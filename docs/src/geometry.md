# AbstractGeometry

Any `AbstractGeometry` subtype will have a bounding box and associated methods. It will also support the [transformation interface](./transformations.md).

```@docs
    DeviceLayout.AbstractGeometry
    coordinatetype
    bounds(::DeviceLayout.AbstractGeometry)
    center(::DeviceLayout.AbstractGeometry)
    lowerleft
    upperright
    footprint
```

There are three important subtypes of `AbstractGeometry`: `GeometryEntity`, `GeometryStructure`, and `GeometryReference`.

## Entities

Entities are "simple" geometric elements. An entity can be placed in a single layer and rendered to an output model. For example, rendering a `Rectangle` to a `Cell` creates a `Polygon` representation suitable for the GDSII format.

```@docs
DeviceLayout.GeometryEntity
DeviceLayout.to_polygons
halo(::GeometryEntity, ::Any, ::Any)
```

Entity subtypes include [`AbstractPolygon`](./polygons.md) (`Polygon` and `Rectangle`) and the individual pieces ("nodes") of a [`Path`](./paths.md).

## Structures

Structures are "composite" geometric objects, containing any number of `GeometryEntity` elements and their metadata, accessed with the `elements` and `element_metadata` methods. They can also contain references to other structures, accessed with `refs`. Structures also have a `name` can be `flatten`ed. Metadata can be recursively changed in-place with `map_metadata!` or in a copy with `map_metadata`. The type parameter of a `GeometryStructure` determines the coordinate type of its elements.

```@docs
DeviceLayout.GeometryStructure
elements(::DeviceLayout.GeometryStructure)
elementtype(::DeviceLayout.GeometryStructure)
element_metadata(::DeviceLayout.GeometryStructure)
map_metadata
map_metadata!
name(::DeviceLayout.GeometryStructure)
refs(::DeviceLayout.GeometryStructure)
```

### Unique names

It's generally desirable to give unique names to structures. In particular, the GDSII format references cells by name, leading to errors or undefined behavior if different cells have the same name. The `uniquename` function makes it possible to ensure unique names on a per-Julia-session basis or until `reset_uniquename!` resets the name counter. Structures that are not constructed directly by the user will generally have names generated by `uniquename`.

```@docs
    uniquename
    reset_uniquename!
```

## References

References point to a `structure` together with a `transformation` that positions it relative to the structure holding the reference. An `ArrayReference` also contains parameters specifying a 2d grid of instantiations of the referenced structure. The methods `sref` and `aref` are convenient for creating `StructureReference`s and `ArrayReference`s, respectively.

```@docs
DeviceLayout.GeometryReference
StructureReference
ArrayReference
copy(::DeviceLayout.GeometryReference)
aref
sref
structure
transformation(::DeviceLayout.GeometryReference)
origin(::DeviceLayout.GeometryReference)
mag(::DeviceLayout.GeometryReference)
rotation(::DeviceLayout.GeometryReference)
xrefl(::DeviceLayout.GeometryReference)
```

### Resolving references

If a structure contains a reference somewhere in its reference hierarchy,
we can use `transformation` to find the total transformation of that
reference relative to the top-level structure:

```@docs
    transformation(::DeviceLayout.GeometryStructure, ::DeviceLayout.GeometryReference)
    transformation(c::DeviceLayout.GeometryStructure, d::DeviceLayout.GeometryReference, e::DeviceLayout.GeometryReference, f::DeviceLayout.GeometryReference...)
```

### Flattening

Sometimes it's also helpful to use an operation called "flattening" to produce an equivalent coordinate system with no referencesâ€”that is, with all its elements at the top level.

```@docs
    flatten(::DeviceLayout.GeometryStructure)
    flatten(::DeviceLayout.GeometryReference)
```

These methods take a `metadata_filter` keyword argument, which is a function that can be generated using `layer_inclusion` and lists of layers to include or ignore:

```@docs
    layer_inclusion
```

For convenience, if you want to get just the list of elements in a flattened structure that match a layer or set of layers, you can use `flat_elements`:

```@docs
    flat_elements
```

### Indexing

For convenience, you can get referenced structures by indexing their parent with the structure name, as in `cs["referenced_cs"]["deeper_cs"]`.

```@docs
    Base.getindex(::DeviceLayout.GeometryStructure, ::AbstractString, ::Integer)
    Base.getindex(::DeviceLayout.GeometryReference, ::AbstractString, ::Integer)
```
