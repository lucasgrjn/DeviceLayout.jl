var documenterSearchIndex = {"docs":
[{"location":"entitystyles/#Styled-geometry-entities","page":"Entity Styles","title":"Styled geometry entities","text":"","category":"section"},{"location":"entitystyles/","page":"Entity Styles","title":"Entity Styles","text":"Entities can also be \"styled\"—paired with a GeometryEntityStyle. This creates a StyledEntity <: GeometryEntity that still supports the entity interface (including the ability to be styled).","category":"page"},{"location":"entitystyles/","page":"Entity Styles","title":"Entity Styles","text":"DeviceLayout.GeometryEntityStyle\nDeviceLayout.StyledEntity\nDeviceLayout.entity\nDeviceLayout.style(::DeviceLayout.StyledEntity)\nDeviceLayout.styled\nDeviceLayout.unstyled\nDeviceLayout.unstyled_type","category":"page"},{"location":"entitystyles/#DeviceLayout.GeometryEntityStyle","page":"Entity Styles","title":"DeviceLayout.GeometryEntityStyle","text":"abstract type GeometryEntityStyle\n\nA style that can be used with a GeometryEntity to create a modified entity.\n\nMay use (sty::MyStyle)(ent), styled(ent, sty), or MyStyle(ent, style_args...; style_kwargs...) to create a StyledEntity.\n\nA GeometryEntityStyle should implement to_polygons(::MyEntity, ::MyStyle; kwargs...) for any entity type it can be applied to. As a fallback, it can implement to_polygons(::Polygon, ::MyStyle; kwargs...), in which case entities will be converted to polygons before applying the style.\n\nUnless implemented by the style, lowerleft and upperright (and hence bounds) of a styled entity will use the underlying entity's bounds.\n\n\n\n\n\n","category":"type"},{"location":"entitystyles/#DeviceLayout.StyledEntity","page":"Entity Styles","title":"DeviceLayout.StyledEntity","text":"StyledEntity{T, U <: GeometryEntity{T}, S <: GeometryEntityStyle} <: GeometryEntity\n\nGeometryEntity composing another GeometryEntity with a GeometryEntityStyle.\n\nThe use of a StyledEntity allows the composition of operations like rounding on geometric entities without committing to a particular representation of those entities.\n\n\n\n\n\n","category":"type"},{"location":"entitystyles/#DeviceLayout.entity","page":"Entity Styles","title":"DeviceLayout.entity","text":"entity(styled_ent::StyledEntity)\n\nReturn the GeometryEntity styled by styled_ent.\n\n\n\n\n\n","category":"function"},{"location":"entitystyles/#DeviceLayout.style-Tuple{DeviceLayout.StyledEntity}","page":"Entity Styles","title":"DeviceLayout.style","text":"style(styled_ent::StyledEntity)\n\nReturn the GeometryEntityStyle of styled_ent.\n\n\n\n\n\n","category":"method"},{"location":"entitystyles/#DeviceLayout.styled","page":"Entity Styles","title":"DeviceLayout.styled","text":"styled(ent, sty)\n\nReturn StyledEntity(ent, sty).\n\n\n\n\n\n","category":"function"},{"location":"entitystyles/#DeviceLayout.unstyled","page":"Entity Styles","title":"DeviceLayout.unstyled","text":"unstyled(styled_ent::StyledEntity)\n\nReturn the unstyled entity referenced by styled_ent.\n\nIf styled_ent.ent is itself a StyledEntity, apply unstyled recursively until the original plain GeometyEntity is found.\n\n\n\n\n\n","category":"function"},{"location":"entitystyles/#DeviceLayout.unstyled_type","page":"Entity Styles","title":"DeviceLayout.unstyled_type","text":"unstyled_type(::GeometryEntity)\nunstyled_type(::Type{GeometryEntity})\n\nReturn the type of the unstyled entity beneath all styles.\n\n\n\n\n\n","category":"function"},{"location":"entitystyles/#Basic-styles","page":"Entity Styles","title":"Basic styles","text":"","category":"section"},{"location":"entitystyles/","page":"Entity Styles","title":"Entity Styles","text":"The styles below can be applied to most entities for generic purposes.","category":"page"},{"location":"entitystyles/","page":"Entity Styles","title":"Entity Styles","text":"DeviceLayout.Plain\nDeviceLayout.MeshSized\nDeviceLayout.meshsized_entity\nDeviceLayout.NoRender\nDeviceLayout.OptionalStyle\nDeviceLayout.optional_entity\nDeviceLayout.ToTolerance","category":"page"},{"location":"entitystyles/#DeviceLayout.Plain","page":"Entity Styles","title":"DeviceLayout.Plain","text":"Plain <: GeometryEntityStyle\n\nPlain style. Does not affect rendering of the styled entity.\n\n\n\n\n\n","category":"type"},{"location":"entitystyles/#DeviceLayout.MeshSized","page":"Entity Styles","title":"DeviceLayout.MeshSized","text":"struct MeshSized{T, S} <: GeometryEntityStyle where {T, S <: Real}\n    h::T\n    α::S\nend\n\nStyle that annotates a GeometryEntity with a mesh size to use in SolidModel rendering. The generated mesh will include a size field defined as:\n\nmesh size = `h` * max(`s_g`, (d/`h`)^`α`)\n\nwhere d is the distance away from the styled entity, and s_g is the global mesh scale parameter specified in MeshingParameters. A smaller value of h will give a finer mesh attached to the styled entity, and a larger value of α will give a more rapid increase in size away from the styled entity.\n\nFor α < 0, the size field will use α_default from the MeshingParameters used in rendering.\n\nSee also meshsized_entity and SolidModels.MeshingParameters.\n\n\n\n\n\n","category":"type"},{"location":"entitystyles/#DeviceLayout.meshsized_entity","page":"Entity Styles","title":"DeviceLayout.meshsized_entity","text":"meshsized_entity(ent::GeometryEntity, h::T, α::S=-1.0) where {T, S <: Real}\n\nCreate a MeshSized entity, specifying a mesh size use in SolidModel rendering. The generated mesh will include a size field defined as:\n\nmesh size = `h` * max(`s_g`, (d/`h`)^`α`)\n\nwhere d is the distance away from the styled entity, and s_g is the global mesh scale parameter specified in MeshingParameters. A smaller value of h will give a finer mesh attached to the styled entity, and a larger value of α will give a more rapid increase in size away from the styled entity.\n\nFor α < 0, the size field will use α_default from the SolidModels.MeshingParameters used in rendering.\n\n\n\n\n\n","category":"function"},{"location":"entitystyles/#DeviceLayout.NoRender","page":"Entity Styles","title":"DeviceLayout.NoRender","text":"NoRender <: GeometryEntityStyle\n\nStyle that marks an entity to be skipped when rendering.\n\n\n\n\n\n","category":"type"},{"location":"entitystyles/#DeviceLayout.OptionalStyle","page":"Entity Styles","title":"DeviceLayout.OptionalStyle","text":"struct OptionalStyle <: GeometryEntityStyle\n    true_style::GeometryEntityStyle\n    false_style::GeometryEntityStyle\n    flag::Symbol\n    default::Bool\nend\nOptionalStyle(true_style::GeometryEntityStyle, flag::Symbol;\n    false_style::GeometryEntityStyle=Plain(), default::Bool=true)\n\nStyle that depends on a Boolean rendering option flag with default default.\n\nExamples\n\nsty = OptionalStyle(Rounded(1μm), :rounding)\np = Rectangle(4μm, 4μm)\nrounded_rect = to_polygons(sty(p))\nplain_rect = to_polygons(sty(p), rounding=false)\n\n\n\n\n\n","category":"type"},{"location":"entitystyles/#DeviceLayout.optional_entity","page":"Entity Styles","title":"DeviceLayout.optional_entity","text":"optional_entity(ent::GeometryEntity, flag::Symbol;\n    true_style::GeometryEntityStyle=Plain(), default=true)\n\nReturn an entity to be rendered or not based on the rendering option flag.\n\nExample\n\njulia> c = Cell();\n\njulia> ent = optional_entity(Rectangle(2, 2), :optional_entities; default=false);\n\njulia> render!(c, ent);\n\njulia> length(elements(c))\n0\n\njulia> render!(c, ent; optional_entities=true);\n\njulia> length(elements(c))\n1\n\n\n\n\n\n","category":"function"},{"location":"entitystyles/#DeviceLayout.ToTolerance","page":"Entity Styles","title":"DeviceLayout.ToTolerance","text":"struct ToTolerance{T<:Coordinate} <: GeometryEntityStyle\n    atol::T\nend\n\nStyle for rendering an entity to absolute tolerance atol.\n\nEquivalent to passing or overriding the keyword atol when rendering this entity.\n\n\n\n\n\n","category":"type"},{"location":"entitystyles/","page":"Entity Styles","title":"Entity Styles","text":"AbstractPolygons also have the Polygons.Rounded style, while ClippedPolygons have Polygons.StyleDict.","category":"page"},{"location":"texts/#Texts","page":"Texts","title":"Texts","text":"","category":"section"},{"location":"texts/","page":"Texts","title":"Texts","text":"There are two ways to generate text in device layouts. The first way is to generate polygons that look like fonts, which will ensure that the text can be fabricated. This is handled by functionality in the PolyText module.","category":"page"},{"location":"texts/","page":"Texts","title":"Texts","text":"The second way is to generate \"text elements,\" which are more like annotations to save metadata into layout files. This is implemented in the Texts module.","category":"page"},{"location":"texts/#PolyText","page":"Texts","title":"PolyText","text":"","category":"section"},{"location":"texts/","page":"Texts","title":"Texts","text":"DeviceLayout.jl provides a few styles for rendering text as polygons. polytext! will render a string to a cell with options that depend on the style. The DotMatrix style provides more options than the styles derived from fonts, which only take a character width and Meta type.","category":"page"},{"location":"texts/","page":"Texts","title":"Texts","text":"Three functions characters_demo, scripted_demo, referenced_characters_demo are exported for demonstration but they also serve as a test of the functionality.","category":"page"},{"location":"texts/","page":"Texts","title":"Texts","text":"    DotMatrix\n    PolyTextComic\n    PolyTextSansMono\n    polytext\n    polytext!\n    characters_demo\n    scripted_demo\n    referenced_characters_demo","category":"page"},{"location":"texts/#DeviceLayout.PolyText.DotMatrix","page":"Texts","title":"DeviceLayout.PolyText.DotMatrix","text":"DotMatrix(; pixelsize, pixelspacing=pixelsize,\n            rounding=zero(pixelsize), meta::Meta=GDSMeta(0,0))\n\nKeyword args\n\npixelsize: dimension for the width/height of each pixel.\npixelspacing: dimension for the spacing between adjacent pixels. Should be ≥ pixelsize. Defaults to pixelsize.\nrounding: rounding radius for sharp corners of pixels. If pixelsize == pixelspacing, individual pixels are not rounded, but rather the pixels are unioned and the entire letter will be rounded.\nmeta: layer/datatype or similar info.\n\n\n\n\n\n","category":"type"},{"location":"texts/#DeviceLayout.PolyText.PolyTextComic","page":"Texts","title":"DeviceLayout.PolyText.PolyTextComic","text":"PolyTextComic(charwidth, meta)\n\nPolyText style derived from the Comic Neue Regular font (Open Font License).\n\n\n\n\n\n","category":"type"},{"location":"texts/#DeviceLayout.PolyText.PolyTextSansMono","page":"Texts","title":"DeviceLayout.PolyText.PolyTextSansMono","text":"PolyTextSansMono(charwidth, meta)\n\nPolyText style derived from the Noto Sans Mono Regular font (Open Font License).\n\n\n\n\n\n","category":"type"},{"location":"texts/#DeviceLayout.PolyText.polytext","page":"Texts","title":"DeviceLayout.PolyText.polytext","text":"polytext(str::String, sty::PolyText.Style;\n    scripting=false, linelimit=typemax(Int), verbose=false) where {T}\n\nRenders the string str to a new coordinate system in a given style.\n\nKeyword args\n\nscripting: boolean parameter for allocating special characters ^, _, {, and }  for superscripting and subscripting. Follows the same usage as LaTeX.\nlinelimit: sets the maximum number of characters per line and continues on a new line  if str is longer than linelimit.\nverbose: prints out information about the character dictionary.\n\n\n\n\n\n","category":"function"},{"location":"texts/#DeviceLayout.PolyText.polytext!","page":"Texts","title":"DeviceLayout.PolyText.polytext!","text":"polytext!(c::AbstractCoordinateSystem, str::String, sty::PolyText.Style;\n    scripting=false, linelimit=typemax(Int), verbose=false)\n\nRenders the string str to cell or coordinate system c in a given style.\n\nKeyword args\n\nscripting: boolean parameter for allocating special characters ^, _, {, and }  for superscripting and subscripting. Follows the same usage as LaTeX.\nlinelimit: sets the maximum number of characters per line and continues on a new line  if str is longer than linelimit.\nverbose: prints out information about the character dictionary.\n\n\n\n\n\n","category":"function"},{"location":"texts/#DeviceLayout.PolyText.characters_demo","page":"Texts","title":"DeviceLayout.PolyText.characters_demo","text":"characters_demo(save_path = joinpath(homedir(),\"Desktop\",\"characters.gds\"), flatten = false)\n\nDemo script for demonstrating the available characters in polytext! and the linelimit parameter in use. flatten can flatten the cells before saving (for SVG output).\n\n\n\n\n\n","category":"function"},{"location":"texts/#DeviceLayout.PolyText.scripted_demo","page":"Texts","title":"DeviceLayout.PolyText.scripted_demo","text":"scripted_demo(save_path = joinpath(homedir(),\"Desktop\",\"scripted.gds\"), flatten = false)\n\nDemo script for demonstrating the use of the scripting parameter in polytext!. flatten can flatten the cells before saving (for SVG output).\n\n\n\n\n\n","category":"function"},{"location":"texts/#DeviceLayout.PolyText.referenced_characters_demo","page":"Texts","title":"DeviceLayout.PolyText.referenced_characters_demo","text":"referenced_characters_demo(save_path = joinpath(homedir(),\"Desktop\",\"referenced_characters.gds\");\n    verbose_override = false)\n\nDemo script for demonstrating the memory saving ability of keeping CellReferences for previously used characters in polytext!. Nothing is printed if verbose_override is true.\n\n\n\n\n\n","category":"function"},{"location":"texts/","page":"Texts","title":"Texts","text":"The fonts are generated by first converting characters from a TrueType font to a GDS file. This is done with the help of external layout tools. These characters are mono-spaced in 100µm x 200µm boxes, with cuts made to connect any interior islands within the characters to the outside. Following this, DeviceLayout.PolyText.format_gds is used to chop up the file into one character per Cell and then save the result for use by DeviceLayout.jl. All of these files are stored in deps/. To define a new font you need to make a new subtype and implement a few methods following the example in src/polytext/polytext.jl.","category":"page"},{"location":"texts/","page":"Texts","title":"Texts","text":"using DeviceLayout, DeviceLayout.PreferredUnits, FileIO # hide\nimport DeviceLayout.Graphics: inch\ncs = CoordinateSystem(\"cs\", nm)\npolytext!(cs, \"AaBbCcDdEe\", DotMatrix(; pixelsize=20μm, rounding=6μm))\nsave(\"dotmatrix_rounded_nosep.svg\", flatten(Cell(cs, nm)), width=6inch, height=1inch);\nnothing; # hide","category":"page"},{"location":"texts/","page":"Texts","title":"Texts","text":"<img src=\"../dotmatrix_rounded_nosep.svg\", style=\"width:6in;\"/>","category":"page"},{"location":"texts/","page":"Texts","title":"Texts","text":"cs = CoordinateSystem(\"cs\", nm)\npolytext!(cs, \"AaBbCcDdEe\", DotMatrix(; pixelsize=20μm, pixelspacing=30μm, rounding=6μm))\nsave(\"dotmatrix_rounded.svg\", flatten(Cell(cs, nm)), width=6inch, height=1inch);\nnothing; # hide","category":"page"},{"location":"texts/","page":"Texts","title":"Texts","text":"<img src=\"../dotmatrix_rounded.svg\", style=\"width:6in;\"/>","category":"page"},{"location":"texts/","page":"Texts","title":"Texts","text":"cs = CoordinateSystem(\"cs\", nm)\npolytext!(cs, \"AaBbCcDdEe\", DotMatrix(; pixelsize=20μm, meta=GDSMeta(1)))\nsave(\"dotmatrix.svg\", flatten(Cell(cs, nm)), width=6inch, height=1inch);\nnothing; # hide","category":"page"},{"location":"texts/","page":"Texts","title":"Texts","text":"<img src=\"../dotmatrix.svg\", style=\"width:6in;\"/>","category":"page"},{"location":"texts/","page":"Texts","title":"Texts","text":"cs = CoordinateSystem(\"cs\", nm)\npolytext!(cs, \"AaBbCcDdEe\", PolyTextSansMono(20μm, GDSMeta(0)))\nsave(\"sansmono.svg\", flatten(Cell(cs, nm)), width=6inch, height=1inch);\nnothing; # hide","category":"page"},{"location":"texts/","page":"Texts","title":"Texts","text":"<img src=\"../sansmono.svg\", style=\"width:6in;\"/>","category":"page"},{"location":"texts/","page":"Texts","title":"Texts","text":"cs = CoordinateSystem(\"cs\", nm)\npolytext!(cs, \"AaBbCcDdEe\", PolyTextComic(20μm, GDSMeta(0)))\nsave(\"comic.svg\", flatten(Cell(cs, nm)), width=6inch, height=1inch);\nnothing; # hide","category":"page"},{"location":"texts/","page":"Texts","title":"Texts","text":"<img src=\"../comic.svg\", style=\"width:6in;\"/>","category":"page"},{"location":"texts/#Inline-demonstrations","page":"Texts","title":"Inline demonstrations","text":"","category":"section"},{"location":"texts/","page":"Texts","title":"Texts","text":"using DeviceLayout, FileIO # hide\npath_to_output_gds = \"characters.svg\" # hide\ncharacters_demo(path_to_output_gds, true)","category":"page"},{"location":"texts/","page":"Texts","title":"Texts","text":"<img src=\"../characters.svg\" style=\"width:6in;\"/>","category":"page"},{"location":"texts/","page":"Texts","title":"Texts","text":"using DeviceLayout, FileIO # hide\npath_to_output_gds = \"scripted.svg\" # hide\nscripted_demo(path_to_output_gds, true);","category":"page"},{"location":"texts/","page":"Texts","title":"Texts","text":"<img src=\"../scripted.svg\" style=\"width:4in;\"/>","category":"page"},{"location":"texts/#Texts-2","page":"Texts","title":"Texts","text":"","category":"section"},{"location":"texts/","page":"Texts","title":"Texts","text":"    Texts.Text\n    text!","category":"page"},{"location":"texts/#DeviceLayout.Texts.Text","page":"Texts","title":"DeviceLayout.Texts.Text","text":"Text{S} <: GeometryEntity{S}\n\nText element in a layout. Distinct from rendering text as polygons (PolyText).\n\nArguments:\n\ntext: the text string.\norigin: location of the text in parent coordinate system.\nwidth: character width\ncan_scale: defaults to false, set to true if the text size should not be affected by scaling of parent coordinate system.\nxalign: horizontal alignment of text with respect to origin. Can be any instance of abstract type Align.XAlignRule and defaults to LeftEdge().\nyalign: vertical alignment of text with respect to origin. Can be any instance of abstract type Align.YAlignRule and defaults to TopEdge().\nxrefl: Reflect across x-axis. Defaults to false.\nmag: Magnification factor.\nrot: Rotation in radians.\n\n\n\n\n\n","category":"type"},{"location":"texts/#DeviceLayout.Cells.text!","page":"Texts","title":"DeviceLayout.Cells.text!","text":"text!(c::Cell{S}, str::String, origin::Point=zero(Point{S}), meta::Meta=GDSMeta(); kwargs...) where {S}\n\nAnnotate cell c with string str as a text element. See also polytext! for rendering strings as polygons.\n\n\n\n\n\ntext!(c::Cell, text::Texts.Text, meta)\n\nAnnotate cell c with Texts.Text object.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/solidmodels/#Solid-Models","page":"Solid Models","title":"Solid Models","text":"","category":"section"},{"location":"schematicdriven/solidmodels/","page":"Solid Models","title":"Solid Models","text":"A Schematic can be rendered to a SolidModel, creating a 3D geometry corresponding to the schematic, which can then be exported to a standard 3D format. This is analogous to rendering the Schematic to a Cell in preparation for GDS export.","category":"page"},{"location":"schematicdriven/solidmodels/","page":"Solid Models","title":"Solid Models","text":"render!(::DeviceLayout.SolidModel, ::SchematicDrivenLayout.Schematic, ::SchematicDrivenLayout.Target; kwargs...)","category":"page"},{"location":"schematicdriven/solidmodels/#DeviceLayout.render!-Tuple{SolidModel, DeviceLayout.SchematicDrivenLayout.Schematic, DeviceLayout.SchematicDrivenLayout.Target}","page":"Solid Models","title":"DeviceLayout.render!","text":"render!(sm::SolidModel, sch::Schematic, target::Target; strict=:error, kwargs...)\n\nRender sch to sm, using rendering settings from target.\n\nThe strict keyword should be :error, :warn, or :no.\n\nThe strict=:error keyword option causes render! to throw an error if any errors were logged while building component geometries or while rendering geometries to cs. This is enabled by default, but can be disabled with strict=:no, in which case any component which was not successfully built will have an empty geometry, and any non-fatal rendering errors will be ignored as usual. Using strict=:no is recommended only for debugging purposes.\n\nThe strict=:warn keyword option causes render! to throw an error if any warnings were logged. This is disabled by default. Using strict=:warn is suggested for use in automated pipelines, where warnings may require human review.\n\nAdditional keyword arguments may be used for certain entity types for controlling how geometry entities are converted to primitives and added to sm.\n\n\n\n\n\n","category":"method"},{"location":"schematicdriven/solidmodels/","page":"Solid Models","title":"Solid Models","text":"We use a SolidModelTarget to specify how a 2D geometry is rendered to 3D entities and physical groups. This is analogous to the use of a LayoutTarget in Cell rendering, which specifies how to render entities with semantic metadata to Cell polygons and GDS layers.","category":"page"},{"location":"schematicdriven/solidmodels/","page":"Solid Models","title":"Solid Models","text":"SchematicDrivenLayout.SolidModelTarget","category":"page"},{"location":"schematicdriven/solidmodels/#DeviceLayout.SchematicDrivenLayout.SolidModelTarget","page":"Solid Models","title":"DeviceLayout.SchematicDrivenLayout.SolidModelTarget","text":"struct SolidModelTarget <: Target\n    technology::ProcessTechnology\n    bounding_layers::Vector{Symbol}\n    levelwise_layers::Vector{Symbol}\n    indexed_layers::Vector{Symbol}\n    substrate_layers::Vector{Symbol}\n    rendering_options::NamedTuple\n    postrenderer\nend\n\nContains information about how to render a Schematic to a 3D SolidModel.\n\nThe technology contains parameters like layer heights and thicknesses that are used to position and extrude 2D geometry elements.\n\nThe rendering_options include any keyword arguments to be passed down to the lower-level render!(::SolidModel, ::CoordinateSystem; kwargs...). The target also includes some 3D-specific options:\n\nbounding_layers: A list of layer Symbols. These layers are extruded according to technology to define the rendered volume, and then all other layers and technology-based extrusions are replaced with their intersection with the rendered volume.\nlevelwise_layers: A list of layer Symbols to be turned into PhysicalGroups \"levelwise\". That is, rather than create a single PhysicalGroup for all entities with the given layer symbol, a group is created for each level value l with \"_L$l\" appended.\nindexed_layers: A list of layer Symbols to be turned into separate PhysicalGroups with \"_$i\" appended for each index i. These layers will be automatically indexed if not already present in a Schematic's index_dict.\nsubstrate_layers: A list of layer Symbols for layers that are extruded by their technology into the substrate, rather than away from it.\n\nThe postrenderer is a list of geometry kernel commands that create new named groups of entities from other groups, for example by geometric Boolean operations like intersection. These follow the extrusions and bounding_layers intersections generated according to the technology and rendering_options.\n\n\n\n\n\n","category":"type"},{"location":"schematicdriven/solidmodels/","page":"Solid Models","title":"Solid Models","text":"Rendering using the SolidModelTarget applies the rendering option solidmodel=true. A pair of functions are provided for designating entities to be rendered or not based on that option (using DeviceLayout.OptionalStyle):","category":"page"},{"location":"schematicdriven/solidmodels/","page":"Solid Models","title":"Solid Models","text":"SchematicDrivenLayout.not_solidmodel\nSchematicDrivenLayout.only_solidmodel","category":"page"},{"location":"schematicdriven/solidmodels/#DeviceLayout.SchematicDrivenLayout.not_solidmodel","page":"Solid Models","title":"DeviceLayout.SchematicDrivenLayout.not_solidmodel","text":"not_solidmodel(ent::GeometryEntity)\n\nReturn a version of ent that is rendered unless solidmodel=true in the rendering options.\n\nThe solidmodel option can be set as a keyword argument to render! or as an element in rendering_options in the Target provided to render!.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/solidmodels/#DeviceLayout.SchematicDrivenLayout.only_solidmodel","page":"Solid Models","title":"DeviceLayout.SchematicDrivenLayout.only_solidmodel","text":"only_solidmodel(ent::GeometryEntity)\n\nReturn a GeometryEntity that is rendered if and only if solidmodel=true in the rendering options.\n\nThe solidmodel option can be set as a keyword argument to render! or as an element in rendering_options in the Target provided to render!.\n\n\n\n\n\n","category":"function"},{"location":"units/#Units","page":"Units","title":"Units","text":"","category":"section"},{"location":"units/","page":"Units","title":"Units","text":"DeviceLayout.jl uses Unitful.jl to support writing code with explicit units.","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"In general, geometric types are parameterized by a coordinatetype, which is either a Real or a Unitful.Length (for example, typeof(1.0nm)). We want to ensure that unitful numbers in a geometry have a common representation, allowing more efficient manipulation and avoiding unnecessary conversions and compilations.","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"Recall the quick-start example from the home page:","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"using DeviceLayout, DeviceLayout.PreferredUnits, FileIO\n\ncr = Cell(\"rect\", nm)\nr = centered(Rectangle(20μm, 40μm))\nrender!(cr, r, GDSMeta(1, 0))\np = Path(μm)\nsty = launch!(p)\nstraight!(p, 500μm, sty)\nturn!(p, π / 2, 150μm)\nstraight!(p, 500μm)\nlaunch!(p)\ncp = Cell(\"pathonly\", nm)\nrender!(cp, p, GDSMeta(0))\nturnidx = Int((length(p) + 1) / 2) - 1 # the first straight segment of the path\nsimplify!(p, turnidx .+ (0:2))\nattach!(\n    p,\n    CellReference(cr, Point(0.0μm, 0.0μm)),\n    (40μm):(40μm):((pathlength(p[turnidx])) - 40μm),\n    i=turnidx\n)\nc = Cell(\"decoratedpath\", nm)\nrender!(c, p, GDSMeta(0))","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"<img src=\"../units.svg\" style=\"width: 3in;\"/>","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"The example begins with using DeviceLayout.PreferredUnits, which enables the unqualified use of the following units: pm, nm, μm, mm, cm, dm, m. (By unqualified we mean that the symbols are imported into the calling namespace and do not need to be prefixed with a module name. using DeviceLayout also gives you ° and rad for angles.) DeviceLayout.PreferredUnits is, by default, an alias for DeviceLayout.PreferNanometers. This means that when adding length units together, if the units don't agree, the result will be in nanometers.","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"You can instead do using DeviceLayout.PreferMicrons if you want the result to default to microns. This is simple and effective, but does not enforce consistency across large projects like process design kits (PDKs) or layout scripts with multiple modules that might accidentally import units in different ways. Accordingly, DeviceLayout.jl provides a slightly more sophisticated method to specify alternative preferences using a configuration setting applied at compilation time, which is described below.","category":"page"},{"location":"units/#Unit-preferences","page":"Units","title":"Unit preferences","text":"","category":"section"},{"location":"units/","page":"Units","title":"Units","text":"By default, DeviceLayout will be compiled with using .PreferNanometers internally. If you then import units from DeviceLayout","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"using DeviceLayout.PreferredUnits","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"or, more explicitly,","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"import DeviceLayout: nm, μm, mm #, ...","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"you get the unqualified units as described above. This also defines const UPREFERRED = DeviceLayout.PreferNanometers.nm. In the handful of places that UPREFERRED appears in DeviceLayout.jl (convenience constructors and type aliases allowing users to omit explicit unit specification), it'll then be ContextUnits that prefers to be converted to nanometers.","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"If you want different behavior, then the recommended practice is to specify a unit preference as a package preference and then import unit symbols from DeviceLayout. That is, if you put a file called LocalPreferences.toml in the root of a project directory with","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"[DeviceLayout]\nunits = \"PreferMicrons\"","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"then DeviceLayout will be compiled with using .PreferMicrons internally. (This is accomplished using Preferences.jl.) That means that DeviceLayout.nm and so on will prefer to be converted to microns, and const UPREFERRED = DeviceLayout.μm.","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"Similarly, if we have the preference units = \"NoUnits\", then DeviceLayout uses import Unitful: nm, ... and const UPREFERRED = Unitful.NoUnits; const PreferredUnits = PreferMicrons internally.","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"    DeviceLayout.UPREFERRED\n    DeviceLayout.PreferMicrons.UPREFERRED\n    DeviceLayout.PreferNoUnits.UPREFERRED","category":"page"},{"location":"units/#DeviceLayout.PreferNanometers.UPREFERRED","page":"Units","title":"DeviceLayout.PreferNanometers.UPREFERRED","text":"const PreferNanometers.UPREFERRED = nm\n\nConstant for DeviceLayout.jl compiled with units = \"PreferNanometers\" in LocalPreferences.toml.\n\nDefault value if no preference specified. Other options are PreferMicrons and NoUnits.\n\n\n\n\n\n","category":"constant"},{"location":"units/#DeviceLayout.PreferMicrons.UPREFERRED","page":"Units","title":"DeviceLayout.PreferMicrons.UPREFERRED","text":"const PreferMicrons.UPREFERRED = μm\n\nConstant for DeviceLayout.jl compiled with units = \"PreferMicrons\" in LocalPreferences.toml.\n\nOther options are PreferNanometers (the default) and NoUnits.\n\n\n\n\n\n","category":"constant"},{"location":"units/#DeviceLayout.PreferNoUnits.UPREFERRED","page":"Units","title":"DeviceLayout.PreferNoUnits.UPREFERRED","text":"const UPREFERRED = Unitful.NoUnits\n\nConstant for DeviceLayout.jl compiled with units = \"NoUnits\" in LocalPreferences.toml.\n\nOther options are PreferNanometers (the default) and PreferMicrons.\n\n\n\n\n\n","category":"constant"},{"location":"units/","page":"Units","title":"Units","text":"You can also set the preference in Project.toml with the following lines:","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"[preferences.DeviceLayout]\nunits = \"PreferMicrons\"","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"Typically, LocalPreferences.toml will be ignored by version control (that is, listed in .gitignore), so you'll use it to set preferences that are only meant to be used locally. If you want preferences to be used by anyone cloning and instantiating your project, then you'll put them in Project.toml.","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"For convenience, you can use DeviceLayout.set_unit_preference! to add the preference to either LocalPreferences.toml or Project.toml.","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"    DeviceLayout.set_unit_preference!","category":"page"},{"location":"units/#DeviceLayout.set_unit_preference!","page":"Units","title":"DeviceLayout.set_unit_preference!","text":"set_unit_preference!(pref::String; local_only=true)\n\nSet the unit preference. pref must be one of \"NoUnits\", \"PreferMicrons\", or \"PreferNanometers\".\n\nIf local_only is true, add the preference to LocalPreferences.toml. Otherwise, add it to Project.toml.\n\nBecause this preference is used at compile time, Julia must be restarted for a change to take effect.\n\n\n\n\n\n","category":"function"},{"location":"units/","page":"Units","title":"Units","text":"Note that only preferences of the active project are applied. For example, if you have a separate package defining your process design kit (PDK), adding the preference to Project.toml does not mean that any project that uses the PDK will inherit that preference. If a PDK is meant to be used with units, you can have it set the preference during package setup:","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"module MyPDK\nusing DeviceLayout\n\nfunction __init__()\n    return DeviceLayout.set_unit_preference!(\"PreferNanometers\"; local_only=false)\nend\n# ...\nend","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"Because the preference is used at compile time, Julia will have to be restarted if the preference was not already set.","category":"page"},{"location":"units/#Example-without-using-units","page":"Units","title":"Example without using units","text":"","category":"section"},{"location":"units/","page":"Units","title":"Units","text":"While units are recommended, it is possible to use DeviceLayout.jl without units at all for compatibility and laziness reasons.","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"If you do not provide units, all values are presumed to be in microns. The syntax is otherwise the same:","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"using DeviceLayout, FileIO\n\ncr = Cell{Float64}(\"rect\") # If unit preference were `NoUnits`, we wouldn't need `{Float64}`\nr = centered(Rectangle(20, 40))\nrender!(cr, r, GDSMeta(1))\n\np = Path{Float64}()\nsty = launch!(p)\nstraight!(p, 500, sty)\nturn!(p, π / 2, 150)\nstraight!(p, 500)\nlaunch!(p)\ncp = Cell{Float64}(\"pathonly\")\nrender!(cp, p, GDSMeta(0))\n\nturnidx = Int((length(p) + 1) / 2) - 1 # the first straight segment of the path\nsimplify!(p, turnidx .+ (0:2))\nattach!(\n    p,\n    CellReference(cr, Point(0.0, 0.0)),\n    40:40:((pathlength(p[turnidx])) - 40),\n    i=turnidx\n)\nc = Cell{Float64}(\"decoratedpath\")\nrender!(c, p, GDSMeta(0))\nflatten(c) # just show using default colors","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"Maintaining unitless functionality alongside unitful functionality takes some care, so you may encounter errors when using unitless geometries, particularly with less mature features. Please file an issue if that happens.","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"tip: Tip\nIt's usually not too hard to write library code that works with or without units. Often it's as simple as making sure you're not overly strict with type annotations and not writing literal coordinate values. For example, use DeviceLayout.Coordinate rather than Unitful.Length if you also want to accept Real values, and use the zero function rather than 0.0nm.","category":"page"},{"location":"units/#Angles","page":"Units","title":"Angles","text":"","category":"section"},{"location":"units/","page":"Units","title":"Units","text":"Throughout the interface, users can provide angles as unitless real numbers, which will be interpreted as radians, or as Unitful numbers using degrees (°, which can be written in the REPL or in VS Code by typing \\degree and hitting the Tab key) or radians (rad), both exported by DeviceLayout.jl. Angles are generally stored internally as degrees.","category":"page"},{"location":"units/#More-on-units","page":"Units","title":"More on units","text":"","category":"section"},{"location":"units/","page":"Units","title":"Units","text":"You cannot mix and match unitful and unitless numbers (the latter are not presumed to be in microns in this case).","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"When you specify the units for a Cell, you are specifying the coordinate type of its elements. Separately, the cell has a database unit stored in its dbscale field, which defaults to 1 nm. Anything rendered into this cell will be discretized into integer multiples of the database unit upon saving to the GDSII format. This means that if the specified unit is nm, nothing smaller than 1 nm can be represented accurately. Nonetheless, this is typically a satisfactory choice for superconducting devices. If you are using a unitless Cell, the database unit will be 0.001 (that is, 1 nm).","category":"page"},{"location":"units/","page":"Units","title":"Units","text":"μ can be input in the REPL or in VS Code by typing \\mu and hitting the Tab key. Some people find it convenient to define const um = DeviceLayout.μm in their scripts.","category":"page"},{"location":"schematicdriven/targets/#Targets","page":"Targets","title":"Targets","text":"","category":"section"},{"location":"schematicdriven/targets/","page":"Targets","title":"Targets","text":"SchematicDrivenLayout.Target\nSchematicDrivenLayout.LayoutTarget\nSchematicDrivenLayout.ArtworkTarget\nSchematicDrivenLayout.SimulationTarget","category":"page"},{"location":"schematicdriven/targets/#DeviceLayout.SchematicDrivenLayout.Target","page":"Targets","title":"DeviceLayout.SchematicDrivenLayout.Target","text":"abstract type Target\n\nA Target can customize behavior during plan, build!, and/or render!.\n\nGiven a target::Target, you would use it like this:\n\ng = SchematicGraph(\"example\")\n# ... build up schematic graph here\nfloorplan = plan(g, target)\ncheck!(floorplan)\nbuild!(floorplan, target)\noutput = Cell(floorplan, target)\n\n\n\n\n\n","category":"type"},{"location":"schematicdriven/targets/#DeviceLayout.SchematicDrivenLayout.LayoutTarget","page":"Targets","title":"DeviceLayout.SchematicDrivenLayout.LayoutTarget","text":"struct LayoutTarget <: Target\n    technology::ProcessTechnology\n    rendering_options::NamedTuple\n    levels::Vector{Int}\n    level_increment::GDSMeta\n    indexed_layers::Vector{Symbol}\n    map_meta_dict::Dict{DeviceLayout.Meta, Union{GDSMeta,Nothing}}\nend\n\nContains information about how to render schematics, typically to a Cell (for the GDSII backend).\n\nA LayoutTarget contains:\n\ntechnology::ProcessTechnology: used to map semantic layers to output layers when rendering to an output format (using layer_record(technology)).\nrendering_options: a NamedTuple of keyword arguments to be supplied to render!\nlevels::Vector{Int}: a list of metadata levels to be rendered\nlevel_increment::GDSMeta: if there are multiple levels in the list, each successive level in the list will have its GDSMeta remapped by this increment\nindexed_layers::Vector{Symbol}: a list of layer symbols whose entities should have GDS datatype incremented by their metadata index, for example to give distinct layers to different port boundaries for simulation\nmap_meta_dict::Dict{SemanticMeta, Union{GDSMeta,Nothing}}: used for memoization of the SemanticMeta -> GDSMeta map; it can also be populated manually to customize behavior\n\nRendering options might include tolerance (atol) or keyword flags like simulation=true that determine how or whether entities with an OptionalStyle with the corresponding flag are rendered.\n\nWhen rendering ent::GeometryEntity with target::LayoutTarget, its metadata m is handled as follows:\n\nIf m is already a GDSMeta, use as is.\nIf target.map_meta_dict[m] exists (as a GDSMeta instance or nothing), use that. This can be manually assigned before rendering, overriding the default that would result from the steps below. If it does not yet exist, then the result of the steps below will be stored in target.map_meta_dict[m].\nIf layer(m) == layer(DeviceLayout.NORENDER_META) (that is, :norender), use nothing.\nIf !(level(m) in target.levels), use nothing.\nIf layer(m) is not present as a key in layer_record(target.technology) and is not of the form :GDS<layer>_<datatype>, then emit a warning and use GDSMeta(0,0), ignoring level and layer index.\nIf layer(m) is not present as a key in layer_record(target.technology) but is of the form :GDS<layer>_<datatype>, then take GDSMeta(layer, datatype) and add any increments according to level(m) and layerindex(m) as below.\nIf layer(m) is present as a key in layer_record(target.technology), then map layer(m) to a GDSMeta or nothing using layer_record(target.technology)[layer(m)]. If the result is nothing, use that. Otherwise, also consider level(m) and layerindex(m) as below.\nIf target.levels has more than one element and level(m) is the nth element, increment the result by (n-1) times the GDS layer and datatype of target.level_increment.\nIf layer(m) in target.indexed_layers, then increment the GDS datatype of the result by layerindex(m).\n\nIf the result is nothing, then ent is not rendered. Here are some examples:\n\njulia> using DeviceLayout, DeviceLayout.SchematicDrivenLayout, DeviceLayout.PreferredUnits\n\njulia> tech = ProcessTechnology((; base_negative=GDSMeta()), (;));\n\njulia> meta = SemanticMeta(:base_negative);\n\njulia> cs = CoordinateSystem(\"test\", nm);\n\njulia> render!.(cs, Ref(Rectangle(10μm, 10μm)), [\n    meta,\n    facing(meta),\n    SemanticMeta(:GDS2_2, index=2, level=2),\n    DeviceLayout.UNDEF_META,\n    DeviceLayout.NORENDER_META,\n    GDSMeta(2, 2)\n    ]);\n\njulia> cell = Cell(\"test\", nm);\n\njulia> render!(cell, cs, ArtworkTarget(tech; levels=[1, 2], indexed_layers=[:GDS2_2]));\n│ ┌ Warning: Target technology does not have a mapping for layer `:undefined`; mapping to GDS layer/datatype 0/0\n│ [...]\n\njulia> cell.element_metadata == [\n    GDSMeta(), # :base_negative => GDSMeta()\n    GDSMeta(300), # :base_negative => GDSMeta() => GDSMeta(300) [level increment]\n    GDSMeta(302, 4), # :GDS2_2 => GDSMeta(2, 2) => GDSMeta(302, 2) [level] => GDSMeta(302, 4) [index]\n    GDSMeta(), # UNDEF_META is not in the layer record, so it's mapped to GDSMeta(0, 0)\n    # NORENDER_META is skipped\n    GDSMeta(2, 2) # GDSMeta(2, 2) is passed through without modification\n    ]\ntrue\n\n\n\n\n\n","category":"type"},{"location":"schematicdriven/targets/#DeviceLayout.SchematicDrivenLayout.ArtworkTarget","page":"Targets","title":"DeviceLayout.SchematicDrivenLayout.ArtworkTarget","text":"ArtworkTarget(technology::ProcessTechnology;\n    rendering_options = (; simulation=false, artwork=true),\n    levels = [1,2],\n    level_increment = GDSMeta(300,0),\n    indexed_layers = Symbol[],\n    map_meta_dict = Dict{SemanticMeta, Union{GDSMeta,Nothing}}()\n)\n\nA LayoutTarget with defaults set for artwork.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/targets/#DeviceLayout.SchematicDrivenLayout.SimulationTarget","page":"Targets","title":"DeviceLayout.SchematicDrivenLayout.SimulationTarget","text":"SimulationTarget(technology::ProcessTechnology;\n    rendering_options = (; simulation=true, artwork=false),\n    levels = [1,2],\n    level_increment = GDSMeta(300,0),\n    indexed_layers = Symbol[],\n    map_meta_dict = Dict{SemanticMeta, Union{GDSMeta,Nothing}}()\n)\n\nA LayoutTarget with defaults set for simulation.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/targets/#Metadata-handling","page":"Targets","title":"Metadata handling","text":"","category":"section"},{"location":"schematicdriven/targets/","page":"Targets","title":"Targets","text":"SchematicDrivenLayout provides the facing and backing functions to be used with a specific interpretation of level in SemanticMeta. The level of a geometric entity describes the vertical index of its substrate surface in a \"flipchip\"-style stack of substrates. Metadata types without a level attribute will default to level 1.","category":"page"},{"location":"schematicdriven/targets/","page":"Targets","title":"Targets","text":"▒    ...        ▒\n▒   level 3 ↓   ▒\n█████████████████\n▒   level 2 ↑   ▒\n▒               ▒\n▒   level 1 ↓   ▒\n█████████████████\n▒   level 0 ↑   ▒","category":"page"},{"location":"schematicdriven/targets/","page":"Targets","title":"Targets","text":"SchematicDrivenLayout.backing\nSchematicDrivenLayout.facing","category":"page"},{"location":"schematicdriven/targets/#DeviceLayout.SchematicDrivenLayout.backing","page":"Targets","title":"DeviceLayout.SchematicDrivenLayout.backing","text":"backing(l::Int)\nbacking(s::SemanticMeta)\nbacking(m::Meta)\n\nThe level backing l or metadata like s in the level backing level(s).\n\nFor example, level 3 backs level 2, so backing(2) == 3 and backing(SemanticMeta(\"lyr\"; level=2)) == SemanticMeta(lyr; level=3)\n\nIf a metadata object m has no layer attribute, then backing(m) == m.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/targets/#DeviceLayout.SchematicDrivenLayout.facing","page":"Targets","title":"DeviceLayout.SchematicDrivenLayout.facing","text":"facing(l::Int)\nfacing(s::SemanticMeta)\nfacing(m::Meta)\n\nThe level facing l or metadata like s in the level facing level(s).\n\nFor example, level 2 faces level 1, so facing(2) == 1 and facing(SemanticMeta(\"lyr\"; level=1)) == SemanticMeta(lyr; level=2)\n\nIf a metadata object m has no layer attribute, then facing(m) == m.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/targets/#Rendering","page":"Targets","title":"Rendering","text":"","category":"section"},{"location":"schematicdriven/targets/","page":"Targets","title":"Targets","text":"A Schematic can be rendered to different geometry representations like Cell or SolidModel using different Targets to control rendering options. See SchematicDrivenLayout.render!(::SchematicDrivenLayout.AbstractCoordinateSystem, ::SchematicDrivenLayout.Schematic, ::SchematicDrivenLayout.LayoutTarget) and SchematicDrivenLayout.render!(::DeviceLayout.SolidModel, ::SchematicDrivenLayout.Schematic, ::SchematicDrivenLayout.Target).","category":"page"},{"location":"schematicdriven/targets/#Rendering-flags","page":"Targets","title":"Rendering flags","text":"","category":"section"},{"location":"schematicdriven/targets/","page":"Targets","title":"Targets","text":"The built-in targets ArtworkTarget and SimulationTarget have the rendering options (artwork=true, simulation=false) and (artwork=false, simulation=true). A pair of functions are provided for designating entities to be rendered or not based on the simulation option (using DeviceLayout.OptionalStyle).","category":"page"},{"location":"schematicdriven/targets/","page":"Targets","title":"Targets","text":"SchematicDrivenLayout.not_simulated\nSchematicDrivenLayout.only_simulated","category":"page"},{"location":"schematicdriven/targets/#DeviceLayout.SchematicDrivenLayout.not_simulated","page":"Targets","title":"DeviceLayout.SchematicDrivenLayout.not_simulated","text":"not_simulated(ent::GeometryEntity)\n\nReturn a version of ent that is rendered unless simulation=true in the rendering options.\n\nThe simulation option can be set as a keyword argument to render! or as an element in rendering_options in the Target provided to render!.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/targets/#DeviceLayout.SchematicDrivenLayout.only_simulated","page":"Targets","title":"DeviceLayout.SchematicDrivenLayout.only_simulated","text":"only_simulated(ent::GeometryEntity)\n\nReturn a GeometryEntity that is rendered if and only if simulation=true in the rendering options.\n\nThe simulation option can be set as a keyword argument to render! or as an element in rendering_options in the Target provided to render!.\n\n\n\n\n\n","category":"function"},{"location":"points/","page":"Points","title":"Points","text":"DocTestSetup = quote\n    using Unitful, DeviceLayout\n    using Unitful: °\nend","category":"page"},{"location":"points/#Points","page":"Points","title":"Points","text":"","category":"section"},{"location":"points/","page":"Points","title":"Points","text":"Points live in a Cartesian coordinate system with Real or Unitful.Length coordinates:","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"julia> Point(1, 1)\n2-element Point{Int64} with indices SOneTo(2):\n 1\n 1\n\njulia> Point(1.0, 1.0)\n2-element Point{Float64} with indices SOneTo(2):\n 1.0\n 1.0\n\njulia> Point(1.0u\"μm\", 1.0u\"μm\")\n2-element Point{Quantity{Float64, 𝐋, Unitful.FreeUnits{(μm,), 𝐋, nothing}}} with indices SOneTo(2):\n 1.0 μm\n 1.0 μm","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"If a point has Real coordinates, the absence of a unit is interpreted to mean μm whenever the geometry is saved to a GDS format, but until then it is just considered to be a pure number. Therefore you cannot mix and match Real and Length coordinates:","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"julia> Point(1.0u\"μm\", 1.0)\nERROR: Cannot use `Point` with this combination of types.","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"You can add Points together or scale them:","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"julia> 3 * Point(1, 1) + Point(1, 2)\n2-element Point{Int64} with indices SOneTo(2):\n 4\n 5","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"You can also do affine transformations by composing any number of Translation and Rotations, which will return a callable object representing the transformation. You can type the following Unicode symbols with \\degree and \\circ tab-completions in the Julia REPL or using the Atom package latex-completions.","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"julia> aff = Rotation(90°) ∘ Translation(Point(1, 2))\nAffineMap([0.0 -1.0; 1.0 0.0], (-2.0,1.0))\n\njulia> aff(Point(0, 0))\n2-element Point{Float64} with indices SOneTo(2):\n -2.0\n  1.0","category":"page"},{"location":"points/#API","page":"Points","title":"API","text":"","category":"section"},{"location":"points/","page":"Points","title":"Points","text":"    DeviceLayout.PointTypes\n    DeviceLayout.Coordinate\n    Points.Point\n    Points.getx\n    Points.gety\n    Points.lowerleft(::AbstractArray{Point{T}}) where T\n    Points.upperright(::AbstractArray{Point{T}}) where T","category":"page"},{"location":"points/#DeviceLayout.PointTypes","page":"Points","title":"DeviceLayout.PointTypes","text":"PointTypes = Union{Real, DimensionlessQuantity, Length, InverseLength}\n\nAllowed type variables for Point{T} types.\n\n\n\n\n\n","category":"type"},{"location":"points/#DeviceLayout.Coordinate","page":"Points","title":"DeviceLayout.Coordinate","text":"Coordinate = Union{Real, Length}\n\nType alias for numeric types suitable for coordinate systems.\n\n\n\n\n\n","category":"type"},{"location":"points/#DeviceLayout.Points.Point","page":"Points","title":"DeviceLayout.Points.Point","text":"struct Point{T<:PointTypes} <: StaticArrays.FieldVector{2,T}\n    x::T\n    y::T\nend\n\n2D Cartesian coordinate in the plane.\n\n\n\n\n\n","category":"type"},{"location":"points/#DeviceLayout.Points.getx","page":"Points","title":"DeviceLayout.Points.getx","text":"getx(p::Point)\n\nGet the x-coordinate of a point. You can also use p.x or p[1].\n\n\n\n\n\n","category":"function"},{"location":"points/#DeviceLayout.Points.gety","page":"Points","title":"DeviceLayout.Points.gety","text":"gety(p::Point)\n\nGet the y-coordinate of a point. You can also use p.y or p[2].\n\n\n\n\n\n","category":"function"},{"location":"points/#DeviceLayout.Points.lowerleft-Union{Tuple{AbstractArray{Point{T}}}, Tuple{T}} where T","page":"Points","title":"DeviceLayout.Points.lowerleft","text":"lowerleft{T}(A::AbstractArray{Point{T}})\n\nReturn the lower-left Point of the smallest bounding rectangle (with sides parallel to the x- and y-axes) that contains all points in A.\n\nExample:\n\njulia> lowerleft([Point(2, 0), Point(1, 1), Point(0, 2), Point(-1, 3)])\n2-element Point{Int64} with indices SOneTo(2):\n -1\n  0\n\n\n\n\n\n","category":"method"},{"location":"points/#DeviceLayout.Points.upperright-Union{Tuple{AbstractArray{Point{T}}}, Tuple{T}} where T","page":"Points","title":"DeviceLayout.Points.upperright","text":"upperright{T}(A::AbstractArray{Point{T}})\n\nReturn the upper-right Point of the smallest bounding rectangle (with sides parallel to the x- and y-axes) that contains all points in A.\n\nExample:\n\njulia> upperright([Point(2, 0), Point(1, 1), Point(0, 2), Point(-1, 3)])\n2-element Point{Int64} with indices SOneTo(2):\n 2\n 3\n\n\n\n\n\n","category":"method"},{"location":"points/#Implementation-details","page":"Points","title":"Implementation details","text":"","category":"section"},{"location":"points/","page":"Points","title":"Points","text":"Points are implemented using the abstract type FieldVector from StaticArrays.jl. This permits a fast, efficient representation of coordinates in the plane. Additionally, unlike Tuple objects, we can add points together, simplifying many function definitions.","category":"page"},{"location":"geometrylevel/#Geometry-Level-Layout:-Overview","page":"Overview","title":"Geometry-Level Layout: Overview","text":"","category":"section"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"DeviceLayout.jl lets you define shapes, place shapes in structures, and place references to structures inside other structures. We call this workflow \"geometry-level layout\", the most basic way of interacting with DeviceLayout.jl.","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"Within the DeviceLayout.jl type hierarchy, \"shapes\" are GeometryEntity subtypes like Polygon and Rectangle.","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"\"Structures\" are GeometryStructure subtypes like Cell, CoordinateSystem, Path, and Component. A structure can contain many entities (its \"elements\"), and it associates each entity with its own piece of metadata (generally specifying the \"layer\" that entity belongs to).","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"Structures may also contain references to other structures: the main type, StructureReference, wraps a structure together with a coordinate transformation that specifies its relative positioning and orientation within the containing structure.","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"To be more concrete, let's take a look at some examples that showcase different geometry-level workflows.","category":"page"},{"location":"geometrylevel/#Entities:-Transformations,-Clipping,-Styles","page":"Overview","title":"Entities: Transformations, Clipping, Styles","text":"","category":"section"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"Starting with a rectangle, let's demonstrate transformations, polygon clipping, and a style.","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"using DeviceLayout, FileIO\nimport DeviceLayout: μm, nm\n\nr = centered(Rectangle(20μm, 40μm))\n# Create a second rectangle rotated by 90 degrees, positioned below the first\nr2 = Align.below(Rotation(90°)(r), r, centered=true) # centered in x-coordinate\nr3 = Align.above(r2, r) # Another copy of r2 above the first rectangle\ndogbone = union2d([r, r2, r3]) # Boolean union of the three rectangles as a single entity\nrounded_dogbone = Rounded(4μm)(dogbone) # Apply the Rounded style","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"It's a bit hard to read, but the result is a StyledEntity{T,U,S} with three type parameters: the coordinate type T = typeof(1.0μm}, the underlying entity type U = ClippedPolygon{T}, and the style S = Rounded{T}—that is, it is a GeometryEntity that composes the result of a polygon clipping (Boolean) operation with a GeometryEntityStyle specifying rules for rounding that entity.","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"What's notable here is that rounded_dogbone only describes the vertices of the dogbone polygon and the rounding radius—in particular, it has not done any calculations to find a discretization of the rounded corners.","category":"page"},{"location":"geometrylevel/#Cells-and-Rendering","page":"Overview","title":"Cells and Rendering","text":"","category":"section"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"The simplest workflow for generating 2D layouts is to render entities directly to a Cell. (That's why we used it for the \"quick start\" example.)","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"The Cell abstraction is meant to correspond to the GDSII backend, which uses Polygon as its only primitive entity type. In other words, rendering a complicated entity like our rounded_dogbone to a Cell will convert it to a Polygon representation of the same shape—just a list of points.","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"info: Info\nBy default, render!(::Cell, ...) discretizes a Rounded curve with absolute tolerance of 1nm—that's the furthest any point on the true curve is from any line segment on the discretized version. This can be controlled in different ways, like providing the atol keyword to render!, or by composing the ToTolerance style on top of the Rounded style. Internally, an atol keyword then gets passed to the method to_polygons(::AbstractPolygon{S}, ::Rounded{T}; kwargs...).","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"cr = Cell(\"dogbone\", nm)\nrender!(cr, rounded_dogbone, GDSMeta(1))\nelements(cr)","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"Our Rounded ClippedPolygon has been reduced to a mere Polygon, as necessary to represent it within the GDSII format. It's also what we need in order to use the SVG backend:","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"save(\"dogbone.svg\", cr; layercolors=Dict(0 => (0, 0, 0, 1), 1 => (1, 0, 0, 1)));\nnothing; # hide","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"<img src=\"../dogbone.svg\" style=\"width: 1in;\"/>","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"info: Info\nOur ClippedPolygon isn't doing anything special, here—it might as well be a Polygon in this example. The ClippedPolygon type mainly exists to represent polygons with holes without having to generate \"keyhole\" polygons as required by the GDSII format. This ends up being convenient for other backends that don't want keyhole polygons as well as for applying different styles to different boundary or hole contours.","category":"page"},{"location":"geometrylevel/#Paths-and-References","page":"Overview","title":"Paths and References","text":"","category":"section"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"We can now create references to our cell, place those references in a structure, and render the whole structure to another cell. Let's do that with a Path structure, as in our quick-start example:","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"cref = sref(cr, Point(0.0μm, 0.0μm)) # sref is short for \"structure [or single] reference\"\np = Path(μm, metadata=GDSMeta())\nsty = launch!(p)\nstraight!(p, 500μm, sty)\nturn!(p, π / 2, 150μm)\nstraight!(p, 500μm)\nlaunch!(p)\nturnidx = Int((length(p) + 1) / 2) - 1 # the first straight segment of the path\nsimplify!(p, turnidx .+ (0:2))\nattach!(p, cref, (60μm):(60μm):((pathlength(p[turnidx])) - 60μm), i=turnidx)\nc = Cell(\"decoratedpath\", nm)\nrender!(c, p)\nrefs(c)","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"The entities making up the Path are rendered into Polygons, but the GeometryReferences stored in the Path are simply placed into our Cell as references, since they're already Cell references. Note that we have many references to the same Cell called \"dogbone\" here—it hasn't been copied.","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"info: Info\nIf you're paying close attention, you might have noticed that Path handles entity metadata slightly differently than a GeometryStructure like Cell. The Path's elements—the launchers and CPW-styled segments—are all associated with a single piece of metadata, rather than allowing the possibility of different metadata for each. As a structure, though, the Path can still have references to other structures with all sorts of different metadata associated with their elements.","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"Let's see how it looks:","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"save(\"dogbone_path.svg\", flatten(c); layercolors=Dict(0 => (0, 0, 0, 1), 1 => (1, 0, 0, 1)));\nnothing; # hide","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"<img src=\"../dogbone_path.svg\" style=\"width: 3in;\"/>","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"info: Info\nThe SVG backend only draws the top-level Cell, so it's necessary to flatten the cell before saving. flatten traverses references to place all entities in a single Cell, applying transformations as necessary.","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"(For further examples, we'll hide the line that saves to SVG just to display a cell.)","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"Of course, we can also add Cell references directly to a Cell, for example to apply a global rotation:","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"c_wrapper = Cell(\"wrapper\", nm)\naddref!(c_wrapper, sref(c, rot=90°))\nsave( # hide\n    \"rotated_dogbone_path.svg\", # hide\n    flatten(c_wrapper); # hide\n    layercolors=Dict(0 => (0, 0, 0, 1), 1 => (1, 0, 0, 1)) # hide\n); # hide\nnothing; # hide","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"<img src=\"../rotated_dogbone_path.svg\" style=\"width: 3in;\"/>","category":"page"},{"location":"geometrylevel/#Coordinate-Systems","page":"Overview","title":"Coordinate Systems","text":"","category":"section"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"We've been working with Cells in the above examples because they're convenient for displaying immediately, but in practice, you'll usually want to work with CoordinateSystem. The two are very similar—both are subtypes of AbstractCoordinateSystem—but where Cell is tied to the GDSII backend, CoordinateSystem is the \"DeviceLayout.jl-native\" geometry structure.","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"In particular, any GeometryEntity can be placed in a CoordinateSystem, like our rounded_dogbone from before. (If Polygon is the only Cell primitive, then every GeometryEntity is a CoordinateSystem primitive.) That way, backend-specific decisions about how to render it can be deferred. This will become clear when we get to the SolidModel backend below.","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"csr = CoordinateSystem(\"dogbone\", nm)\nplace!(csr, rounded_dogbone, SemanticMeta(:bridge))\nelements(csr)[1]","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"info: Info\nplace! can only be used with CoordinateSystems. It does the same thing as render!, which still works, but the verb is less ambiguous. If you know you're only working with CoordinateSystems, it may be clearer to use place!, since render! suggests rendering to primitives—which can mean different things depending on the \"backend\".","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"We're also free to use any type of metadata to describe layers, not just GDSMeta. In this case, we use SemanticMeta with the layer symbol :bridge.","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"You can do just about anything with a CoordinateSystem that you could do with a Cell, and some things you couldn't. For example, rendering a Path to a Cell converted it into Polygons—a Cell can only hold references to other Cells, not arbitrary structures. CoordinateSystem doesn't have that limitation:","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"csref = sref(csr, Point(0.0μm, 0.0μm))\np = Path(nm, metadata=SemanticMeta(:metal_negative))\nsty = launch!(p, trace1=4μm, gap1=4μm)\nstraight!(p, 500μm, sty)\nturn!(p, π / 2, 150μm)\nstraight!(p, 500μm)\nlaunch!(p, trace1=4μm, gap1=4μm)\nturnidx = Int((length(p) + 1) / 2) - 1 # the first straight segment of the path\nsimplify!(p, turnidx .+ (0:2))\nattach!(p, csref, (60μm):(60μm):((pathlength(p[turnidx])) - 60μm), i=turnidx)\ncs = CoordinateSystem(\"decoratedpath\", nm)\naddref!(cs, p) # either render! or place! would do the same thing here\nrefs(cs)","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"Of course, eventually we'll want to turn this into a Cell. Since we were using named SemanticMeta layers, we just need to specify how to convert them to GDSMeta:","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"layer_record = Dict(:bridge => GDSMeta(1), :metal_negative => GDSMeta())\ncell = Cell(cs; map_meta=m -> layer_record[layer(m)])\n# Could also say cell = render!(Cell(\"newcell\", nm), cs; map_meta=...)\nsave(\n    \"cs_dogbone_path.svg\",\n    flatten(cell);\n    layercolors=Dict(0 => (0, 0, 0, 1), 1 => (1, 0, 0, 1))\n); # hide\nnothing; # hide","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"<img src=\"../cs_dogbone_path.svg\" style=\"width: 3in;\"/>","category":"page"},{"location":"geometrylevel/#Solid-Models","page":"Overview","title":"Solid Models","text":"","category":"section"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"We can also render the same CoordinateSystem to a 3D model. DeviceLayout.jl uses Open CASCADE Technology, an open-source 3D geometry library, through the API provided by Gmsh, a 3D finite element mesh generator.","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"Even though our geometry is purely 2D, we can generate a SolidModel by providing a map from layer name to position in the third dimension (zmap) as well as a list of Booleans, extrusions, and other operations to perform after rendering the 2D entities (postrender_ops).","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"It's not really recommended to do this directly from geometry-level layout. There are tools in the schematic-driven layout interface that handle some of the complexity for you. We'll have an analogous overview later that showcases all of that, but for the sake of demonstration, here's a simple (relatively) manual example. (Making bridges in particular can be a bit involved, so there's a helper method to generate the postrendering operations for a basic \"staple\" configuration.)","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"We'll add a few more rectangles to help with 3D operations—one that will intersect with our \"bridge\" pattern to create a 3D \"staple\", one to extrude the substrate volume, and one to define a larger volume above and below the substrate.","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"place!(csr, centered(Rectangle(30μm, 15μm)), :base)\nplace!.(cs, offset(bounds(cs), 200μm), :substrate)\nplace!(cs, bounds(cs), :simulated_area)\nzmap = (m) -> layer(m) == :simulated_area ? -1000μm : 0μm\npostrender_ops = [\n    (\"substrate_extrusion\", SolidModels.extrude_z!, (\"substrate\", -500μm))\n    (\"simulated_area_extrusion\", SolidModels.extrude_z!, (\"simulated_area\", 2000μm))\n    (\"metal\", SolidModels.difference_geom!, (\"substrate\", \"metal_negative\"))\n    SolidModels.staple_bridge_postrendering(; base=\"base\", bridge=\"bridge\")\n]\nsm = SolidModel(\"model\", overwrite=true)\nSolidModels.gmsh.option.setNumber(\"General.Verbosity\", 0)\nrender!(sm, cs; zmap=zmap, postrender_ops=postrender_ops);","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"We can look at the current model in the Gmsh GUI:","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"SolidModels.gmsh.fltk.run()","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"<img src=\"../assets/gmsh_example.png\"/>","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"Let's zoom in on the CPW bend:","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"<img src=\"../assets/gmsh_zoom.png\"/>","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"One notable thing about this solid model is that the arcs in the bent CPW are exact circular arcs. When we render to a Cell, all shapes get discretized into Polygons. But since we were working with our \"native\" CoordinateSystem, curved shapes like the CPW bend can be rendered as native curves in the solid geometry kernel. This not only keeps model size down but also allows Gmsh to make better meshes.","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"Moreover, when DeviceLayout.jl renders path segments and certain other entities, it automatically sets mesh sizing information to help Gmsh make better meshes. (You can also annotate entities with the MeshSized style to provide such information manually.)","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"SolidModels.gmsh.model.mesh.generate(3)","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"<img src=\"../assets/mesh_example.png\"/>\n\n<img src=\"../assets/mesh_zoom.png\"/>","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"Compare this to what happens if we render to polygons first.","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"layer_record = Dict(\n    :substrate => GDSMeta(0),\n    :simulated_area => GDSMeta(1),\n    :metal_negative => GDSMeta(2),\n    :base => GDSMeta(3),\n    :bridge => GDSMeta(4)\n)\ncell = Cell(cs; map_meta=m -> layer_record[layer(m)])\n### Fix for duplicate consecutive points on certain rounded polygons\n### GDS doesn't care but Gmsh/OCCT do care\nflatten!(cell)\ncell.elements .= Polygon.([unique(points(poly)) for poly in elements(cell)])\n###\nlyr(name) = layername(layer_record[Symbol(name)])\ngds_postrender_ops = [\n    (\"substrate_extrusion\", SolidModels.extrude_z!, (lyr(\"substrate\"), -500μm))\n    (\"simulated_area_extrusion\", SolidModels.extrude_z!, (lyr(\"simulated_area\"), 2000μm))\n    (\"metal\", SolidModels.difference_geom!, (lyr(\"substrate\"), lyr(\"metal_negative\")))\n    SolidModels.staple_bridge_postrendering(; base=lyr(\"base\"), bridge=lyr(\"bridge\"))\n]\nsm = SolidModel(\"model\", overwrite=true)\nrender!(sm, cell; zmap=zmap, postrender_ops=gds_postrender_ops)\nSolidModels.gmsh.model.mesh.generate(2) # 3D meshing may hit an error—have to be careful about postrendering","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"Not only is this render! call much slower, but the mesh is forced to use every point on the 1nm-tolerance-discretization of the curve. Without any help from the rich information in the original geometry, Gmsh also uses its default settings—resulting in a very poor mesh.","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"<img src=\"../assets/mesh_bad.png\"/>","category":"page"},{"location":"geometrylevel/#Data-flow-diagrams","page":"Overview","title":"Data flow diagrams","text":"","category":"section"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"It may be easier to understand the flow of data with a diagram. Here's one for the \"quick start\" workflow, working directly with Cells:","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"<img src=\"../assets/cell_dataflow.jpg\"/>","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"And here's a diagram for the typical CoordinateSystem workflow:","category":"page"},{"location":"geometrylevel/","page":"Overview","title":"Overview","text":"<img src=\"../assets/coordinatesystem_dataflow.jpg\"/>","category":"page"},{"location":"schematicdriven/schematics/#Schematics","page":"Schematics","title":"Schematics","text":"","category":"section"},{"location":"schematicdriven/schematics/#Schematic-graphs","page":"Schematics","title":"Schematic graphs","text":"","category":"section"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"The schematic graph is a collection of logical information about the presence of components and their connections. Its nodes are ComponentNodes, representing instances of AbstractComponents in the design. The edges are labeled with the names of the components' Hooks that are to be fused together.","category":"page"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"SchematicDrivenLayout.SchematicGraph\nSchematicDrivenLayout.ComponentNode","category":"page"},{"location":"schematicdriven/schematics/#DeviceLayout.SchematicDrivenLayout.SchematicGraph","page":"Schematics","title":"DeviceLayout.SchematicDrivenLayout.SchematicGraph","text":"SchematicGraph <: AbstractMetaGraph{Int}\n\nGraph describing the components and connectivity of a device schematic.\n\n\n\n\n\n","category":"type"},{"location":"schematicdriven/schematics/#DeviceLayout.SchematicDrivenLayout.ComponentNode","page":"Schematics","title":"DeviceLayout.SchematicDrivenLayout.ComponentNode","text":"mutable struct ComponentNode\n    id::String\n    component::AbstractComponent\nend\n\nRepresents an instance of a component in the context of a schematic graph.\n\n\n\n\n\n","category":"type"},{"location":"schematicdriven/schematics/#Adding-and-connecting-Components","page":"Schematics","title":"Adding and connecting Components","text":"","category":"section"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"SchematicDrivenLayout.add_node!\nSchematicDrivenLayout.fuse!\nroute!(::SchematicDrivenLayout.SchematicGraph,\n    ::Paths.RouteRule,\n    ::Pair{SchematicDrivenLayout.ComponentNode, Symbol},\n    ::Pair{SchematicDrivenLayout.ComponentNode, Symbol},\n    ::Any,\n    ::Any)\nSchematicDrivenLayout.RouteComponent\nattach!(::SchematicDrivenLayout.SchematicGraph,\n    ::S,\n    ::Pair{T, Symbol},\n    ::DeviceLayout.Coordinate\n) where {S <: SchematicDrivenLayout.ComponentNode, T <: SchematicDrivenLayout.ComponentNode}","category":"page"},{"location":"schematicdriven/schematics/#DeviceLayout.SchematicDrivenLayout.add_node!","page":"Schematics","title":"DeviceLayout.SchematicDrivenLayout.add_node!","text":"add_node!(g::SchematicGraph, comp::AbstractComponent; base_id=name(comp), kwargs...)\n\nCreate and return a new node for comp.\n\nThe base_id will be used as the node's id if it is not already in use by the Schematic. If it is, then a uniquename will be generated by appending _n, where n is the number of occurrences of base_id so far (including this one).\n\nAdditional keyword arguments will become vertex properties.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/schematics/#DeviceLayout.SchematicDrivenLayout.fuse!","page":"Schematics","title":"DeviceLayout.SchematicDrivenLayout.fuse!","text":"fuse!(g::SchematicGraph,\n    nodehook1::Pair{Int, Symbol},\n    nodehook2::Pair{Int, Symbol}; kwargs...)\nfuse!(g::SchematicGraph,\n    nodehook1::Pair{ComponentNode, <:Union{Symbol, Hook}},\n    nodehook2::Pair{<:Union{ComponentNode, AbstractComponent}, <:Union{Symbol, Hook}}; kwargs...)\n\nUsage:\n\nfuse!(g, node1=>:hook1, node2=>:hook2)\nfuse!(g, idx1=>:hook1, idx2=>:hook2)\nfuse!(g, node1=>:hook1, comp2=>:hook2)\nfuse!(g, node1=>:hook1, comp2=>:hook2; PLAN_SKIPS_EDGE=>true)\n\nAdd an edge (node1, node2) connecting their hooks (:hook1, :hook2) to g.\n\nReturns the second ComponentNode.\n\nIf fuse! is passed a bare component comp2, it makes a new node, even if that component is referenced in another node.\n\nIf no hook or only one hook is specified, fuse! will try to determine the correct hook using matching_hooks or matching_hook.\n\nYou can make an attachment anywhere, not just to an existing named hook, by providing a Hook object with the desired point and orientation rather than a Symbol (example: fuse!(g, node1=>PointHook(1mm, 1mm, 90°), comp2=>:hook2)). This option is provided for convenience in situations that call for ad-hoc or case-by-case relative positioning; one example use case might be placing labels near components. On the other hand, if you find yourself needing a consistent hook that doesn't already exist for MyComponent, then it's generally better to update the component definition so that the hook is available through hooks(::MyComponent). Alternatively, if you want to use an existing hook with an additional offset, consider using the Spacer component.\n\nCycles: Sometimes we need to avoid adding edges in the graph to avoid cycles that'd force the plan function to throw an error. Solution: Pass a keyword argument plan_skips_edge=true. This allows us to encode all the edges in the graph, while informing the plan function that the edge should be skipped for rendering purposes.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/schematics/#DeviceLayout.Paths.route!-Tuple{DeviceLayout.SchematicDrivenLayout.SchematicGraph, DeviceLayout.Paths.RouteRule, Pair{DeviceLayout.SchematicDrivenLayout.ComponentNode, Symbol}, Pair{DeviceLayout.SchematicDrivenLayout.ComponentNode, Symbol}, Any, Any}","page":"Schematics","title":"DeviceLayout.Paths.route!","text":"route!(g::SchematicGraph, rule::RouteRule,\n    nodehook1::Pair{ComponentNode,Symbol}, nodehook2::Pair{ComponentNode,Symbol},\n    sty, meta;\n    waypoints=[], waydirs=[], global_waypoints=false,\n    name=uniquename(\"r_$(component(nodehook1.first).name)_$(component(nodehook2.first).name)\"),\n    kwargs...)\nroute!(g::SchematicGraph, rule::RouteRule, node1::ComponentNode, nodehook2::Pair{ComponentNode,Symbol}, sty, meta; kwargs...)\nroute!(g::SchematicGraph, rule::RouteRule, nodehook1::Pair{ComponentNode,Symbol}, node2::ComponentNode, sty, meta; kwargs...)\nroute!(g::SchematicGraph, rule::RouteRule, node1::ComponentNode, node2::ComponentNode, sty, meta; kwargs...)\n\nCreates a RouteComponent with given style sty and metadata meta, and fuses it between the specified nodes and hooks in g.\n\nReturns the resulting ComponentNode in g.\n\nExample usage: route!(g, BSplineRouting(), zline_node=>:feedline, z_launcher_node=>:line, Paths.CPW(10μm, 6μm), GDSMeta(1, 2))\n\nIf one or both hook symbols are not specified, then matching_hook or matching_hooks will be used to attempt to automatically find the correct hook or hooks.\n\nThe route will have start and endpoints at the origin until a method like plan! is called. waypoints and waydirs are in component-local coordinates (unless global_waypoints is true), and rule determines how they will be used.\n\nAdditional keyword arguments will become vertex properties for the RouteComponent's node.\n\nname should be unique.\n\n\n\n\n\n","category":"method"},{"location":"schematicdriven/schematics/#DeviceLayout.SchematicDrivenLayout.RouteComponent","page":"Schematics","title":"DeviceLayout.SchematicDrivenLayout.RouteComponent","text":"struct RouteComponent{T} <: AbstractComponent{T}\n    name::String\n    r::Paths.Route{T}\n    global_waypoints::Bool\n    sty::Paths.Style\n    meta::Meta\n\nWraps a Route in a Component type for use with schematics.\n\nname should be unique. If global_waypoints is false, then the waypoints and waydirs are taken to be relative to the component coordinate system. Otherwise, they will be relative to the schematic global coordinate system.\n\n\n\n\n\n","category":"type"},{"location":"schematicdriven/schematics/#DeviceLayout.Paths.attach!-Union{Tuple{T}, Tuple{S}, Tuple{DeviceLayout.SchematicDrivenLayout.SchematicGraph, S, Pair{T, Symbol}, Union{Real, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {T, U, L, S}, Unitful.Quantity{T, 𝐋} where T}}} where {S<:DeviceLayout.SchematicDrivenLayout.ComponentNode, T<:DeviceLayout.SchematicDrivenLayout.ComponentNode}","page":"Schematics","title":"DeviceLayout.Paths.attach!","text":"attach!(g::SchematicGraph,\n    pathnode::S,\n    nodehook2::Pair{T, Symbol},\n    position;\n    i=lastindex(component(pathnode)),\n    location=0) where {S <: ComponentNode, T <: ComponentNode}\nUsage: attach!(g, pathnode, node2=>:hook2, position; i=segment_idx, location=0)\n\nAdds an edge to g between pathnode and node2, attaching :hook2 to a specified point along pathnode.\n\nA new HandedPointHook is generated a distance position along the segment specified by i. If location is +1 or -1, the generated hook is offset to the right or left of the segment by the extent defined by the path's style, with the hook's inward direction pointing back to the segment.\n\n\n\n\n\n","category":"method"},{"location":"schematicdriven/schematics/#Routing","page":"Schematics","title":"Routing","text":"","category":"section"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"A Paths.Route is like a Path, but defined implicitly in terms of its endpoints and rules (like \"use only straight sections and 90 degree turns\") for getting from one end to another. We can add Routes between components in a schematic using route!, creating flexible connections that are only resolved after floorplanning has determined the positions of the components to be connected.","category":"page"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"info: Terminology note: connected component\nThere is a graph-theory term \"connected component\" unrelated to our AbstractComponent, indicating a subgraph whose nodes are all connected by edges and which isn't part of a larger such subgraph. For example, a fully connected graph has one connected component, the entire graph. Sometimes you may even hear these called \"components\", but below we use \"connected component\" for the graph-theory sense and \"component\" for AbstractComponent.","category":"page"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"In more detail: Typically, each fuse! operation fully determines the position and rotation of the new node. For each connected component, the first node added to the SchematicGraph is positioned at the origin. A typical workflow could start by creating a node with a \"chip template\" component containing port hooks and other boilerplate. We then fuse! any CPW launchers to the template. The devices in the middle of the chip are added and fused to one another without yet fixing their position relative to the chip template. Next, one connection is made between this connected component of devices and the connected component containing the template, fixing their relative positions. Since the chip template was added first, it will be centered at the origin.","category":"page"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"At this point, further connections still need to be made between various device ports and CPW launchers positioned on the chip template, all of which are now fully constrained. Another constraint like those created by fuse! so far would overconstrain the layout, causing floorplanning with plan to fail. The remaining connections are instead made with route!, which creates a RouteNode with edges to the ComponentNodes at its start and end points. Then, during plan, after the initial floorplanning phase has determined position of all fixed Components, the route node finds a path between its start and end points.","category":"page"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"tip: Schematic connections without geometric constraints\nYou can add edges to the schematic graph that will be ignored during plan using the keyword plan_skips_edge=true in fuse!.","category":"page"},{"location":"schematicdriven/schematics/#Schematics-2","page":"Schematics","title":"Schematics","text":"","category":"section"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"SchematicDrivenLayout.Schematic\nSchematicDrivenLayout.plan\nSchematicDrivenLayout.check!\nSchematicDrivenLayout.build!\nSchematicDrivenLayout.render!(::SchematicDrivenLayout.AbstractCoordinateSystem, ::SchematicDrivenLayout.Schematic, ::SchematicDrivenLayout.LayoutTarget; kwargs...)","category":"page"},{"location":"schematicdriven/schematics/#DeviceLayout.SchematicDrivenLayout.Schematic","page":"Schematics","title":"DeviceLayout.SchematicDrivenLayout.Schematic","text":"struct Schematic{S} <: AbstractCoordinateSystem{S}\n\nSpatial representation of a layout in terms of AbstractComponents rather than polygons.\n\nCan be constructed from a SchematicGraph g using plan(g).\n\n\n\n\n\n","category":"type"},{"location":"schematicdriven/schematics/#DeviceLayout.SchematicDrivenLayout.plan","page":"Schematics","title":"DeviceLayout.SchematicDrivenLayout.plan","text":"plan(g::SchematicGraph, hooks_fn=hooks; strict=:error, log_dir=\"build\", log_level=Logging.Info)\nplan(g::SchematicGraph, t::Target; strict=:error, log_dir=\"build\", log_level=Logging.Info)\n\nConstructs a Schematic floorplan from g without rendering Components.\n\nIterates through the nodes in g depth-first to build a tree (or more than one, if the graph is disconnected) of CoordinateSystems satisfying the translations, reflections, and rotations required by the hooks corresponding to each edge. Each CoordinateSystem holds a StructureReference to the Component in the corresponding node. A new Schematic is created containing references to the roots of these trees (sometimes called \"rendering trees\") as well as a dictionary mapping each ComponentNode in g to the reference to that node's CoordinateSystem in its rendering tree. (This is the reference stored by its parent.)\n\nplan will ignore edges with the property SchematicDrivenLayout.PLAN_SKIPS_EDGE=>true.\n\nThe strict keyword should be :error, :warn, or :no.\n\nThe strict=:error keyword option causes plan to throw an error if any errors were logged during planning. This is enabled by default, but can be disabled with strict=:no, in which case any node that was not successfully placed relative to an existing node will simply appear at the origin. Using strict=:no is recommended only for debugging purposes.\n\nThe strict=:warn keyword option causes plan to throw an error if any warnings were logged during planning. This is disabled by default. Using strict=:warn is suggested for use in automated pipelines, where warnings may require human review.\n\nLog messages with level of at least log_level will be written to joinpath(log_dir, name(g) * \".log\"). If logdir is nothing, then no file will be written. The same log file will be used for build! and render! stages of the schematic workflow.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/schematics/#DeviceLayout.SchematicDrivenLayout.check!","page":"Schematics","title":"DeviceLayout.SchematicDrivenLayout.check!","text":"check!(sch::Schematic; rules=[rotations_valid])\n\nVerifies that sch satisfies rule(sch) == true for each rule in rules, and sets sch.checked = true if it does.\n\nBy default, checks that all checkable components have an allowed global orientation (rotations_valid(::Schematic)).\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/schematics/#DeviceLayout.SchematicDrivenLayout.build!","page":"Schematics","title":"DeviceLayout.SchematicDrivenLayout.build!","text":"build!(sch::Schematic, geometry_fn=geometry; strict=:error)\nbuild!(sch::Schematic, t::Target; strict=:error)\n\nReplace the AbstractComponents in sch with their geometry. Usually there's no reason to do this, since render! will still render the geometry but won't modify sch.\n\nUsers must run check!(sch) before calling this method; otherwise, it will throw an error.\n\nThe strict keyword should be :error, :warn, or :no.\n\nThe strict=:error keyword option causes build! to throw an error if any errors were logged while building component geometries. This is enabled by default, but can be disabled with strict=:no, in which case any component which was not successfully built will have an empty geometry. Using strict=:no is recommended only for debugging purposes.\n\nThe strict=:warn keyword option causes build! to throw an error if any warnings were logged. This is disabled by default. Using strict=:warn is suggested for use in automated pipelines, where warnings may require human review.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/schematics/#DeviceLayout.render!-Tuple{DeviceLayout.AbstractCoordinateSystem, DeviceLayout.SchematicDrivenLayout.Schematic, DeviceLayout.SchematicDrivenLayout.LayoutTarget}","page":"Schematics","title":"DeviceLayout.render!","text":"render!(\n    cs::AbstractCoordinateSystem,\n    sch::Schematic,\n    target::LayoutTarget;\n    strict=:error,\n    kwargs...\n)\n\nRun build!(sch, target) and render the resulting geometry to cs using target's rendering options.\n\nThe strict keyword should be :error, :warn, or :no.\n\nThe strict=:error keyword option causes render! to throw an error if any errors were logged while building component geometries or while rendering geometries to cs. This is enabled by default, but can be disabled with strict=:no, in which case any component which was not successfully built will have an empty geometry, and any non-fatal rendering errors will be ignored as usual. Using strict=:no is recommended only for debugging purposes.\n\nThe strict=:warn keyword option causes render! to throw an error if any warnings were logged. This is disabled by default. Using strict=:warn is suggested for use in automated pipelines, where warnings may require human review.\n\n\n\n\n\n","category":"method"},{"location":"schematicdriven/schematics/#Inspecting-and-manipulating-schematics","page":"Schematics","title":"Inspecting and manipulating schematics","text":"","category":"section"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"Schematics allow you to produce layouts by specifying designs at a high level, in terms of components and their connections. Often, this isn't quite enough to get the final artwork you want. Maybe a wire needs to be routed differently, or a component needs to be modified based on its position.","category":"page"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"SchematicDrivenLayout allows you to inspect and modify a Schematic to make these sorts of changes before build renders it into polygons.","category":"page"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"When you construct a SchematicGraph, you don't need to know exactly where a component will end up. You can usually calculate it yourself, but there are some built-in utilities to simplify things.","category":"page"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"SchematicDrivenLayout.indexof(::SchematicDrivenLayout.ComponentNode, ::SchematicDrivenLayout.SchematicGraph)\nSchematicDrivenLayout.bounds(::SchematicDrivenLayout.Schematic, ::SchematicDrivenLayout.ComponentNode)\nSchematicDrivenLayout.center(::SchematicDrivenLayout.Schematic, ::SchematicDrivenLayout.ComponentNode)\nSchematicDrivenLayout.hooks(::SchematicDrivenLayout.Schematic, ::SchematicDrivenLayout.ComponentNode)\nSchematicDrivenLayout.origin(::SchematicDrivenLayout.Schematic, ::SchematicDrivenLayout.ComponentNode)\nSchematicDrivenLayout.transformation(::SchematicDrivenLayout.Schematic, ::SchematicDrivenLayout.ComponentNode)\nSchematicDrivenLayout.find_components\nSchematicDrivenLayout.find_nodes","category":"page"},{"location":"schematicdriven/schematics/#DeviceLayout.SchematicDrivenLayout.indexof-Tuple{DeviceLayout.SchematicDrivenLayout.ComponentNode, DeviceLayout.SchematicDrivenLayout.SchematicGraph}","page":"Schematics","title":"DeviceLayout.SchematicDrivenLayout.indexof","text":"indexof(n::ComponentNode, g::SchematicGraph)\n\nFinds the index of the node n in g.\n\n\n\n\n\n","category":"method"},{"location":"schematicdriven/schematics/#DeviceLayout.bounds-Tuple{DeviceLayout.SchematicDrivenLayout.Schematic, DeviceLayout.SchematicDrivenLayout.ComponentNode}","page":"Schematics","title":"DeviceLayout.bounds","text":"bounds(sch::Schematic, node::ComponentNode)\nbounds(sch::Schematic, node_idx::Int)\n\nThe Rectangle bounding the component in node in the global coordinate system of sch.\n\n\n\n\n\n","category":"method"},{"location":"schematicdriven/schematics/#DeviceLayout.center-Tuple{DeviceLayout.SchematicDrivenLayout.Schematic, DeviceLayout.SchematicDrivenLayout.ComponentNode}","page":"Schematics","title":"DeviceLayout.center","text":"center(sch::Schematic, node::ComponentNode)\ncenter(sch::Schematic, node_idx::Int)\n\nThe center of the bounds of node's component in the global coordinate system of sch.\n\n\n\n\n\n","category":"method"},{"location":"schematicdriven/schematics/#DeviceLayout.hooks-Tuple{DeviceLayout.SchematicDrivenLayout.Schematic, DeviceLayout.SchematicDrivenLayout.ComponentNode}","page":"Schematics","title":"DeviceLayout.hooks","text":"hooks(sch::Schematic, node::ComponentNode)\n\nThe hooks belonging to the component in node in the global coordinate system of sch.\n\n\n\n\n\n","category":"method"},{"location":"schematicdriven/schematics/#DeviceLayout.Transformations.origin-Tuple{DeviceLayout.SchematicDrivenLayout.Schematic, DeviceLayout.SchematicDrivenLayout.ComponentNode}","page":"Schematics","title":"DeviceLayout.Transformations.origin","text":"origin(sch::Schematic, node::ComponentNode)\norigin(sch::Schematic, node_idx::Int)\n\nThe origin of node in the global coordinate system of sch.\n\n\n\n\n\n","category":"method"},{"location":"schematicdriven/schematics/#DeviceLayout.transformation-Tuple{DeviceLayout.SchematicDrivenLayout.Schematic, DeviceLayout.SchematicDrivenLayout.ComponentNode}","page":"Schematics","title":"DeviceLayout.transformation","text":"transformation(sch::Schematic, node::ComponentNode)\n\nGiven a Schematic sch containing ComponentNode node in its SchematicGraph, this function returns a CoordinateTransformations.Transformation object that lets you translate from the coordinate system of the node to the global coordinate system of sch.\n\nEffectively a wrapper around DeviceLayout.transformation(::CoordinateSystem, ::CoordSysRef).\n\n\n\n\n\n","category":"method"},{"location":"schematicdriven/schematics/#DeviceLayout.SchematicDrivenLayout.find_components","page":"Schematics","title":"DeviceLayout.SchematicDrivenLayout.find_components","text":"find_components(f::Function, g::SchematicGraph; depth=-1)\n\nReturn the indices of the nodes in sch or g for which f(component(node)) is true.\n\nKeyword depth is the number of layers of the graph to search within, where the subgraph of each CompositeComponent is a layer beyond the layer holding the ComponentNode for that CompositeComponent. To search only top-level components, use depth=1. To search all subgraphs recursively, use a negative depth (the default).\n\nIndices for nodes in subgraphs are integers or Tuples of integer indices, one for each additional layer. For example, if a node containing a CompositeComponent has index 2 in the top layer, then the third subcomponent in the CompositeComponent's graph has index (2,3).\n\n\n\n\n\nfind_components(comptype::Type{T}, sch::Schematic; depth=-1) where {T <: AbstractComponent}\nfind_components(comptype::Type{T}, g::SchematicGraph; depth=-1) where {T <: AbstractComponent}\n\nReturn the indices of nodes containing components of type T.\n\nSee find_components(::Function, ::SchematicGraph).\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/schematics/#DeviceLayout.SchematicDrivenLayout.find_nodes","page":"Schematics","title":"DeviceLayout.SchematicDrivenLayout.find_nodes","text":"find_nodes(f::Function, g::SchematicGraph; depth=-1)\n\nReturn the indices of the nodes in sch or g for which f(node) is true.\n\nKeyword depth is the number of layers of the graph to search within, where the subgraph of each CompositeComponent is a layer beyond the layer holding the ComponentNode for that CompositeComponent. To search only top-level components, use depth=1. To search all subgraphs recursively, use a negative depth (the default).\n\nIndices for nodes in subgraphs are integers or Tuples of integer indices, one for each additional layer. For example, if a node containing a CompositeComponent has index 2 in the top layer, then the third subcomponent in the CompositeComponent's graph has index (2,3).\n\nSee also find_components, which checks f(component(node)).\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"If you have a ComponentNode, you can replace its component using an arbitrary function that takes the original component as an argument:","category":"page"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"SchematicDrivenLayout.replace_component!","category":"page"},{"location":"schematicdriven/schematics/#DeviceLayout.SchematicDrivenLayout.replace_component!","page":"Schematics","title":"DeviceLayout.SchematicDrivenLayout.replace_component!","text":"replace_component!(sch::Schematic, node_index::Int, replacement::Function)\n\nReplaces the component c at node_index in sch with replacement(c).\n\nreplacement should return a new AbstractComponent with a unique name.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"You can also replace it (or all components of that type) using a function that takes the position in schematic-global or wafer-global coordinates as an argument:","category":"page"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"SchematicDrivenLayout.position_dependent_replace!","category":"page"},{"location":"schematicdriven/schematics/#DeviceLayout.SchematicDrivenLayout.position_dependent_replace!","page":"Schematics","title":"DeviceLayout.SchematicDrivenLayout.position_dependent_replace!","text":"position_dependent_replace!(sch::Schematic{S}, node_index::Int, replacement::Function;\n    schematic_origin_globalcoords=zero(Point{S})) where {S}\n\nReplaces the component c at node_index in sch with replacement.\n\nThe replacement function should have a signature matching replacement(c<:AbstractComponent, c_origin_globalcoords::Point) where c is the component to be replaced and c_origin_globalcoords is the component's origin in global coordinates. Here \"global\" coordinates are defined as those in which the schematic's origin is the keyword argument schematic_origin_globalcoords in position_dependent_replace!.\n\nreplacement should return a new AbstractComponent with a unique name.\n\n\n\n\n\nposition_dependent_replace!(sch::Schematic{S}, comptype::Type{<:AbstractComponent},\n    replacement::Function;\n    schematic_origin_globalcoords=zero(Point{S})) where {S}\n\nReplaces each component instance of type comptype in sch using position_dependent_replace! with the replacement function replacement(c<:AbstractComponent, c_origin_globalcoords::Point).\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"One other useful trick allows a kind of interactive routing. When you view your final layout built from the schematic, you may find that a route bends too sharply or goes too close to a component. You can write down the points it needs to go to in the schematic's global coordinate system, and add them as waypoints to the route. That is, if you go back to your layout script, before you build! the layout, you can do something like","category":"page"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"### original script\ng = SchematicGraph(\"example\")\n...\nroute_node = route!(g, args...)\n...\nfloorplan = plan(g)\ncheck!(floorplan)\n### modifications\n# waypoints are global coordinates, not relative to the route's origin\nroute_node.component.global_waypoints = true\nroute_node.component.r.waypoints = [Point(600.0μm, -3000.0μm)]\nroute_node.component.r.waydirs = [90°]\n### finalize\nbuild!(floorplan)","category":"page"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"Now the route in route_node is guaranteed to pass through the point (600.0μm, -3000.0μm) on its way to its destination. If the RouteRule's implementation uses waydirs, then it will also have a direction of 90° at that point.","category":"page"},{"location":"schematicdriven/schematics/#Automatic-crossover-generation","page":"Schematics","title":"Automatic crossover generation","text":"","category":"section"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"You can automatically generate crossovers between Paths and RouteComponents, including those nested within composite components. This is based on Path intersection functionality.","category":"page"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"SchematicDrivenLayout.crossovers!","category":"page"},{"location":"schematicdriven/schematics/#DeviceLayout.SchematicDrivenLayout.crossovers!","page":"Schematics","title":"DeviceLayout.SchematicDrivenLayout.crossovers!","text":"crossovers!(sch::Schematic, xsty::DeviceLayout.Paths.Intersect.IntersectStyle)\n\nSplice crossovers into intersecting Paths and RouteComponents.\n\nRouteComponents will cross over Paths, and otherwise components added to the schematic graph later will cross over those added earlier.\n\nExample\n\n    g = SchematicGraph(\"crossover_example\")\n    # ...\n    floorplan = plan(g)\n    xsty = Intersect.AirBridge(\n        crossing_gap=5μm,\n        foot_gap=2μm,\n        foot_length=4μm,\n        extent_gap=2μm,\n        scaffold_gap=5μm,\n        scaffold_meta=GDSMeta(5),\n        air_bridge_meta=GDSMeta(3)\n        )\n    SchematicDrivenLayout.crossovers!(floorplan, xsty)\n\n\n\n\n\ncrossovers!(sch::Schematic, xsty::DeviceLayout.Paths.Intersect.IntersectStyle,\n    nodes_1, nodes_2)\n\nSplice crossovers into intersecting Paths and RouteComponents.\n\nComponents in nodes_2 will cross over any components in nodes_1, and otherwise components added to the schematic graph later will cross over those added earlier.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/schematics/#Checking-schematics","page":"Schematics","title":"Checking schematics","text":"","category":"section"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"It is often necessary to check that a planned Schematic obeys a set of constraints set by the fabrication process. For instance, one may want to verify that all the junctions in a floorplan are oriented in the right direction, e.g. pointing north. Instead of doing this by eye, users should call check!(sch::Schematic). In the future, this method could run any number of checks, but at present it only checks the global orientation of checkable components via the following methods:","category":"page"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"SchematicDrivenLayout.rotations_valid","category":"page"},{"location":"schematicdriven/schematics/#DeviceLayout.SchematicDrivenLayout.rotations_valid","page":"Schematics","title":"DeviceLayout.SchematicDrivenLayout.rotations_valid","text":"rotations_valid(sch::Schematic)\n\nVerifies that all checkable components in sch have the right orientation in the global coordinate system (returns true if successful and throws an error otherwise). A component of type T is checkable if check_rotation(::T) = true.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"To be able to build! a floorplan (i.e. turn components into their CoordinateSystem geometries), users must run check! first, otherwise build will throw an error.","category":"page"},{"location":"schematicdriven/schematics/#Visualization","page":"Schematics","title":"Visualization","text":"","category":"section"},{"location":"schematicdriven/schematics/","page":"Schematics","title":"Schematics","text":"SchematicDrivenLayout also contains some prototype schematic-visualization methods: if GraphMakie is present in the environment, then GraphMakie.graphplot can be used with a SchematicGraph to show nodes and edges or with Schematic to also place the components at their on-chip positions.","category":"page"},{"location":"examples/singletransmon/#Single-transmon-with-readout-resonator","page":"Single-Transmon Simulation","title":"Single transmon with readout resonator","text":"","category":"section"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"In this example, we demonstrate the layout and solid model generation of a single transmon coupled to a readout resonator. In particular, this example demonstrates the additional steps necessary to generate a mesh suitable for electromagnetic simulation using external applications, such as the Palace solver. This example constructs the geometry used in the Palace release documentation and is aimed at demonstrating the power of the SolidModels capability.","category":"page"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"The full code for this example can be found in examples/SingleTransmon/SingleTransmon.jl in the DeviceLayout.jl repository. Components and process technology are drawn from the ExamplePDK.","category":"page"},{"location":"examples/singletransmon/#Overview","page":"Single-Transmon Simulation","title":"Overview","text":"","category":"section"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"The single transmon schematic design is simple, consisting of three components: an ExampleRectangleTransmon, an ExampleClawedMeanderReadout, and a coplanar waveguide path. The path additionally demonstrates how to terminate a path using lumped ports.","category":"page"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"Once the mesh has been generated, configfile(sm::SolidModel; palace_build=nothing) will ingest the SolidModel and return a dictionary representing a Palace configuration. If the optional palace_build directory is also passed then the configuration file will be validated using the Palace provided JSON schema.","category":"page"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"The generated configuration and mesh files can then be run directly from within julia using the palace_job(config::Dict; palace_build, np=0, nt=1) which will write the config to config.json and if np > 0 attempt to run the Palace job from within the julia shell mode. If np>0 the configuration file will be written to disk ready for a manual call to Palace outside of julia.","category":"page"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"These three functions are all wrapped together in main(palace_build, np=0) which will build the SolidModel, and write the mesh and configuration file to disk, before optionally attempting to run Palace.","category":"page"},{"location":"examples/singletransmon/#SolidModel-construction","page":"Single-Transmon Simulation","title":"SolidModel construction","text":"","category":"section"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"To run the example we include the example/SingleTransmon/SingleTransmon.jl file and then call single_transmon(). This will construct the schematic and render the design to SolidModel. To visualize the resulting model in Gmsh, we then call SolidModels.gmsh.fltk.run().","category":"page"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"using DeviceLayout\ninclude(\"examples/SingleTransmon/SingleTransmon.jl\")\nsm = SingleTransmon.single_transmon()\nSolidModels.gmsh.fltk.run() # Opens Gmsh GUI","category":"page"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"Below, we show the mesh for the metal surfaces. You can also (barely) see the lumped ports at the ends of the readout line in red.","category":"page"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"<img src=\"../../assets/single_transmon_mesh.png\"/>","category":"page"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"The function exposes a number of parameters for the definition of the transmon and readout resonator, demonstrating how the kernel for an automated parameter search might be established. Aside from the design parameters there are two processing arguments: save_mesh::Bool, which performs the meshing of the SolidModel and writes the resulting mesh to disk as single_transmon.msh2 in the Gmsh 2.2 mesh format, and save_gds::Bool, which generates a GDS of the schematic and writes the resulting design to single_transmon.gds.","category":"page"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"The schematic design is significantly simplied compared to that of the quantum processor example, but has the same general structure: the three components are added to the schematic graph and attached to each other before being placed by plan into a floorplan, which is then furnished with air bridges.","category":"page"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"What differs from the processor example is the construction of the SolidModel. When we render! the floorplan to a SolidModel, instead of a LayoutTarget we provide a SolidModelTarget containing information about how to generate the 3D model. The SolidModelTarget is based on this definition from ExamplePDK:","category":"page"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"\"\"\"\n    const SINGLECHIP_SOLIDMODEL_TARGET::SolidModelTarget\n\nA `Target` for rendering to a `SolidModel` using the `ExamplePDK`'s process technology.\n\nContains rendering options and postrendering operations to create a solid model suitable\nfor simulation of a single-chip device (as opposed to a flipchip device).\n\"\"\"\nconst SINGLECHIP_SOLIDMODEL_TARGET = SolidModelTarget(\n    EXAMPLE_SINGLECHIP_TECHNOLOGY; # Thickness and height define z-height and extrusions\n    simulation=true, # Optional simulation-only geometry entities will be rendered\n    bounding_layers=[:simulated_area], # SIMULATED_AREA defines the simulation bounds\n    substrate_layers=[:chip_area], # CHIP_AREA will be extruded downward\n    indexed_layers=[:port, :lumped_element, :integration], # Automatically index these layers\n    postrender_ops=[ # Manual definition of operations to run after 2D rendering\n        (   # Get metal ground plane by subtracting negative from writeable area\n            \"metal\", # Output group name\n            SolidModels.difference_geom!, # Operation\n            (\"writeable_area\", \"metal_negative\", 2, 2), # (object, tool, object_dim, tool_dim)\n            :remove_object => true # Remove \"writeable_area\" group after operation\n        ),\n        (   # Then add any positive back in\n            \"metal\",\n            SolidModels.union_geom!,\n            (\"metal\", \"metal_positive\", 2, 2),\n            :remove_tool => true\n        ),\n        (   # Define a bulk physical group for all the substrates in the domain.\n            \"substrate\",\n            SolidModels.union_geom!,\n            (\"chip_area_extrusion\", \"chip_area_extrusion\", 3, 3),\n            :remove_object => true,\n            :remove_tool => true\n        ),\n        (   # Define the vacuum domain as the remainder of the simulation domain.\n            \"vacuum\",\n            SolidModels.difference_geom!,\n            (\"simulated_area_extrusion\", \"substrate\", 3, 3)\n        ),\n        # Generate staple bridges in \"bridge_metal\" group\n        SolidModels.staple_bridge_postrendering(;\n            base=\"bridge_base\",\n            bridge=\"bridge\",\n            bridge_height=10μm # Exaggerated, for visualization\n        )...,\n        (   # Union of all physical metal\n            \"metal\",\n            SolidModels.union_geom!,\n            (\"metal\", \"bridge_metal\"),\n            :remove_object => true,\n            :remove_tool => true\n        ),\n        ((\"metal\", SolidModels.difference_geom!, (\"metal\", \"port\")))\n    ],\n    # We only want to retain physical groups that we will need for specifying boundary\n    # conditions in the physical domain.\n    retained_physical_groups=[\n        (\"vacuum\", 3),\n        (\"substrate\", 3),\n        (\"metal\", 2),\n        (\"exterior_boundary\", 2)\n    ]\n)","category":"page"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"We modify it slightly to retain port_1, port_2, and lumped_element physical groups in order to use those in the simulation configuration.","category":"page"},{"location":"examples/singletransmon/#Configuration","page":"Single-Transmon Simulation","title":"Configuration","text":"","category":"section"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"Next, we generate a dictionary defining a Palace configuration, specifying the problem type, model, materials, boundary conditions, and solver settings. We can also validate the configuration if we have a path to a Palace build, which contains the schema for validation. For more details on configuration, see the Palace documentation.","category":"page"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"For this example, we define most of the configuration by hand. However, we need to identify which materials and boundary conditions apply to which volumes and surfaces in the model.","category":"page"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"By construction, the SolidModel contains physical groups identifying the volumes and surfaces we're interested in. Using SolidModels.attributes, we can get a dictionary mapping the names of the physical groups to the integer \"attribute\" identifying the corresponding entities in the mesh. We can then use this dictionary to populate the configuration automatically according to the physical intent behind the model, without having to worry about whether the underlying geometry or attribute numbering might change.","category":"page"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"\"\"\"\n    configfile(sm::SolidModel; palace_build=nothing)\n\nGiven a `SolidModel`, assemble a dictionary defining a configuration file for use within\nPalace.\n\n  - `sm`: The `SolidModel`from which to construct the configuration file\n  - `palace_build = nothing`: Path to a Palace build directory, used to perform validation of\n    the configuration file. If not present, no validation is performed.\n\"\"\"\nfunction configfile(sm::SolidModel; palace_build=nothing)\n    attributes = SolidModels.attributes(sm)\n\n    config = Dict(\n        \"Problem\" => Dict(\n            \"Type\" => \"Eigenmode\",\n            \"Verbose\" => 2,\n            \"Output\" => joinpath(@__DIR__, \"postpro/single-transmon\")\n        ),\n        \"Model\" => Dict(\n            \"Mesh\" => joinpath(@__DIR__, \"single_transmon.msh2\"),\n            \"L0\" => DeviceLayout.ustrip(m, 1SolidModels.STP_UNIT), # um is Palace default; record it anyway\n            \"Refinement\" => Dict(\n                \"MaxIts\" => 0 # Increase to enable AMR\n            )\n        ),\n        \"Domains\" => Dict(\n            \"Materials\" => [\n                Dict(\n                    # Vaccuum\n                    \"Attributes\" => [attributes[\"vacuum\"]],\n                    \"Permeability\" => 1.0,\n                    \"Permittivity\" => 1.0\n                ),\n                Dict(\n                    # Sapphire\n                    \"Attributes\" => [attributes[\"substrate\"]],\n                    \"Permeability\" => [0.99999975, 0.99999975, 0.99999979],\n                    \"Permittivity\" => [9.3, 9.3, 11.5],\n                    \"LossTan\" => [3.0e-5, 3.0e-5, 8.6e-5],\n                    \"MaterialAxes\" =>\n                        [[0.8, 0.6, 0.0], [-0.6, 0.8, 0.0], [0.0, 0.0, 1.0]]\n                )\n            ],\n            \"Postprocessing\" => Dict(\n                \"Energy\" => [Dict(\"Index\" => 1, \"Attributes\" => [attributes[\"substrate\"]])]\n            )\n        ),\n        \"Boundaries\" => Dict(\n            \"PEC\" => Dict(\"Attributes\" => [attributes[\"metal\"]]),\n            \"Absorbing\" => Dict(\n                \"Attributes\" => [attributes[\"exterior_boundary\"]],\n                \"Order\" => 1\n            ),\n            \"LumpedPort\" => [\n                Dict(\n                    \"Index\" => 1,\n                    \"Attributes\" => [attributes[\"port_1\"]],\n                    \"R\" => 50,\n                    \"Direction\" => \"+X\"\n                ),\n                Dict(\n                    \"Index\" => 2,\n                    \"Attributes\" => [attributes[\"port_2\"]],\n                    \"R\" => 50,\n                    \"Direction\" => \"+X\"\n                ),\n                Dict(\n                    \"Index\" => 3,\n                    \"Attributes\" => [attributes[\"lumped_element\"]],\n                    \"L\" => 14.860e-9,\n                    \"C\" => 5.5e-15,\n                    \"Direction\" => \"+Y\"\n                )\n            ]\n        ),\n        \"Solver\" => Dict(\n            \"Order\" => 1,\n            \"Eigenmode\" => Dict(\"N\" => 2, \"Tol\" => 1.0e-6, \"Target\" => 2, \"Save\" => 2),\n            \"Linear\" => Dict(\"Type\" => \"Default\", \"Tol\" => 1.0e-7, \"MaxIts\" => 500)\n        )\n    )\n\n    if !isnothing(palace_build)\n        # Load the json schema and validate the configuration\n        schema_dir = joinpath(palace_build, \"bin\", \"schema\")\n        schema = Schema(\n            JSON.parsefile(joinpath(schema_dir, \"config-schema.json\"));\n            parent_dir=schema_dir\n        )\n        validate(schema, config)\n    end\n\n    return config\nend","category":"page"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"The output should look like this:","category":"page"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"Configuration: 0.000082 seconds (327 allocations: 31.391 KiB)\nDict{String, Dict{String, Any}} with 5 entries:\n  \"Problem\"    => Dict(\"Verbose\"=>...)\n  \"Boundaries\" => Dict(\"LumpedPort\"=>...)\n  \"Model\"      => Dict(\"Refinement\"=>...)\n  \"Domains\"    => Dict(\"Postprocessing\"=>...)\n  \"Solver\"     => Dict(\"Eigenmode\"=>...)","category":"page"},{"location":"examples/singletransmon/#*Palace*","page":"Single-Transmon Simulation","title":"Palace","text":"","category":"section"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"Finally, we write the configuration to a file, call Palace, and parse the computed eigenfrequencies from its output:","category":"page"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"\"\"\"\n    palace_job(config::Dict; palace_build, np=0, nt=1)\n\nGiven a configuration dictionary, write and optionally run the Palace simulation.\n\nWrites `config.json` to `@__DIR__` in order to pass the configuration into Palace.\n\n  - `config` - A configuration file defining the required fields for a Palace configuration file\n  - `palace_build` - Path to a Palace build.\n  - `np = 0` - Number of MPI processes to use in the call to Palace. If greater than 0 attempts\n    to call palace from within the Julia shell. Requires correct specification of `ENV[PATH]`.\n  - `nt = 1` - Number of OpenMp threads to use in the call to Palace (requires Palace built with\n    OpenMp)\n\"\"\"\nfunction palace_job(config::Dict; palace_build, np=0, nt=1)\n    # Write the configuration file to json, ready for Palace ingestion\n    println(\"Writing configuration file to $(joinpath(@__DIR__, \"config.json\"))\")\n    open(joinpath(@__DIR__, \"config.json\"), \"w\") do f\n        return JSON.print(f, config)\n    end\n\n    if np > 0\n        # Call Palace using the generated configuration file.\n        # Record the terminal output and any error to files.\n        println(\"Running Palace: stdout sent to log.out, stderr sent to err.out\")\n        withenv(\"PATH\" => \"$(ENV[\"PATH\"]):$palace_build/bin\") do\n            return run(\n                pipeline(\n                    ignorestatus(\n                        `palace -np $np -nt $nt $(joinpath(@__DIR__,\"config.json\"))`\n                    ),\n                    stdout=joinpath(@__DIR__, \"log.out\"),\n                    stderr=joinpath(@__DIR__, \"err.out\")\n                )\n            )\n        end\n        println(\"Complete.\")\n\n        # Extract the computed frequencies\n        postprodir = joinpath(@__DIR__, config[\"Problem\"][\"Output\"])\n        freq = CSV.File(joinpath(postprodir, \"eig.csv\"); header=1) |> DataFrame\n\n        println(\"Eigenmode Frequencies (GHz): \", freq[:, 2])\n    end\n    return nothing\nend","category":"page"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"The output should look like this:","category":"page"},{"location":"examples/singletransmon/","page":"Single-Transmon Simulation","title":"Single-Transmon Simulation","text":"Writing configuration file to /path/to/your/config.json\nRunning Palace: stdout sent to log.out, stderr sent to err.out\nComplete.\nEigenmode Frequencies (GHz): [3.161773657, 4.878135762]\nPalace: 52.914418 seconds (669 allocations: 46.422 KiB)","category":"page"},{"location":"polygons/#Abstract-polygons","page":"Polygons","title":"Abstract polygons","text":"","category":"section"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"In this package, any polygon regardless of its concrete representation in memory should be a subtype of DeviceLayout.AbstractPolygon. Usually, when we write \"polygon\" in unformatted text, we mean AbstractPolygon. (In this documentation, we try to follow this pattern for common words and corresponding abstract types. For example, we'll use \"coordinate system\" to mean any AbstractCoordinateSystem including Cell, not necessarily just CoordinateSystem.)","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"    DeviceLayout.AbstractPolygon","category":"page"},{"location":"polygons/#DeviceLayout.AbstractPolygon","page":"Polygons","title":"DeviceLayout.AbstractPolygon","text":"abstract type AbstractPolygon{T} <: GeometryEntity{T} end\n\nAnything you could call a polygon regardless of the underlying representation. Currently only Rectangle or Polygon are concrete subtypes, but one could imagine further subtypes to represent specific shapes that appear in highly optimized pattern formats. Examples include the OASIS format (which has 25 implementations of trapezoids) or e-beam lithography pattern files like the Raith GPF format.\n\n\n\n\n\n","category":"type"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"The most important polygon subtype is Polygon, which is defined by a vector of points. Polygon is the primitive entity type for Cell—any shape being rendered to a Cell must end up represented as one or more Polygon. The GeometryEntity interface provides a to_polygons function that produces that representation. Most functions in the geometry interface (besides transformation, which must be implemented by subtypes) will fall back to calling to_polygons on entities first if there is no specialized method.","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"For example, if you ask for the bounding box of a path node (which could define a shape like multiple parallel brushstrokes) bounds(node) will simply find the bounding box of the polygon(s) from to_polygons(node), using the default tolerance for discretization of curves.","category":"page"},{"location":"polygons/#Clipping","page":"Polygons","title":"Clipping","text":"","category":"section"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"Geometric Boolean operations on polygons are called \"clipping\" operations. For 2D geometry, these—union2d, difference2d, and intersection2d—are the only geometric Booleans available. Other geometry types are first converted to polygons using to_polygons to perform clipping.","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"info: Info\nBoolean operations in 3D with SolidModel are handled by the Open CASCADE Technology kernel, which works directly with rich geometry types rendered from our native CoordinateSystem.","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"For many use cases, union2d, difference2d, and intersect2d behave as expected and are easiest to use. More general operations may be accomplished using the clip function.","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"    union2d\n    difference2d\n    intersect2d\n    clip\n    cliptree","category":"page"},{"location":"polygons/#DeviceLayout.Polygons.union2d","page":"Polygons","title":"DeviceLayout.Polygons.union2d","text":"union2d(p1, p2)\n\nReturn the geometric union of p1 and p2 as a ClippedPolygon.\n\nEach of p1 and p2 may be a GeometryEntity or array of GeometryEntity. All entities are first converted to polygons using to_polygons.\n\nEach of p1 and p2 can also be a GeometryStructure or GeometryReference, in which case elements(flatten(p)) will be converted to polygons.\n\nEach can also be a pair geom => layer, where geom is a GeometryStructure or GeometryReference, while layer is a DeviceLayout.Meta, a layer name Symbol, and/or a collection of either, in which case only the elements in those layers will used.\n\nThis is not implemented as a method of union because you can have a set union of arrays of polygons, which is a distinct operation.\n\nThe Clipper polyfill rule is PolyFillTypePositive, meaning as long as a region lies within more non-hole (by orientation) than hole polygons, it lies in the union.\n\n\n\n\n\nunion2d(p)\n\nReturn the geometric union of p or all entities in p.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#DeviceLayout.Polygons.difference2d","page":"Polygons","title":"DeviceLayout.Polygons.difference2d","text":"difference2d(p1, p2)\n\nReturn the geometric union of p1 minus the geometric union of p2 as a ClippedPolygon.\n\nEach of p1 and p2 may be a GeometryEntity or array of GeometryEntity. All entities are first converted to polygons using to_polygons.\n\nEach of p1 and p2 can also be a GeometryStructure or GeometryReference, in which case elements(flatten(p)) will be converted to polygons.\n\nEach can also be a pair geom => layer, where geom is a GeometryStructure or GeometryReference, while layer is a DeviceLayout.Meta, a layer name Symbol, and/or a collection of either, in which case only the elements in those layers will be used.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#DeviceLayout.Polygons.intersect2d","page":"Polygons","title":"DeviceLayout.Polygons.intersect2d","text":"intersect2d(p1, p2)\n\nReturn the geometric union of p1 intersected with the geometric union of p2  as a ClippedPolygon.\n\nEach of p1 and p2 may be a GeometryEntity or array of GeometryEntity. All entities are first converted to polygons using to_polygons.\n\nEach of p1 and p2 can also be a GeometryStructure or GeometryReference, in which case elements(flatten(p)) will be converted to polygons.\n\nEach can also be a pair geom => layer, where geom is a GeometryStructure or GeometryReference, while layer is a DeviceLayout.Meta, a layer name Symbol, and/or a collection of either, in which case only the elements in those layers will be used.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#DeviceLayout.Polygons.clip","page":"Polygons","title":"DeviceLayout.Polygons.clip","text":"clip(op::Clipper.ClipType, s, c; kwargs...) where {S<:Coordinate, T<:Coordinate}\nclip(op::Clipper.ClipType, s::AbstractVector{A}, c::AbstractVector{B};\n    kwargs...) where {S, T, A<:Polygon{S}, B<:Polygon{T}}\nclip(op::Clipper.ClipType,\n    s::AbstractVector{Polygon{T}}, c::AbstractVector{Polygon{T}};\n    pfs::Clipper.PolyFillType=Clipper.PolyFillTypeEvenOdd,\n    pfc::Clipper.PolyFillType=Clipper.PolyFillTypeEvenOdd) where {T}\n\nReturn the ClippedPolygon resulting from a polygon clipping operation.\n\nUses the Clipper library and the Clipper.jl wrapper to perform polygon clipping.\n\nPositional arguments\n\nThe first argument must be one of the following types to specify a clipping operation:\n\nClipper.ClipTypeDifference\nClipper.ClipTypeIntersection\nClipper.ClipTypeUnion\nClipper.ClipTypeXor\n\nNote that these are types; you should not follow them with ().\n\nThe second and third argument may be a GeometryEntity or array of GeometryEntity. All entities are first converted to polygons using to_polygons. Each can also be a GeometryStructure or GeometryReference, in which case elements(flatten(p)) will be converted to polygons. Each can also be a pair geom => layer, where geom is a GeometryStructure or GeometryReference, while layer is a DeviceLayout.Meta, a layer name Symbol, and/or a collection of either, in which case only the elements in those layers will be taken from the flattened structure.\n\nKeyword arguments\n\npfs and pfc specify polygon fill rules for the s and c arguments, respectively. These arguments may include:\n\nClipper.PolyFillTypeNegative\nClipper.PolyFillTypePositive\nClipper.PolyFillTypeEvenOdd\nClipper.PolyFillTypeNonZero\n\nSee the Clipper docs for further information.\n\nSee also union2d, difference2d, and intersect2d.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#DeviceLayout.Polygons.cliptree","page":"Polygons","title":"DeviceLayout.Polygons.cliptree","text":"cliptree(op::Clipper.ClipType, s::AbstractPolygon{S}, c::AbstractPolygon{T};\n    kwargs...) where {S<:Coordinate, T<:Coordinate}\ncliptree(op::Clipper.ClipType, s::AbstractVector{A}, c::AbstractVector{B};\n    kwargs...) where {S, T, A<:AbstractPolygon{S}, B<:AbstractPolygon{T}}\ncliptree(op::Clipper.ClipType,\n    s::AbstractVector{Polygon{T}}, c::AbstractVector{Polygon{T}};\n    pfs::Clipper.PolyFillType=Clipper.PolyFillTypeEvenOdd,\n    pfc::Clipper.PolyFillType=Clipper.PolyFillTypeEvenOdd) where {T}\n\nReturn a Clipper.PolyNode representing parent-child relationships between polygons and interior holes. The units and number type may need to be converted.\n\nUses the Clipper library and the Clipper.jl wrapper to perform polygon clipping.\n\nPositional arguments\n\nThe first argument must be one of the following types to specify a clipping operation:\n\nClipper.ClipTypeDifference\nClipper.ClipTypeIntersection\nClipper.ClipTypeUnion\nClipper.ClipTypeXor\n\nNote that these are types; you should not follow them with (). The second and third arguments are AbstractPolygons or vectors thereof.\n\nKeyword arguments\n\npfs and pfc specify polygon fill rules for the s and c arguments, respectively. These arguments may include:\n\nClipper.PolyFillTypeNegative\nClipper.PolyFillTypePositive\nClipper.PolyFillTypeEvenOdd\nClipper.PolyFillTypeNonZero\n\nSee the Clipper docs for further information.\n\n\n\n\n\n","category":"function"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"The results of clipping are represented using the ClippedPolygon <: AbstractPolygon type, which stores a tree of positive and negative contours. These mainly exist to represent polygons with holes without having to generate \"keyhole\" polygons as required by the GDSII format. This ends up being convenient for other backends that don't want keyhole polygons as well as for applying different styles to different boundary or hole contours.","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"    Polygons.ClippedPolygon","category":"page"},{"location":"polygons/#DeviceLayout.Polygons.ClippedPolygon","page":"Polygons","title":"DeviceLayout.Polygons.ClippedPolygon","text":"struct ClippedPolygon{T} <: AbstractPolygon{T}\n    tree::Clipper.PolyNode{Point{T}}\nend\n\nCollection of polygons defined by a call to Clipper.\n\n\n\n\n\n","category":"type"},{"location":"polygons/#Styles","page":"Polygons","title":"Styles","text":"","category":"section"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"In addition to other generic entity styles like NoRender, AbstractPolygons can be paired with the Rounded style. ClippedPolygons support StyleDict, which allows for different styles to be applied to different contours in its tree.","category":"page"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"    Polygons.Rounded\n    Polygons.StyleDict","category":"page"},{"location":"polygons/#DeviceLayout.Polygons.Rounded","page":"Polygons","title":"DeviceLayout.Polygons.Rounded","text":"struct Rounded{T <: Coordinate} <: GeometryEntityStyle\n    abs_r::T = zero(T)\n    rel_r::Float64 = 0.0\n    min_side_len::T = r\n    min_angle::Float64 = 1e-3\n    p0::Vector{Point{T}} = []\n    inverse_selection::Bool = false\nend\n\nRounded polygon style defined by either radius absolute radius abs_r or relative radius rel_r. Only one of abs_r or rel_r can be non-zero at once. Can't handle shapes with interior cuts, or shapes with too sharp of angles relative to segment length. If rel_r is non-zero the radius of curvature at each vertex is calculated with rel_r * min(l₁, l₂) where l₁ and l₂ denote the length of the two attached line segments.\n\nExample usage:\n\nr = Rectangle(10μm, 10μm)\nrsty = Rounded(1μm)\n# Create a rounded rectangle StyledEntity with different options for syntax\nrounded_rect = rsty(r)\nrounded_rect = styled(r, rsty)\nrounded_rect = Rounded(r, 1μm)\n# Turn the result into a plain Polygon\nrounded_rect_discretized_poly = to_polygons(rounded_rect)\n\nKeyword arguments\n\nmin_side_len: The minimum side length that will get rounded (e.g. for 90-degree angles, it makes sense to have min_side_len = 2 * rounding_radius). This currently uses exact comparison, so it may result in very short straight edges or failure to round a corner due to floating point imprecision.\nmin_angle: If adjacent sides are collinear within the tolerance set by min_angle, rounding will not be performed.\np0: set of target points used to select vertices to attempt to round when applied to a polygon. Selected vertices where min_side_len and min_angle are satisfied will be rounded. If empty, all vertices will be selected. Otherwise, for each point in p0, the nearest point in the styled polygon will be selected. Note that for a ClippedPolygon, the same p0 will be used for every contour; for different rounding styles on different contours, use StyleDict.\ninverse_selection: If true, the selection from p0 is inverted; that is, all corners will be rounded except those selected by p0.\n\n\n\n\n\n","category":"type"},{"location":"polygons/#DeviceLayout.Polygons.StyleDict","page":"Polygons","title":"DeviceLayout.Polygons.StyleDict","text":"struct StyleDict{S} <: GeometryEntityStyle where {S}\n    styles::Dict{Vector{Int}, GeometryEntityStyle},\n    default::S\nend\n\nStyle used for applying differing styles to different Polygons at different levels within a ClippedPolygon or CurvilinearRegion. Styles are stored by the sequence of child indices required to find the corresponding Clipper.PolyNode within the ClippedPolygon. For a CurvilinearRegion only dictionaries of depth 2 (a single parent and one set of holes) are valid.\n\n\n\n\n\n","category":"type"},{"location":"polygons/#Offsetting","page":"Polygons","title":"Offsetting","text":"","category":"section"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"    offset","category":"page"},{"location":"polygons/#DeviceLayout.offset","page":"Polygons","title":"DeviceLayout.offset","text":"offset{S<:Coordinate}(s::AbstractPolygon{S}, delta::Coordinate;\n    j::Clipper.JoinType=Clipper.JoinTypeMiter,\n    e::Clipper.EndType=Clipper.EndTypeClosedPolygon)\noffset{S<:AbstractPolygon}(subject::AbstractVector{S}, delta::Coordinate;\n    j::Clipper.JoinType=Clipper.JoinTypeMiter,\n    e::Clipper.EndType=Clipper.EndTypeClosedPolygon)\noffset{S<:Polygon}(s::AbstractVector{S}, delta::Coordinate;\n    j::Clipper.JoinType=Clipper.JoinTypeMiter,\n    e::Clipper.EndType=Clipper.EndTypeClosedPolygon)\n\nUsing the Clipper library and the Clipper.jl wrapper, perform polygon offsetting.\n\nThe orientations of polygons must be consistent, such that outer polygons share the same orientation, and any holes have the opposite orientation. Additionally, any holes should be contained within outer polygons; offsetting hole edges may create positive artifacts at corners.\n\nThe first argument should be an AbstractPolygon. The second argument is how much to offset the polygon. Keyword arguments include a join type:\n\nClipper.JoinTypeMiter\nClipper.JoinTypeRound\nClipper.JoinTypeSquare\n\nand also an end type:\n\nClipper.EndTypeClosedPolygon\nClipper.EndTypeClosedLine\nClipper.EndTypeOpenSquare\nClipper.EndTypeOpenRound\nClipper.EndTypeOpenButt\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Rectangle-API","page":"Polygons","title":"Rectangle API","text":"","category":"section"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"    Rectangle\n    Rectangle(::Point, ::Point)\n    Rectangle(::Any, ::Any)\n    bounds(::Rectangle)\n    height(::Rectangle)\n    isproper(::Rectangle)\n    lowerleft(::Rectangle)\n    upperright(::Rectangle)\n    points(::Rectangle{T}) where {T<:Real}\n    width(::Rectangle)","category":"page"},{"location":"polygons/#DeviceLayout.Rectangles.Rectangle","page":"Polygons","title":"DeviceLayout.Rectangles.Rectangle","text":"struct Rectangle{T} <: AbstractPolygon{T}\n    ll::Point{T}\n    ur::Point{T}\n    function Rectangle(a,b)\n        # Ensure ll is lower-left, ur is upper-right.\n        ll = Point(a.<=b) .* a + Point(b.<=a) .* b\n        ur = Point(a.<=b) .* b + Point(b.<=a) .* a\n        new(ll,ur)\n    end\nend\n\nA rectangle, defined by opposing lower-left and upper-right corner coordinates. Lower-left and upper-right are guaranteed to be such by the inner constructor.\n\n\n\n\n\n","category":"type"},{"location":"polygons/#DeviceLayout.Rectangles.Rectangle-Tuple{Point, Point}","page":"Polygons","title":"DeviceLayout.Rectangles.Rectangle","text":"Rectangle(ll::Point, ur::Point)\n\nConvenience constructor for Rectangle objects.\n\n\n\n\n\n","category":"method"},{"location":"polygons/#DeviceLayout.Rectangles.Rectangle-Tuple{Any, Any}","page":"Polygons","title":"DeviceLayout.Rectangles.Rectangle","text":"Rectangle(width, height)\n\nConstructs Rectangle objects by specifying the width and height rather than the lower-left and upper-right corners.\n\nThe rectangle will sit with the lower-left corner at the origin. With centered rectangles we would need to divide width and height by 2 to properly position. If we wanted an object of Rectangle{Int} type, this would not be possible if either width or height were odd numbers. This definition ensures type stability in the constructor.\n\nRectangle has the special importance of being the return type of bounds.\n\n\n\n\n\n","category":"method"},{"location":"polygons/#DeviceLayout.bounds-Tuple{Rectangle}","page":"Polygons","title":"DeviceLayout.bounds","text":"bounds(r::Rectangle)\n\nNo-op (just returns r).\n\n\n\n\n\n","category":"method"},{"location":"polygons/#DeviceLayout.Rectangles.height-Tuple{Rectangle}","page":"Polygons","title":"DeviceLayout.Rectangles.height","text":"height(r::Rectangle)\n\nReturn the height of a rectangle.\n\n\n\n\n\n","category":"method"},{"location":"polygons/#DeviceLayout.Rectangles.isproper-Tuple{Rectangle}","page":"Polygons","title":"DeviceLayout.Rectangles.isproper","text":"isproper(r::Rectangle)\n\nReturn true if the rectangle has a non-zero area. Otherwise, returns false. Note that the upper-right and lower-left corners are enforced to be the ur and ll fields of a Rectangle by the inner constructor.\n\n\n\n\n\n","category":"method"},{"location":"polygons/#DeviceLayout.Points.lowerleft-Tuple{Rectangle}","page":"Polygons","title":"DeviceLayout.Points.lowerleft","text":"lowerleft(r::Rectangle)\n\nReturn the lower-left corner of a rectangle (Point object).\n\n\n\n\n\n","category":"method"},{"location":"polygons/#DeviceLayout.Points.upperright-Tuple{Rectangle}","page":"Polygons","title":"DeviceLayout.Points.upperright","text":"upperright(r::Rectangle)\n\nReturn the upper-right corner of a rectangle (Point object).\n\n\n\n\n\n","category":"method"},{"location":"polygons/#DeviceLayout.Polygons.points-Union{Tuple{Rectangle{T}}, Tuple{T}} where T<:Real","page":"Polygons","title":"DeviceLayout.Polygons.points","text":"points{T}(x::Rectangle{T})\n\nReturn the array of Point objects defining the rectangle.\n\n\n\n\n\n","category":"method"},{"location":"polygons/#DeviceLayout.Rectangles.width-Tuple{Rectangle}","page":"Polygons","title":"DeviceLayout.Rectangles.width","text":"width(r::Rectangle)\n\nReturn the width of a rectangle.\n\n\n\n\n\n","category":"method"},{"location":"polygons/#Polygon-API","page":"Polygons","title":"Polygon API","text":"","category":"section"},{"location":"polygons/","page":"Polygons","title":"Polygons","text":"    Polygon\n    Polygon(::AbstractVector{Point{T}}) where {T}\n    Polygon(::Point, ::Point, ::Point, ::Point...)\n    perimeter\n    points\n    sweep_poly\n    gridpoints_in_polygon","category":"page"},{"location":"polygons/#DeviceLayout.Polygons.Polygon","page":"Polygons","title":"DeviceLayout.Polygons.Polygon","text":"struct Polygon{T} <: AbstractPolygon{T}\n    p::Vector{Point{T}}\n    Polygon(x) = new(x)\n    Polygon(x::AbstractPolygon) = convert(Polygon{T}, x)\nend\n\nPolygon defined by list of coordinates. The first point should not be repeated at the end (although this is true for the GDS format).\n\n\n\n\n\n","category":"type"},{"location":"polygons/#DeviceLayout.Polygons.Polygon-Union{Tuple{AbstractArray{Point{T}, 1}}, Tuple{T}} where T","page":"Polygons","title":"DeviceLayout.Polygons.Polygon","text":"Polygon{T}(parr::AbstractVector{Point{T}})\n\nConvenience constructor for a Polygon{T} object.\n\n\n\n\n\n","category":"method"},{"location":"polygons/#DeviceLayout.Polygons.Polygon-Tuple{Point, Point, Point, Vararg{Point}}","page":"Polygons","title":"DeviceLayout.Polygons.Polygon","text":"Polygon(p0::Point, p1::Point, p2::Point, p3::Point...)\n\nConvenience constructor for a Polygon{T} object.\n\n\n\n\n\n","category":"method"},{"location":"polygons/#DeviceLayout.Polygons.perimeter","page":"Polygons","title":"DeviceLayout.Polygons.perimeter","text":"perimeter(poly::AbstractPolygon)\n\nThe (Euclidean) perimeter of an AbstractPolygon.\n\n\n\n\n\nperimeter(poly::ClippedPolygon)\n\nThe (Euclidean) perimeter of the outermost contour of a ClippedPolygon\n\n\n\n\n\nperimeter(poly::Ellipse)\n\nApproximate (Euclidean) perimeter of an Ellipse using Ramanujan's approximation formula https://arxiv.org/pdf/math/0506384.pdf\n\n\n\n\n\n","category":"function"},{"location":"polygons/#DeviceLayout.Polygons.points","page":"Polygons","title":"DeviceLayout.Polygons.points","text":"points(x::Polygon)\n\nReturn the array of Point objects defining the polygon.\n\n\n\n\n\npoints{T}(x::Rectangle{T})\n\nReturn the array of Point objects defining the rectangle.\n\n\n\n\n\npoints(x::ClippedPolygon)\n\nReturn the array of Point objects that define the keyhole polygon.\n\n\n\n\n\npoints(x::Clipper.PolyNode)\n\nReturn the array of Point objects that make up the contour of the PolyNode\n\n\n\n\n\n","category":"function"},{"location":"polygons/#DeviceLayout.Polygons.sweep_poly","page":"Polygons","title":"DeviceLayout.Polygons.sweep_poly","text":"sweep_poly(poly::Polygon, displacement::Point)\n\nReturn a Polygon corresponding to the boundary formed by poly swept by displacement.\n\nThis is the result you would get by painting with a brush shaped like poly and moving it along a line by displacement.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#DeviceLayout.Polygons.gridpoints_in_polygon","page":"Polygons","title":"DeviceLayout.Polygons.gridpoints_in_polygon","text":"gridpoints_in_polygon(poly::AbstractArray{<:AbstractPolygon},\n    dx::Coordinate, dy::Coordinate; b=nothing)\n\nReturn a BitArray for the gridpoints in b with true for gridpoints in poly.\n\nOnly grid points in the bounding box b will be considered; if b is nothing, then bounds(poly) is used. dx and dy are the distances between adjacent points on the rectangular grid. The grid points represented by the BitArray start from the lower left point p0 = (m*dx, n*dy) with m and n integers and p0 lying in b.\n\nAll polygons should have the same orientation (clockwise or counterclockwise). A mix (for example to represent \"holes\") may not give the desired behavior on polygon or hole edges.\n\n\n\n\n\ngridpoints_in_polygon(poly::AbstractArray{<:AbstractPolygon},\n    grid_x::AbstractArray, grid_y::AbstractArray)\n\nReturn a BitArray with true for points lying in some polygon in poly.\n\nThe BitArray values correspond to points (x, y) with x ∈ grid_x, y ∈ grid_y, starting from the lower left.\n\nAll polygons should have the same orientation (clockwise or counterclockwise). A mix (for example to represent \"holes\") may not give the desired behavior on polygon or hole edges.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/technologies/#Technologies","page":"Technologies","title":"Technologies","text":"","category":"section"},{"location":"schematicdriven/technologies/#ProcessTechnology","page":"Technologies","title":"ProcessTechnology","text":"","category":"section"},{"location":"schematicdriven/technologies/","page":"Technologies","title":"Technologies","text":"SchematicDrivenLayout.ProcessTechnology\nSchematicDrivenLayout.chip_thicknesses\nSchematicDrivenLayout.flipchip_gaps\nSchematicDrivenLayout.layer_thickness\nSchematicDrivenLayout.layer_height\nSchematicDrivenLayout.layer_z\nSchematicDrivenLayout.level_z","category":"page"},{"location":"schematicdriven/technologies/#DeviceLayout.SchematicDrivenLayout.ProcessTechnology","page":"Technologies","title":"DeviceLayout.SchematicDrivenLayout.ProcessTechnology","text":"struct ProcessTechnology\n    layer_record::NamedTuple\n    parameters::NamedTuple\nend\n\nSpecifies process-specific parameters and mapping of semantic layers (e.g., to GDS layers).\n\nThe interface for process parameters includes the functions layer_thickness, layer_height, chip_thicknesses, and flipchip_gaps, which use the following parameters entries if they are defined:\n\nthickness: A NamedTuple associating layer Symbols with a thickness or list of thicknesses indexed by level.\nheight: A NamedTuple associating layer Symbols with \"height\" or list of heights indexed by level. Height is the distance of a layer from the substrate surface at a given level, measured away from the substrate.\nchip_thicknesses: A Vector of thicknesses of chips from bottom to top, used for calculating the z coordinate of the surface for each level.\nflipchip_gaps: A Vector of gaps between chips in a flipchip stack, used with chip_thicknesses for calculating the z coordinate of the surface for each level.\n\nNote that other tools often have their own related concepts of a \"Technology\", but these may not directly correspond to our ProcessTechnology.\n\n\n\n\n\n","category":"type"},{"location":"schematicdriven/technologies/#DeviceLayout.SchematicDrivenLayout.chip_thicknesses","page":"Technologies","title":"DeviceLayout.SchematicDrivenLayout.chip_thicknesses","text":"chip_thicknesses(tech::ProcessTechnology)\n\nA Vector of thicknesses of chips (default [525μm, 525μm]).\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/technologies/#DeviceLayout.SchematicDrivenLayout.flipchip_gaps","page":"Technologies","title":"DeviceLayout.SchematicDrivenLayout.flipchip_gaps","text":"flipchip_gaps(tech::ProcessTechnology)\n\nA Vector of flipchip gaps (default [5μm]).\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/technologies/#DeviceLayout.SchematicDrivenLayout.layer_thickness","page":"Technologies","title":"DeviceLayout.SchematicDrivenLayout.layer_thickness","text":"layer_thickness(tech::ProcessTechnology, m::DeviceLayout.Meta)\n\nThe thickness of m in tech.parameters.thickness (0μm if not specified).\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/technologies/#DeviceLayout.SchematicDrivenLayout.layer_height","page":"Technologies","title":"DeviceLayout.SchematicDrivenLayout.layer_height","text":"layer_height(tech::ProcessTechnology, m::DeviceLayout.Meta)\n\nThe height of m in tech.parameters.height (0μm if not specified).\n\nHeight is measured outward from the substrate surface corresponding to level(m).\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/technologies/#DeviceLayout.SchematicDrivenLayout.layer_z","page":"Technologies","title":"DeviceLayout.SchematicDrivenLayout.layer_z","text":"layer_z(tech::ProcessTechnology, m::DeviceLayout.Meta)\n\nThe z position corresponding to metadata m.\n\nUses chip_thicknesses(tech) and flipchip_gaps(tech) to determine the z coordinate corresponding to level(m), then adds or subtracts layer_height(tech, m) for odd or even level(m), respectively. (That is, the layer height is measured outward from the substrate surface using the flipchip level convention.)\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/technologies/#DeviceLayout.SchematicDrivenLayout.level_z","page":"Technologies","title":"DeviceLayout.SchematicDrivenLayout.level_z","text":"level_z(l::Integer; t_chips=[525μm, 525μm], t_gaps=[5μm])\n\nReturn the z position corresponding to level l.\n\nUses the flip-chip level convention (see facing, backing).\n\nKeywords\n\nt_chips: A list of chip thicknesses from bottom to top\nt_gaps: A list of gap thicknesses between substrates\n\nt_gaps should start at the same index as t_chips and have length length(t_chips) - 1. Level 1 is at z = 0.\n\n\n\n\n\n","category":"function"},{"location":"routes/#Routes","page":"Routes","title":"Routes","text":"","category":"section"},{"location":"routes/","page":"Routes","title":"Routes","text":"A Paths.Route implicitly defines a Path between two points, following a Paths.RouteRule, with a specified start and end direction. It's a building block for \"interactive autorouting\". For simple cases, it lets you define a path between two points without having to do any geometric calculations yourself. In more complicated cases, you can provide additional waypoint constraints to guide it.","category":"page"},{"location":"routes/","page":"Routes","title":"Routes","text":"To draw a Path from a Route, you can use Path(r::Route, sty).","category":"page"},{"location":"routes/","page":"Routes","title":"Routes","text":"More often, you won't work directly with the Route type but will instead use route! to extend an existing path to an endpoint according to the rules you specify.","category":"page"},{"location":"routes/#Route-API","page":"Routes","title":"Route API","text":"","category":"section"},{"location":"routes/","page":"Routes","title":"Routes","text":"    Paths.Route","category":"page"},{"location":"routes/#DeviceLayout.Paths.Route","page":"Routes","title":"DeviceLayout.Paths.Route","text":"struct Route{T<:RouteRule, S<:Coordinate}\nRoute(rule, startpoint::Point{S}, endpoint::Point, start_direction, end_direction; waypoints=Point{S}[], waydirs=[])\nRoute(rule, path0::Path, endpoint::Point, end_direction)\n\nA Route implicitly defines a Path between two points with given start and end directions.\n\nUse Path(r::Route, sty::Paths.Style) to create the explicit path.\n\nContains a RouteRule to determine how the Path should be drawn.\n\nMay contain waypoints and waydirs that additionally constrain the route. The RouteRule determines how these are handled, by default routing waypoint-to-waypoint such that the path starts at p0, passes through each point in waypoints in order, and then ends at p1.\n\nIf waydirs is not nothing, it should have the same length as waypoints. If waydirs is provided and is not ignored by the RouteRule (check the specific rule documentation), then waypoints[i] will be reached with the path pointing along waydirs[i].\n\n\n\n\n\n","category":"type"},{"location":"routes/#Route-rules","page":"Routes","title":"Route rules","text":"","category":"section"},{"location":"routes/","page":"Routes","title":"Routes","text":"    Paths.RouteRule\n    Paths.BSplineRouting\n    Paths.StraightAnd90\n    Paths.StraightAnd45\n    Paths.CompoundRouteRule","category":"page"},{"location":"routes/#DeviceLayout.Paths.RouteRule","page":"Routes","title":"DeviceLayout.Paths.RouteRule","text":"abstract type RouteRule end\n\nControls how a Route is turned into a Path.\n\nA RouteRule may contain parameters or be used only for dispatch. It should implement one of the following two methods:\n\n_route!(p::Path, p1::Point, α1, rule::MyRouteRule, sty, waypoints, waydirs)\n_route_leg!(p::Path, next::Point, rule::MyRouteRule,\n    sty::Paths.Style=Paths.contstyle1(p))\n\nIt may also implement\n\nreconcile!(path::Path, endpoint::Point,\n    end_direction, rule::RouteRule, waypoints, waydirs; initialize_waydirs)\n\nIf only _route_leg! is implemented, then a Path drawn from r::Route with MyRouteRule will first call reconcile! to validate constraints and insert waypoints if necessary. (The default implementation of reconcile! does nothing.) The Path will then be routed waypoint-to-waypoint such that the path starts at r.p0, passes through each point in r.waypoints in order, and then ends at r.p1, ignoring waydirs. Alternatively, _route! can be implemented to use r.waypoints and/or r.waydirs all at once as desired.\n\n\n\n\n\n","category":"type"},{"location":"routes/#DeviceLayout.Paths.BSplineRouting","page":"Routes","title":"DeviceLayout.Paths.BSplineRouting","text":"Base.@kwdef struct BSplineRouting <: RouteRule\n    endpoints_speed = 2500μm\nend\n\nSpecifies rules for routing from one point to another using BSplines.\n\nIgnores waydirs.\n\n\n\n\n\n","category":"type"},{"location":"routes/#DeviceLayout.Paths.StraightAnd90","page":"Routes","title":"DeviceLayout.Paths.StraightAnd90","text":"Base.@kwdef struct StraightAnd90 <: RouteRule\n    min_bend_radius = 200μm\n    max_bend_radius = Inf*μm\nend\n\nSpecifies rules for routing from one point to another using straight segments and 90° bends.\n\nCan be used with no waydirs if each waypoint is reachable from the previous with a single turn and the endpoint is reachable with a single turn or two turns in opposite directions.\n\nIf waydirs are used, then any waypoint may be reachable with two turns in opposite directions if that satisfies the corresponding waydirection.\n\n\n\n\n\n","category":"type"},{"location":"routes/#DeviceLayout.Paths.StraightAnd45","page":"Routes","title":"DeviceLayout.Paths.StraightAnd45","text":"Base.@kwdef struct StraightAnd45 <: RouteRule\n    min_bend_radius = 200μm\n    max_bend_radius = Inf*μm\nend\n\nSpecifies rules for routing from one point to another using using straight segments and 45° bends.\n\nCan be used with no waydirs if each waypoint is reachable from the previous with a single turn and the endpoint is reachable with one or two turns.\n\nIf waydirs are used, then any waypoint may be reachable with two turns if that satisfies the corresponding waydirection.\n\n\n\n\n\n","category":"type"},{"location":"routes/#DeviceLayout.Paths.CompoundRouteRule","page":"Routes","title":"DeviceLayout.Paths.CompoundRouteRule","text":"CompoundRouteRule <: RouteRule\nCompoundRouteRule(rules::Vector{RouteRule}, leg_length::Vector{Int}=ones(length(rules)))\n\nSpecifies a sequence of rules for routing from one point to another, where rules[i] is used to route through the next leg_length[i] waypoints and/or endpoint.\n\n\n\n\n\n","category":"type"},{"location":"routes/#Route-drawing","page":"Routes","title":"Route drawing","text":"","category":"section"},{"location":"routes/","page":"Routes","title":"Routes","text":"Calling Path(r::Route, sty::Style) creates a new Path at p0(r), then extends it to p1(r) using route!. The default implementation of route!, for a generic RouteRule, first calls reconcile! to validate and modify waypoints as necessary. It then calls _route! to draw the path, which by default calls _route_leg! to each waypoint in order. (A \"leg\" is an informal abstraction describing the \"unit\" that the RouteRule works with, which may be more than one Paths.Segment. For example, each leg in StraightAnd90 routing has a single 90-degree bend with up to one straight segment on either side, or a single straight segment if no bend is necessary.)","category":"page"},{"location":"routes/","page":"Routes","title":"Routes","text":"    Paths.Path(::Paths.Route, ::Paths.Style)\n    Paths.route!\n    Paths.reconcile!(::Paths.Path, ::Point, ::Any, ::Paths.RouteRule, ::Any, ::Any)","category":"page"},{"location":"routes/#DeviceLayout.Paths.Path-Tuple{Route, DeviceLayout.Paths.Style}","page":"Routes","title":"DeviceLayout.Paths.Path","text":"Path(r::Route, sty)\n\nThe explicit Path defined by r, with style sty.\n\n\n\n\n\n","category":"method"},{"location":"routes/#DeviceLayout.Paths.route!","page":"Routes","title":"DeviceLayout.Paths.route!","text":"function route!(path::Path{S}, p_end::Point, α_end, rule::RouteRule, sty=Paths.contstyle1(path);\n                waypoints=Point{S}[], waydirs=Vector{typeof(1.0°)}(undef, length(waypoints)))) where {S}\n\nExtend path to p_end with arrival angle α_end according to RouteRule. The default implementation is\n\nreconcile!(path, p_end, α_end, rule, waypoints, waydirs)\n_route!(path, p_end, α_end, rule, sty, waypoints, waydirs)\n\nfollowed by checking that the endpoint was successfully reached.\n\n\n\n\n\nroute!(g::SchematicGraph, rule::RouteRule,\n    nodehook1::Pair{ComponentNode,Symbol}, nodehook2::Pair{ComponentNode,Symbol},\n    sty, meta;\n    waypoints=[], waydirs=[], global_waypoints=false,\n    name=uniquename(\"r_$(component(nodehook1.first).name)_$(component(nodehook2.first).name)\"),\n    kwargs...)\nroute!(g::SchematicGraph, rule::RouteRule, node1::ComponentNode, nodehook2::Pair{ComponentNode,Symbol}, sty, meta; kwargs...)\nroute!(g::SchematicGraph, rule::RouteRule, nodehook1::Pair{ComponentNode,Symbol}, node2::ComponentNode, sty, meta; kwargs...)\nroute!(g::SchematicGraph, rule::RouteRule, node1::ComponentNode, node2::ComponentNode, sty, meta; kwargs...)\n\nCreates a RouteComponent with given style sty and metadata meta, and fuses it between the specified nodes and hooks in g.\n\nReturns the resulting ComponentNode in g.\n\nExample usage: route!(g, BSplineRouting(), zline_node=>:feedline, z_launcher_node=>:line, Paths.CPW(10μm, 6μm), GDSMeta(1, 2))\n\nIf one or both hook symbols are not specified, then matching_hook or matching_hooks will be used to attempt to automatically find the correct hook or hooks.\n\nThe route will have start and endpoints at the origin until a method like plan! is called. waypoints and waydirs are in component-local coordinates (unless global_waypoints is true), and rule determines how they will be used.\n\nAdditional keyword arguments will become vertex properties for the RouteComponent's node.\n\nname should be unique.\n\n\n\n\n\n","category":"function"},{"location":"routes/#DeviceLayout.Paths.reconcile!-Tuple{Path, Point, Any, DeviceLayout.Paths.RouteRule, Any, Any}","page":"Routes","title":"DeviceLayout.Paths.reconcile!","text":"reconcile!(path::Path, endpoint::Point, end_direction, rule::RouteRule, waypoints, waydirs;\n    initialize_waydirs = false)\n\nEnsure that path can be routed to endpoint at end_direction using rule, waypoints, waydirs, or throw an error.\n\nDoes nothing for a generic RouteRule. Subtypes of RouteRule may implement specialized methods to do their own validation when route! is called.\n\nMay insert inferred constraints to waypoints and waydirs to allow the path to be drawn leg-by-leg. For example, reconcile! with rule::StraightAnd90, no waypoints, and α1(path) == end_direction will insert a waypoint halfway between p1(path) and endpoint, allowing two successive StraightAnd90 legs with opposite bends.\n\n\n\n\n\n","category":"method"},{"location":"routes/#Route-inspection","page":"Routes","title":"Route inspection","text":"","category":"section"},{"location":"routes/","page":"Routes","title":"Routes","text":"A Route supports endpoint inspection much like a Path does:","category":"page"},{"location":"routes/","page":"Routes","title":"Routes","text":"    Paths.p0(::Paths.Route)\n    Paths.α0(::Paths.Route)\n    Paths.p1(::Paths.Route)\n    Paths.α1(::Paths.Route)","category":"page"},{"location":"routes/#DeviceLayout.Paths.p0-Tuple{Route}","page":"Routes","title":"DeviceLayout.Paths.p0","text":"p0(s::Segment{T}) where {T}\n\nReturn the first point in a segment (calculated).\n\n\n\n\n\np0(r::Route)\n\nFirst point of a route, returns r.p0.\n\n\n\n\n\n","category":"method"},{"location":"routes/#DeviceLayout.Paths.α0-Tuple{Route}","page":"Routes","title":"DeviceLayout.Paths.α0","text":"α0(s::Segment)\n\nReturn the first angle in a segment (calculated).\n\n\n\n\n\nα0(r::Route)\n\nFirst angle of a route, returns r.α0.\n\n\n\n\n\n","category":"method"},{"location":"routes/#DeviceLayout.Paths.p1-Tuple{Route}","page":"Routes","title":"DeviceLayout.Paths.p1","text":"p1(s::Segment{T}) where {T}\n\nReturn the last point in a segment (calculated).\n\n\n\n\n\np1(r::Route)\n\nLast point of a route, returns r.p1.\n\n\n\n\n\n","category":"method"},{"location":"routes/#DeviceLayout.Paths.α1-Tuple{Route}","page":"Routes","title":"DeviceLayout.Paths.α1","text":"α1(r::Route)\n\nLast angle of a route, returns r.α1.\n\n\n\n\n\n","category":"method"},{"location":"examples/examplepdk/#ExamplePDK","page":"ExamplePDK","title":"ExamplePDK","text":"","category":"section"},{"location":"examples/examplepdk/","page":"ExamplePDK","title":"ExamplePDK","text":"ExamplePDK is a DeviceLayout.jl PDK containing layer definitions, components, and rendering targets for an example process technology.","category":"page"},{"location":"examples/examplepdk/","page":"ExamplePDK","title":"ExamplePDK","text":"warning: Warning\nExamplePDK is intended for demonstrations, tutorials, and tests. While we aim to demonstrate best practices for Julia code and DeviceLayout.jl usage, these components are not optimized for device performance. Most importantly: Breaking changes to ExamplePDK may occur within major versions. In other words, don't depend on ExamplePDK in your own PDK or for real devices!","category":"page"},{"location":"examples/examplepdk/","page":"ExamplePDK","title":"ExamplePDK","text":"info: Info\nExamplePDK is written to model best practices for developing your own PDK, with a small caveat about how the PDK is packaged. For the sake of convenient testing and tutorials, ExamplePDK is just a SchematicDrivenLayout submodule, and component modules are defined as submodules within ExamplePDK by including their source files. However, when you create your own PDK, we recommend making separate packages for each independent component, each of which has your PDK package as a dependency and uses its layer vocabulary. That way, you can add, edit, and version technologies and components independently. The files can be organized in a similar way within a single repository, but as separate packages registered to your private Julia package registry. Each subfolder in MyPDK/components/ would represent its own package (e.g., MyClawCapacitors.jl) with its own Project.toml specifying a version number, dependencies, and compatibility requirements. See the documentation on PDKs for more detail.","category":"page"},{"location":"examples/examplepdk/","page":"ExamplePDK","title":"ExamplePDK","text":"SchematicDrivenLayout.ExamplePDK.LAYER_RECORD\nSchematicDrivenLayout.ExamplePDK.LayerVocabulary\nSchematicDrivenLayout.ExamplePDK.EXAMPLE_SINGLECHIP_TECHNOLOGY\nSchematicDrivenLayout.ExamplePDK.EXAMPLE_FLIPCHIP_TECHNOLOGY\nSchematicDrivenLayout.ExamplePDK.SINGLECHIP_SOLIDMODEL_TARGET\nSchematicDrivenLayout.ExamplePDK.singlechip_solidmodel_target\nSchematicDrivenLayout.ExamplePDK.FLIPCHIP_SOLIDMODEL_TARGET\nSchematicDrivenLayout.ExamplePDK.flipchip_solidmodel_target","category":"page"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.LAYER_RECORD","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.LAYER_RECORD","text":"const LAYER_RECORD\n\nA NamedTuple mapping semantic layer name Symbols to GDS layer and datatype.\n\nProcess layers:\n\nmetal_positive   = GDSMeta(1, 1)\nmetal_negative   = GDSMeta(1, 2)\ndielectric       = GDSMeta(2, 0)\nmarker           = GDSMeta(3, 0)\njunction_pattern = GDSMeta(10, 0)\nbridge_base      = GDSMeta(20, 0)\nbridge           = GDSMeta(21, 0)\nbump             = GDSMeta(30, 0)\n\nInformational layers:\n\nchip_area      = GDSMeta(100, 0)\nwriteable_area = GDSMeta(101, 0)\nannotation     = GDSMeta(102, 0)\n\nSimulation layers:\n\nsimulated_area = GDSMeta(200, 0)\nport           = GDSMeta(210, 0)\nlumped_element = GDSMeta(211, 0)\nmesh_control   = GDSMeta(220, 0)\nintegration    = GDSMeta(230, 0)\n\nSee also ExamplePDK.LayerVocabulary\n\n\n\n\n\n","category":"constant"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.LayerVocabulary","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.LayerVocabulary","text":"module LayerVocabulary\n\nExports constants for each layer name in ExamplePDK.LAYER_RECORD.\n\nFor example, defines const METAL_NEGATIVE = SemanticMeta(:metal_negative), then exports it so that using LayerVocabulary brings METAL_NEGATIVE into the namespace.\n\n\n\n\n\n","category":"module"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.EXAMPLE_SINGLECHIP_TECHNOLOGY","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.EXAMPLE_SINGLECHIP_TECHNOLOGY","text":"const EXAMPLE_SINGLECHIP_TECHNOLOGY::ProcessTechnology\n\nA ProcessTechnology combining the ExamplePDK layer record with process parameters for single chip assembly.\n\n\n\n\n\n","category":"constant"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.EXAMPLE_FLIPCHIP_TECHNOLOGY","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.EXAMPLE_FLIPCHIP_TECHNOLOGY","text":"const EXAMPLE_FLIPCHIP_TECHNOLOGY::ProcessTechnology\n\nA ProcessTechnology combining the ExamplePDK layer record with process parameters for flipchip assembly.\n\n\n\n\n\n","category":"constant"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.SINGLECHIP_SOLIDMODEL_TARGET","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.SINGLECHIP_SOLIDMODEL_TARGET","text":"const SINGLECHIP_SOLIDMODEL_TARGET::SolidModelTarget\n\nA Target for rendering to a SolidModel using the ExamplePDK's process technology.\n\nContains rendering options and postrendering operations to create a solid model suitable for simulation of a single-chip device (as opposed to a flipchip device).\n\n\n\n\n\n","category":"constant"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.singlechip_solidmodel_target","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.singlechip_solidmodel_target","text":"singlechip_solidmodel_target(boundary_groups)\n\nHelper function for creating a SolidModelTarget for a single chip, with additional boundary groups to be retained specified by boundary_groups\n\n\n\n\n\n","category":"function"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.FLIPCHIP_SOLIDMODEL_TARGET","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.FLIPCHIP_SOLIDMODEL_TARGET","text":"const FLIPCHIP_SOLIDMODEL_TARGET::SolidModelTarget\n\nA Target for rendering to a SolidModel using the ExamplePDK's process technology.\n\nContains rendering options and postrendering operations to create a solid model suitable for simulation of a flipchip device.\n\n\n\n\n\n","category":"constant"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.flipchip_solidmodel_target","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.flipchip_solidmodel_target","text":"flipchip_solidmodel_target(boundary_groups)\n\nHelper function for creating a SolidModelTarget for a single chip, with additional boundary groups to be retained specified by boundary_groups\n\n\n\n\n\n","category":"function"},{"location":"examples/examplepdk/#ChipTemplates","page":"ExamplePDK","title":"ChipTemplates","text":"","category":"section"},{"location":"examples/examplepdk/","page":"ExamplePDK","title":"ExamplePDK","text":"SchematicDrivenLayout.ExamplePDK.ChipTemplates\nSchematicDrivenLayout.ExamplePDK.ChipTemplates.ExampleChip\nSchematicDrivenLayout.ExamplePDK.ChipTemplates.example_launcher","category":"page"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.ChipTemplates","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.ChipTemplates","text":"module ChipTemplates\n\nAn ExamplePDK component module containing simple chips and coplanar-waveguide launchers.\n\nExamplePDK is intended for demonstrations, tutorials, and tests. While we aim to demonstrate best practices for Julia code and DeviceLayout.jl usage, these components are not optimized for device performance. Most importantly: breaking changes to ExamplePDK may occur within major versions.** In other words, don't depend on ExamplePDK in your own PDK or for real devices!\n\n\n\n\n\n","category":"module"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.ChipTemplates.ExampleChip","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.ChipTemplates.ExampleChip","text":"struct ExampleChip <: Component\n\nA Component with rectangular geometry in the CHIP_AREA layer and uniformly spaced hooks.\n\nParameters\n\nname = \"chip\": Name of component\nnum_ports_lr = 12: Number of ports on the left and right edges\nnum_ports_tb = 12: Number of ports on the top and bottom edges\nlength_x = 15mm: x length of chip\nlength_y = 15mm: y length of chip\ndx = 1mm: x spacing of ports on top and bottom\ndy = 1mm: y spacing of ports on left and right\nedge_gap_lr = 0.050mm: Gap between chip edge and ports on left and right\nedge_gap_tb = 0.050mm: Gap between chip edge and ports on top and bottom\n\nHooks\n\nport_i: Uniformly spaced around the edge of the chip with in_direction towards the edge of the chip, with i beginning at 1 at the top left and increasing clockwise\n\n\n\n\n\n","category":"type"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.ChipTemplates.example_launcher","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.ChipTemplates.example_launcher","text":"example_launcher(port_spec)\n\nCreate a coplanar-waveguide \"launcher\" in METAL_NEGATIVE created using launch! with its defaults.\n\nReturns a Path named \"launcher_$role_$target\", where role and target are the first two elements of port_spec. Hooks are given by hooks(::Path).\n\nThis method exists for use in demonstrations. The launcher design is not optimized for microwave properties.\n\n\n\n\n\n","category":"function"},{"location":"examples/examplepdk/#ClawCapacitors","page":"ExamplePDK","title":"ClawCapacitors","text":"","category":"section"},{"location":"examples/examplepdk/","page":"ExamplePDK","title":"ExamplePDK","text":"SchematicDrivenLayout.ExamplePDK.ClawCapacitors\nSchematicDrivenLayout.ExamplePDK.ClawCapacitors.ExampleSeriesClawCapacitor\nSchematicDrivenLayout.ExamplePDK.ClawCapacitors.ExampleShuntClawCapacitor","category":"page"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.ClawCapacitors","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.ClawCapacitors","text":"module ClawCapacitors\n\nAn ExamplePDK component module containing claw capacitors for coupling coplanar waveguides in shunt and series configurations.\n\nExamplePDK is intended for demonstrations, tutorials, and tests. While we aim to demonstrate best practices for Julia code and DeviceLayout.jl usage, these components are not optimized for device performance. Most importantly: breaking changes to ExamplePDK may occur within major versions.** In other words, don't depend on ExamplePDK in your own PDK or for real devices!\n\n\n\n\n\n","category":"module"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.ClawCapacitors.ExampleSeriesClawCapacitor","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.ClawCapacitors.ExampleSeriesClawCapacitor","text":"ExampleSeriesClawCapacitor <: Component\n\nSeries capacitor between two coplanar lines. The input forms a claw around a pad at the output.\n\nContains hooks p0 at the input and p1 at the output, as well as left-handed versions p0_lh and p1_lh. (When left-handed hooks are fused to right-handed hooks, an extra reflection is applied when aligning the hooks—see HandedPointHook.)\n\nThis component is intended for use in demonstrations.\n\n                 claw_inner_gap\n                  ←——→   ←——→\n              ███████████████████\n              ██               ██\n              ██  ███████████  ██ ↑ claw_inner_gap\n              ██  ███████████  ██ ↓\n←input_length→██  ████ ↑ ████  ██\n████████████████  ████ | ████████                                \ninput_style       ████ inner_cap_length  ↕ output_style.trace    \n████████████████  ████ | ████████        ↕ output_style.gap        \n              ██  ████ ↓ ████  ██\n              ██  ███████████  ██  \n              ██←→███████████  ██ \n              ██claw_width↕    ██\n             ↕███████████████████\nclaw_outer_gap←→      ←—→ inner_cap_width\n\nParameters\n\nname = \"claw\": Name of component\ninput_length = 2μm: Length of input segment\ninput_style = Paths.CPW(10μm, 6μm): Style of input path\ninner_cap_width = 20μm: Width (short dimension, usually) of inner capacitor pad\ninner_cap_length = 200μm: Length (long dimension) of inner capacitor pad\nclaw_inner_gap = 5μm: Gap between claw and inner pad\nclaw_width = 10μm: Width of claw metal trace\nclaw_outer_gap = 20μm: Outer gap around claw\noutput_style = Paths.CPW(10μm, 6μm): Style of output path\nrounding = 2μm: Rounding radius applied to the capacitor\n\nHooks\n\np0: Input\np1: Output\np0_lh: Input (left-handed)\np1_lh: Output (left-handed)\n\n\n\n\n\n","category":"type"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.ClawCapacitors.ExampleShuntClawCapacitor","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.ClawCapacitors.ExampleShuntClawCapacitor","text":"ExampleShuntClawCapacitor <: Component\n\nSimilar to ExampleSeriesClawCapacitor, but the capacitor is teed off a feedline.\n\nContains hooks p0 at the feedline input and p1 at the feedline output, as well as p2 at the capacitively coupled output, as well as left-handed versions. (When left-handed hooks are fused to right-handed hooks, an extra reflection is applied when aligning the hooks—see HandedPointHook.)\n\nThis component is intended for use in demonstrations.\n\nParameters\n\nname = \"claw\": Name of component\nfeedline_length = 300μm: Total length of feedline\nfeedline_style = Paths.CPW(10μm, 6μm): Style of feedline path\ninput_length = 20μm: Length of \"input\" path between edge of feedline and claw\ninput_style = Paths.CPW(10μm, 6μm): Style of \"input\" path\ninner_cap_width = 20μm: Width (short dimension, usually) of inner capacitor pad\ninner_cap_length = 200μm: Length (long dimension) of inner capacitor pad\nclaw_inner_gap = 5μm: Gap between claw and inner pad\nclaw_width = 10μm: Width of claw metal trace\nclaw_outer_gap = 20μm: Outer gap around claw\noutput_style = Paths.CPW(10μm, 6μm): Style of output path\nrounding = 2μm: Rounding radius applied to the capacitor\nbridge = nothing: CoordinateSystem holding the air bridge geometry for the feedline and input\n\nHooks\n\np0: Feedline input\np1: Feedline output\np2: Capacitively coupled output\np0_lh: Feedline input (left-handed)\np1_lh: Feedline output (left-handed)\np2_lh: Capacitively coupled output (left-handed)\n\n\n\n\n\n","category":"type"},{"location":"examples/examplepdk/#ReadoutResonators","page":"ExamplePDK","title":"ReadoutResonators","text":"","category":"section"},{"location":"examples/examplepdk/","page":"ExamplePDK","title":"ExamplePDK","text":"SchematicDrivenLayout.ExamplePDK.ReadoutResonators\nSchematicDrivenLayout.ExamplePDK.ReadoutResonators.ExampleClawedMeanderReadout\nSchematicDrivenLayout.ExamplePDK.ReadoutResonators.ExampleTappedHairpin\nSchematicDrivenLayout.ExamplePDK.ReadoutResonators.ExampleFilteredHairpinReadout","category":"page"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.ReadoutResonators","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.ReadoutResonators","text":"module ReadoutResonators\n\nAn ExamplePDK component module containing resonators for transmon readout.\n\nExamplePDK is intended for demonstrations, tutorials, and tests. While we aim to demonstrate best practices for Julia code and DeviceLayout.jl usage, these components are not optimized for device performance. Most importantly: breaking changes to ExamplePDK may occur within major versions.** In other words, don't depend on ExamplePDK in your own PDK or for real devices!\n\n\n\n\n\n","category":"module"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.ReadoutResonators.ExampleClawedMeanderReadout","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.ReadoutResonators.ExampleClawedMeanderReadout","text":"struct ExampleClawedMeanderReadout <: Component\n\nReadout resonator consisting of a meander with short and claw-capacitor terminations.\n\nThis component is intended for use in demonstrations with ExampleRectangleTransmon.\n\nParameters\n\nname: Name of component\nstyle: Resonator CPW style\ntotal_length: Total length of resonator\ncoupling_length: Length of coupling section\ncoupling_gap: Width of ground plane between coupling section and coupled line\nbend_radius: Meander bend radius\nn_meander_turns: Number of meander turns\ntotal_height: Total height from top hook to bottom hook\nhanger_length: Length of hanger section between coupling section and meander\nw_shield: Width of claw capacitor ground plane shield\nw_claw: Claw trace width\nl_claw: Claw finger length\nclaw_gap: Claw capacitor gap\nw_grasp: Width between inner edges of ground plane shield\nbridge: CoordinateSystem containing a bridge\n\n\n\n\n\n","category":"type"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.ReadoutResonators.ExampleTappedHairpin","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.ReadoutResonators.ExampleTappedHairpin","text":"ExampleTappedHairpin <: Component\n\nA \"hairpin\" component with a tap and coupling capacitor before the bend and a meander after.\n\nThis component is intended for use in demonstrations.\n\nDiagram shows positive metal path for simplicity, but the path is drawn in the METAL_NEGATIVE layer. Hooks are marked with ⋆ and an arrow in their inward direction.\n\n                          :tap\n                           ↓\n                           ⋆\n                           ↕ tap_cap_coupling_distance\n                         █████ ↑                         ⤒\n                         █████ tap_cap_length            │\n                         █████ ↓                      tap_depth\n                          ███  ↕ tap_cap_taper_length    │\n     ←————tap_position————→█                             ↓\n:p0→⋆█████████████████████████████████                   —\n     ←————————straight_length————————→██\n    |← ...                             ██\n                                      ██\n           ███████████████████████████\n          |← ... total path length + assumed_extra_length = total_effective_length\n\nParameters\n\nNote that when this component is created within an ExampleFilteredHairpinReadout, most of these defaults are overridden.\n\nname = \"res\": Name of component\ntotal_effective_length = 4mm: Total effective length, such that the resonant frequency occurs when this length is a quarter wavelength at that frequency (assuming some effective index)\nassumed_extra_length = 1.0mm: Assumed extra effective length such that the physical path length plus assumed_extra_length is total_effective_length. For example, bends, bridges, and coupling capacitors may affect the effective length.\nr_bend = 50μm: Radius of hairpin bend\nstyle = Paths.CPW(10μm, 10μm): Path style\ninitial_snake = Point(0μm, 0μm): If nonzero, add an initial s-curve to this point (in the hairpin coordinate system, where the path starts from the origin pointing along the positive x-axis)\nstraight_length = 1.25μm: Length of first long straight section in hairpin\nbridge = nothing: CoordinateSystem holding the air bridge geometry\nParameters for tap and coupling capacitor to other resonator\ntap_position = 0.7mm: Position of tap along initial straight segment\ntap_location = -1: Side of hairpin for tap (+1 for right-hand side starting from qubit)\ntap_depth = 35μm: Distance from center of hairpin CPW to end of coupling capacitor\ntap_style = Paths.CPW(5μm, 25μm): Style of tap path\ntap_cap_taper_length = 5μm: Length of taper from tap_style to tap_cap_style\ntap_cap_length = 10μm: Length of capacitive pad after taper\ntap_cap_style = Paths.CPW(25μm, 15μm): Width and gap-width of coupling capacitor as a CPW style\ntap_cap_termination_gap = 5μm: Gap between coupling capacitor metal and ground in the direction of coupling\ntap_cap_coupling_distance = 7.5μm: Distance from end of capacitor metal to :tap hook\n\nHooks\n\np0: Start of hairpin path\ntap: Distance tap_cap_coupling_distance away from the end of the tap capacitor metal, with in_direction pointing back towards the hairpin\n\n\n\n\n\n","category":"type"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.ReadoutResonators.ExampleFilteredHairpinReadout","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.ReadoutResonators.ExampleFilteredHairpinReadout","text":"ExampleFilteredHairpinReadout <: CompositeComponent\n\nA pair of hairpin meanders to be used together with a transmon for Purcell-filtered readout.\n\nThis component is intended for use in demonstrations with ExampleStarTransmon.\n\nSubcomponents\n\nclaw, an ExampleShuntClawCapacitor\nefp (\"extra filter path\"), a Path inserted between the claw and Purcell hairpin\npurcell, an ExampleTappedHairpin used for the Purcell filter\nreadout, an ExampleTappedHairpin used for the readout resonator\n\nParameters\n\nExampleFilteredHairpinReadout mostly passes parameters directly to subcomponents.\n\nname = \"readout\": Name of component\nFeedline, tap, and claw capacitor (see ExampleShuntClawCapacitor)\nfeedline_length = 300μm\nfeedline_style = Paths.CPW(10μm, 6μm)\nfeedline_tap_length = 20μm\nfeedline_tap_style = Paths.CPW(10μm, 6μm)\nfeedline_bridge = nothing\ninner_cap_width = 20μm\ninner_cap_length = 200μm\nclaw_inner_gap = 5μm\nclaw_width = 10μm\nclaw_outer_gap = 20μm\nrounding = 2μm\nExtra claw-to-filter path\nextra_filter_l1 = 300μm: Initial straight length\nextra_filter_θ1 = 0°: Bend angle following initial straight\nextra_filter_l2 = 0μm: Straight length following first bend\nextra_filter_θ2 = 0°: Second bend following second straight\nResonators (see ExampleTappedHairpin)\nresonator_style = Paths.CPW(10μm, 10μm)\nr_bend = 50μm\nstraight_length = 1.5mm # Long straight segment\nfilter_total_effective_length = 4mm\nfilter_assumed_extra_length = 1.0mm\nreadout_total_effective_length = 4mm\nreadout_assumed_extra_length = 1.0mm\nreadout_initial_snake = Point(600μm, 200μm)\nParameters for tap and coupling capacitor between resonators\ntap_position = 0.77mm: Position of tap along initial straight segment\ntap_location = -1: Side of hairpin for tap (+1 for right-hand side starting from qubit)\nhairpin_tap_depth = 35μm: Distance from center of hairpin CPW to end of coupling capacitor\nhairpin_tap_style = Paths.CPW(5μm, 25μm): Style of hairpin tap path\ntap_cap_taper_length = 5μm: Length of taper from tap_style to tap_cap_style\ntap_cap_length = 10μm: Length of capacitive pad after taper\ntap_cap_style = Paths.CPW(25μm, 15μm): Width and gap-width of coupling capacitor as a CPW style\ntap_cap_termination_gap = 5μm: Gap between coupling capacitor metal and ground in the direction of coupling\ntap_cap_coupling_distance = 7.5μm: Distance from end of capacitor metal to :tap hook\n\nHooks\n\n- `p0`: Input of the readout feedline\n- `p1`: Output of the readout feedline    # Feedline and tap\n- `qubit`: End of the readout hairpin that connects galvanically to a capacitive pad in a qubit component\n\n\n\n\n\n","category":"type"},{"location":"examples/examplepdk/#SimpleJunctions","page":"ExamplePDK","title":"SimpleJunctions","text":"","category":"section"},{"location":"examples/examplepdk/","page":"ExamplePDK","title":"ExamplePDK","text":"SchematicDrivenLayout.ExamplePDK.SimpleJunctions\nSchematicDrivenLayout.ExamplePDK.SimpleJunctions.ExampleSimpleJunction\nSchematicDrivenLayout.ExamplePDK.SimpleJunctions.ExampleSimpleSQUID","category":"page"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.SimpleJunctions","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.SimpleJunctions","text":"module SimpleJunctions\n\nAn ExamplePDK component module containing simple placeholder Josephson junctions and SQUIDs.\n\nExamplePDK is intended for demonstrations, tutorials, and tests. While we aim to demonstrate best practices for Julia code and DeviceLayout.jl usage, these components are not optimized for device performance. Most importantly: breaking changes to ExamplePDK may occur within major versions.** In other words, don't depend on ExamplePDK in your own PDK or for real devices!\n\n\n\n\n\n","category":"module"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.SimpleJunctions.ExampleSimpleJunction","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.SimpleJunctions.ExampleSimpleJunction","text":"ExampleSimpleJunction <: Component\n\nAn example Josephson junction component with placeholder artwork.\n\nThis example component showcases that you can draw different geometry for different rendering targets. Junctions are often defined using double-angle evaporation, resulting in a physical metal pattern distinct from the geometry used for lithography. While it's possible to calculate that metal pattern based on process parameters like resist thicknesses and deposition angles, in this case, we take a shortcut and just define different rectangles for \"artwork\" and \"simulation\" which will be used or ignored based on rendering options.\n\nThe \"artwork\" geometry contains an unrealistic placeholder pattern in a single JUNCTIONPATTERN layer. The \"simulation\" geometry adds METALPOSITIVE rectangles representing junction leads, connected by a LUMPED_ELEMENT rectangle.\n\n :island hook\n    ↓    \n    ⋆           —\n    █           ↑  \n    █           │\n    █           │\n    ▒↕ h_jj     h_ground_island\n    █           │\n   →█← w_jj     │\n    █           ↓\n    ⋆           —\n    ↑    \n :ground hook\n\nParameters\n\nname = \"junction\": Name of component\nw_jj = 1μm: Width of JJ and lead\nh_jj = 1μm: Height of JJ port rectangle / gap between leads\nh_ground_island = 20μm: Total JJ ground-to-island height\nh_excess = 2μm: Additional JJ lead height overlapping each of ground and island\n\nHooks\n\nisland: Hook where the \"top\" (in JJ coordinate system) JJ lead should meet the island, inward direction pointing down\nground: Hook where the \"bottom\" JJ lead should meet ground, inward direction pointing up\n\n\n\n\n\n","category":"type"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.SimpleJunctions.ExampleSimpleSQUID","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.SimpleJunctions.ExampleSimpleSQUID","text":"ExampleSimpleSQUID <: CompositeComponent\n\nAn example SQUID consisting of two ExampleSimpleJunctions.\n\nThe \"artwork\" geometry contains an unrealistic placeholder pattern in a single JUNCTIONPATTERN layer. The \"simulation\" geometry adds METALPOSITIVE rectangles representing junction leads, connected by a LUMPED_ELEMENT rectangle.\n\n  :island hook\n     ↓    \n     ⋆                —\n█         █           ↑\n█         █           │\n█         █           │\n▒         ▒↕ h_jj     h_ground_island\n█         █           │\n█        →█← w_jj     │\n█         █           ↓\n     ⋆                —\n     ↑\n     :ground hook\n\nParameters\n\nname = \"squid\": Name of component\njj_templates = (ExampleSimpleJunction(), ExampleSimpleJunction()): Templates for left and right (in the SQUID coordinate system) JJs, respectively, used to specify parameters not overridden by the SQUID\nh_ground_island = 20μm: Total JJ ground-to-island height\nh_excess = 2μm: Additional JJ lead height overlapping each of ground and island\nw_squid: Distance between left and right JJs\n\nHooks\n\nisland: Hook at the center of the \"top\" (in SQUID coordinate system) edge of the SQUID loop meant to coincide with the edge of the island metal, inward direction pointing down\n\n\n\n\n\n","category":"type"},{"location":"examples/examplepdk/#Transmons","page":"ExamplePDK","title":"Transmons","text":"","category":"section"},{"location":"examples/examplepdk/","page":"ExamplePDK","title":"ExamplePDK","text":"SchematicDrivenLayout.ExamplePDK.Transmons\nSchematicDrivenLayout.ExamplePDK.Transmons.ExampleRectangleTransmon\nSchematicDrivenLayout.ExamplePDK.Transmons.ExampleRectangleIsland\nSchematicDrivenLayout.ExamplePDK.Transmons.ExampleStarTransmon\nSchematicDrivenLayout.ExamplePDK.Transmons.ExampleStarIsland\nSchematicDrivenLayout.ExamplePDK.Transmons.ExampleXYTermination\nSchematicDrivenLayout.ExamplePDK.Transmons.ExampleZTermination","category":"page"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.Transmons","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.Transmons","text":"module Transmons\n\nAn ExamplePDK component module containing simple transmons and associated elements like static couplers and control lines.\n\nExamplePDK is intended for demonstrations, tutorials, and tests. While we aim to demonstrate best practices for Julia code and DeviceLayout.jl usage, these components are not optimized for device performance. Most importantly: breaking changes to ExamplePDK may occur within major versions.** In other words, don't depend on ExamplePDK in your own PDK or for real devices!\n\n\n\n\n\n","category":"module"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.Transmons.ExampleRectangleTransmon","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.Transmons.ExampleRectangleTransmon","text":"struct ExampleRectangleTransmon <: CompositeComponent\nExampleRectangleTransmon(base_parameters::NamedTuple=default_parameters(ExampleRectangleTransmon);\n    kwargs...)\n\nTransmon component with a rectangular island acting as a shunt capacitor across a junction or SQUID.\n\nParameters\n\nname = \"island\": Name of component\njj_template = ExampleSimpleJunction(): Template to generate JJ or SQUID, where name and h_ground_island will be overridden\ncap_width = 24μm: The width of the rectangular island\ncap_length = 520μm: The length of the rectangular island\ncap_gap = 30μm: The gap surrounding the rectangular island, except the side with the junction/SQUID\njunction_gap = 12μm: The gap on the side of the island where the junction/SQUID will go\njunction_pos = :bottom: Location to place junction/SQUID (options :top or :bottom)\nisland_rounding = 0µm: Optional rounding radius to apply to the island; if zero, no rounding is applied to the island\n\n\n\n\n\n","category":"type"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.Transmons.ExampleRectangleIsland","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.Transmons.ExampleRectangleIsland","text":"ExampleRectangleIsland <: Component\n\nExample transmon capacitor consisting of a rectangle.\n\nThe transmon island is a rectangle with surrounding gap and optional rounding.\n\nParameters\n\nNote that when this component is created within an ExampleRectangleTransmon, these defaults are overwritten.\n\nname = \"island\": Name of component\ncap_width = 24μm: The width of the rectangular island\ncap_length = 520μm: The length of the rectangular island\ncap_gap = 30μm: The gap surrounding the rectangular island, except the side with the junction/SQUID\njunction_gap = 12μm: The gap on the side of the island where the junction/SQUID will go\njunction_pos = :bottom: Location to place junction/SQUID (options :top or :bottom)\nisland_rounding = 0µm: Optional rounding radius to apply to the island; if zero, no rounding is applied to the island\n\nHooks\n\njunction: Attachment point where junction leads meet the island\nreadout: Claw attachment point for the readout resonator, opposite the junction_pos.\nxy: Attachment point for the XY line (left side, midpoint of island)\nz: Attachment point for the Z line\n\n\n\n\n\n","category":"type"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.Transmons.ExampleStarTransmon","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.Transmons.ExampleStarTransmon","text":"ExampleStarTransmon <: CompositeComponent\n\nExample transmon component with five capacitive couplers and control lines.\n\nThe transmon island is a five-pointed star ⋆ with truncated tips. A Josephson junction subcomponent connects the top of the star (in the default orientation) to ground. Five wedge-shaped capacitive coupling pads fill the gaps between star arms. Four of them extend in the cardinal directions to half of the lattice_spacing from the island's center, while the other extends at an angle to couple to a readout resonator. XY and Z control line terminations are also included.\n\nThis component is intended for use in demonstrations.\n\nParameters\n\nname = \"transmon\": Name of component\nisland_outer_radius = 135μm: Radius of island at the tips of the star\nisland_inner_radius = [80, 80, 80, 80, 80]μm: Radii of island between the tips of stars, clockwise from 12 o'clock  (smaller radius produces a larger coupler pad at that location; index 5 is the coupler to the readout resonator)\nisland_ground_gap = 15μm: Gap between island (tips of star) and ground\nisland_coupler_gap = 15μm: Gap between island and couplers\nstar_tip_width = 50μm: Width of star tips\nrounding = 5μm: Rounding applied to ground plane geometry\njj_template = ExampleSimpleSQUID(): Template to generate JJ or SQUID, where name and h_ground_island will be overridden\nlattice_spacing = 1.65mm: Spacing between transmons (determines coupler length)\nright_handed = true: If false, is reflected when attached to right-handed transmons\ncoupler_style = Paths.CPW(10μm, 10μm): Path style for couplers\nresonator_style = Paths.CPW(10μm, 10μm): Path style for readout resonator (coupler index 5 includes a taper from coupler_style to resonator_style)\ngrounded_couplers = Int[]: List of grounded coupler indices (1 to 5, clockwise from 12 o'clock)\ncoupler_bridge = nothing: CoordinateSystem holding a bridge to place over couplers\nfeedline_style = Paths.CPW(10μm, 6μm): XY/Z control feedline style (before taper)\nxy_length = 100μm: Straight length of XY line before termination\nxy_style = Paths.CPW(3.3μm, 2μm): XY control line style after taper (near the qubit)\nxy_distance = 50μm: Distance from XY termination to ground plane edge near qubit\nz_length = 100μm: Straight length of Z line before termination\nz_style = Paths.CPW(3.3μm, 2μm): Style of the Z line after taper (near the qubit)\nz_cut_offset = 0μm: Offset of z cut relative to SQUID axis of symmetry\nz_cut_length = 16μm: Length of cut defining a return current path shared by the SQUID loop\nz_distance = 2μm: Distance from edge of ground plane cut to qubit\ncontrol_bridge = nothing: CoordinateSystem holding a bridge to place over control lines\n\nHooks\n\norigin: Center of transmon island, with inward direction pointing right\nreadout: Readout coupler\ncoupler_{N,E,S,W}: North/South/East/West (in transmon coordinate system)\nxy: End of XY line to be connected to control feedline\nz: End of Z line to be connected to control feedline\n\n\n\n\n\n","category":"type"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.Transmons.ExampleStarIsland","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.Transmons.ExampleStarIsland","text":"ExampleStarIsland <: Component\n\nExample transmon capacitor with five capacitive couplers.\n\nThe transmon island is a five-pointed star with truncated tips. Five wedge-shaped capacitive coupling pads fill the gaps between star arms.\n\nParameters\n\nNote that when this component is created within an ExampleStarTransmon, these defaults are overridden.\n\nname = \"island\": Name of component\nisland_outer_radius = 135μm: Radius of island at the tips of the star\nisland_inner_radius = [80, 80, 80, 80, 80]μm: Radii of island between the tips of stars, clockwise from 12 o'clock (smaller radius produces a larger coupler pad at that location)\nisland_ground_gap = 15μm: Gap between island (tips of star) and ground\nisland_coupler_gap = 15μm: Gap between island and couplers\nstar_tip_width = 50μm: Width of star tips\ncoupler_style = Paths.CPW(10μm, 10μm): Path style for couplers\nrounding = 5μm: Rounding applied to ground plane geometry\n\nHooks\n\ncoupler_i, for i from 1 to 5: Interface point for coupler, clockwise from 12 o'clock, inward direction pointing back towards island\njunction: Edge of star tip 1 that connects to junction or SQUID, inward direction pointing down\norigin: Center of star, with inward direction pointing right\nxy: Edge of ground plane opposite star tip 5, inward direction pointing right\nz: Edge of ground plane opposite star tip 5, inward direction pointing down\n\n\n\n\n\n","category":"type"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.Transmons.ExampleXYTermination","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.Transmons.ExampleXYTermination","text":"ExampleXYTermination\n\nComponent for terminating a coplanar waveguide with an open for driving a qubit via weak capacitive coupling.\n\nContains a taper to the desired CPW dimensions and an optional s-curve for floorplanning convenience.\n\nParameters\n\nname = \"xyterm\": Name of component\nxy_length = 100μm: Straight length of XY line before termination\nxy_style = Paths.CPW(3.3μm, 2μm): XY control line style after taper (near the qubit)\nxy_snake = Point(350μm, -100μm): If nonzero, add an s-curve to this point before the final xy_length straight section before terimation (in the component coordinate system, where the path starts with feedline_style from the origin pointing along the positive x-axis)\nxy_distance = 50μm: Distance from XY termination to ground plane edge near qubit\ntaper_length = 100μm: Length of taper from feedline_style to xy_style\nfeedline_style = Paths.CPW(10μm, 6μm): Initial style before taper towards qubit\nbridge = nothing: CoordinateSystem holding the air bridge geometry\nbridge_spacing = 100μm: Spacing of bridges on the line\nlast_bridge = 50μm: Distance from the last bridge to the end of the line\n\nHooks\n\nline: Input to be connected to a feedline\nqubit: Distance xy_distance beyond the edge of the termination, with inward direction back towards the XY line\n\n\n\n\n\n","category":"type"},{"location":"examples/examplepdk/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.Transmons.ExampleZTermination","page":"ExamplePDK","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.Transmons.ExampleZTermination","text":"ExampleZTermination <: Component\n\nComponent for terminating a coplanar waveguide with an asymmetric short, as to apply flux bias to a SQUID.\n\nContains a taper to the desired CPW dimensions and an optional bend for floorplanning convenience.\n\nThis component is intended for use in demonstrations.\n\nExample (hooks marked with ⋆ and an arrow in their inward direction):\n\n                  ██   (+z_cut_length + z_cut_offset) / 2 ⤒\n                  ██\n     z_style.gap →██←\n                  ██\n      ██████████████\n:line→⋆  z_style  ██|←z_distance→|⋆←:qubit              0 —\n      ██████████  ██\n      ←z_length→  ██\n                  ██\n                  ██   (-z_cut_length + z_cut_offset) / 2 ⤓\n\nParameters\n\nNote that when this component is created within an ExampleStarTransmon, most of these defaults are overridden.\n\nname = \"zterm\": Name of component\nz_length = 100μm: Straight length of Z line before termination\nz_style = Paths.CPW(3.3μm, 2μm): Style of the Z line near the qubit\nz_cut_offset = 0μm: Offset of z cut relative to SQUID axis of symmetry\nz_cut_length = 16μm: Length of cut defining a return current path shared by the SQUID loop\nz_distance = 2μm: Distance from edge of ground plane cut to qubit\nz_bend_angle = -45°: Angle of bend in Z line (moving towards the qubit)\nz_bend_radius = 140μm: Radius of bend in Z line\ntaper_length = 100μm: Length of taper from feedline_style to z_style\nfeedline_style = Paths.CPW(10μm, 6μm): Initial style before taper towards qubit\nbridge = nothing: CoordinateSystem holding the air bridge geometry\nbridge_spacing = 30μm: Spacing of bridges on the line\nlast_bridge = 20μm: Distance from the last bridge to the end of the line\n\nHooks\n\nline: Input to be connected to a feedline\nqubit: Distance z_distance beyond the edge of the ground plane cut, with inward direction back towards the Z line\n\n\n\n\n\n","category":"type"},{"location":"render/#Render-methods","page":"Rendering","title":"Render methods","text":"","category":"section"},{"location":"render/","page":"Rendering","title":"Rendering","text":"    render!","category":"page"},{"location":"render/#DeviceLayout.render!","page":"Rendering","title":"DeviceLayout.render!","text":"render!(c::Cell, p::Polygon, meta::GDSMeta=GDSMeta())\n\nRender a polygon p to cell c, defaulting to plain styling. If p has more than 8190 (set by DeviceLayout's GDS_POLYGON_MAX constant), then it is partitioned into smaller polygons which are then rendered. Environment variable ENV[\"GDS_POLYGON_MAX\"] will override this constant. The partitioning algorithm implements guillotine cutting, that goes through at least one existing vertex and in manhattan directions. Cuts are selected by ad hoc optimzation for \"nice\" partitions.\n\n\n\n\n\nrender!(c::CoordinateSystem, ent, meta)\n\nSynonym for place!.\n\n\n\n\n\nrender!(cell::Cell{S}, cs::GeometryStructure;\n    memoized_cells=Dict{CoordinateSystem, Cell}(),\n    map_meta = identity,\n    kwargs...) where {S}\n\nRender a geometry structure (e.g., CoordinateSystem) to a cell.\n\nPasses each element and its metadata (mapped by map_meta if a method is supplied) to render!(::Cell, element, ::Meta), traversing the references such that if a CoordinateSystem is referred to in multiple places, it will become a single cell referred to in multiple places.\n\nRendering a GeometryEntity to a Cell uses the optional keyword arguments\n\nmap_meta, a function that takes a Meta object and returns another Meta object (or nothing, in which case rendering is skipped)\n\nUsage note: calling this function with non-empty dictionary memoized_cells = Dict{CoordinateSystem, Cell}(cs => cell) is effectively a manual override that forces cs to render as cell.\n\n\n\n\n\nrender!(sm::SolidModel, cs::AbstractCoordinateSystem{T}; map_meta=layer, postrender_ops=[], zmap=(_) -> zero(T), kwargs...) where {T}\n\nRender cs to sm.\n\nKeywords\n\nmap_meta: Function (m::SemanticMeta) -> name of PhysicalGroup (as String or Symbol; may also return nothing to skip rendering m)\npostrender_ops: Vector of Tuples (destination, op, args, op_kwargs...) specifying \"postrendering\" of PhysicalGroups executed after entities have been rendered to to sm. Each operation op creates a new PhysicalGroup defined as sm[destination] = op(sm, args...; op_kwargs...). That is, args are the arguments to op (following the first argument, which is always the model sm being rendered to). For most operations, these arguments include the names and dimensions of groups being operated on, and op_kwargs are the keyword arguments passed to op. For example, (\"base\", difference_geom!, (\"writeable_area\", \"base_negative\"), :remove_object => true, :remove_tool => true) defines a postrendering step that subtracts the PhysicalGroup named \"base_negative\" from \"writeable_area\" (by default using dimension 2 for each group) to define a new group called \"base\". The keyword pairs :remove_object=>true and :remove_tool=>true mean that the \"object\" (first argument) group \"writeable_area\" and the \"tool\" (second argument) group \"base_negative\" are both removed when \"base\" is created.\nzmap: Function (m::SemanticMeta) -> z coordinate of corresponding elements. Default: Map all metadata to zero.\nmeshing_parameters: MeshingParameters allows customization of the top level meshing parameters when calling Gmsh.\n\nAvailable postrendering operations are translate!, extrude_z!, revolve!, union_geom!, intersect_geom!, difference_geom!, fragment_geom!, and box_selection. (The geometric Boolean operations are only available for models using the OpenCASCADE kernel.)\n\nAdditional keyword arguments are passed to SolidModels.to_primitives (which falls back to to_polygons) and may be used for certain entity types to control how entities of cs are converted to primitives and added to sm.\n\n\n\n\n\nrender!(cs::AbstractCoordinateSystem, obj::GeometryEntity, meta::DeviceLayout.Meta,\n    target::LayoutTarget; kwargs...)\n\nRender obj to cs, with metadata mapped to layers and rendering options by target.\n\n\n\n\n\nrender!(cs::AbstractCoordinateSystem, cs2::GeometryStructure, target::LayoutTarget; kwargs...)\n\nRender cs2 to cs, with metadata mapped to layers and rendering options by target.\n\nSee LayoutTarget documentation for details.\n\n\n\n\n\nrender!(\n    cs::AbstractCoordinateSystem,\n    sch::Schematic,\n    target::LayoutTarget;\n    strict=:error,\n    kwargs...\n)\n\nRun build!(sch, target) and render the resulting geometry to cs using target's rendering options.\n\nThe strict keyword should be :error, :warn, or :no.\n\nThe strict=:error keyword option causes render! to throw an error if any errors were logged while building component geometries or while rendering geometries to cs. This is enabled by default, but can be disabled with strict=:no, in which case any component which was not successfully built will have an empty geometry, and any non-fatal rendering errors will be ignored as usual. Using strict=:no is recommended only for debugging purposes.\n\nThe strict=:warn keyword option causes render! to throw an error if any warnings were logged. This is disabled by default. Using strict=:warn is suggested for use in automated pipelines, where warnings may require human review.\n\n\n\n\n\nrender!(sm::SolidModel, sch::Schematic, target::Target; strict=:error, kwargs...)\n\nRender sch to sm, using rendering settings from target.\n\nThe strict keyword should be :error, :warn, or :no.\n\nThe strict=:error keyword option causes render! to throw an error if any errors were logged while building component geometries or while rendering geometries to cs. This is enabled by default, but can be disabled with strict=:no, in which case any component which was not successfully built will have an empty geometry, and any non-fatal rendering errors will be ignored as usual. Using strict=:no is recommended only for debugging purposes.\n\nThe strict=:warn keyword option causes render! to throw an error if any warnings were logged. This is disabled by default. Using strict=:warn is suggested for use in automated pipelines, where warnings may require human review.\n\nAdditional keyword arguments may be used for certain entity types for controlling how geometry entities are converted to primitives and added to sm.\n\n\n\n\n\n","category":"function"},{"location":"render/#Rendering-arbitrary-paths","page":"Rendering","title":"Rendering arbitrary paths","text":"","category":"section"},{"location":"render/","page":"Rendering","title":"Rendering","text":"A Segment and Style together define one or more closed curves in the plane. The job of rendering is to approximate these curves by closed polygons. To enable rendering of styles along generic paths in the plane, an adaptive algorithm is used when no other method is available:","category":"page"},{"location":"render/","page":"Rendering","title":"Rendering","text":"    DeviceLayout.adapted_grid","category":"page"},{"location":"render/#DeviceLayout.adapted_grid","page":"Rendering","title":"DeviceLayout.adapted_grid","text":"adapted_grid(f, anchors;\n    max_recursions::Real = 7, max_change = 5°, rand_factor::Real = 0.05,\n    grid_step = 1.0μm)\n\nComputes a resampled grid given anchor points so that f.(grid) is sufficiently smooth. The method used is to create an initial grid around the anchor points and refine intervals. When an interval becomes \"straight enough\" it is no longer divided. Adapted from a contribution to PlotUtils.jl from Kristoffer Carlsson.\n\nmax_recursions: how many times each interval is allowed to be refined.\nmax_change: specifies acceptable change between evaluations of f on subsequent grid points, as estimated by the derivative times the distance between grid points. Typically, f is the angle of a path in the plane, so this is often an angle threshold. This condition is approximately valid in the end result, but may be weakly violated. This condition may be grossly violated if max_recursions is too low.\nrand_factor: between anchor points, adapted_grid will wiggle initial grid points a bit to prevent aliasing. The wiggling is sampled uniformly from the interval: [-rand_factor, rand_factor], times the distance between three grid points (e.g. i+1 and i-1). A random number generator is given a fixed seed every time adapted_grid is called, so the rendered results are deterministic.\ngrid_step: Step size for initial grid points. If you set this to be larger than the maximum anchor point, then the lowest resolution consistent with max_change is used (unless f has some fast variations that the algorithm might miss).\n\n\n\n\n\n","category":"function"},{"location":"render/","page":"Rendering","title":"Rendering","text":"In some cases, custom rendering methods are implemented when it would improve performance for simple structures or when special attention is required. The rendering methods can specialize on either the Segment or Style types, or both.","category":"page"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"DocTestSetup = quote\n    using Unitful, DeviceLayout\n    using Unitful: °\nend","category":"page"},{"location":"shapes/#Shape-library","page":"Shape library","title":"Shape library","text":"","category":"section"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"Examples on this page assume you have done using DeviceLayout, DeviceLayout.PreferredUnits, FileIO.","category":"page"},{"location":"shapes/#Simple-shapes","page":"Shape library","title":"Simple shapes","text":"","category":"section"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"A library of simple shapes is available from the SimpleShapes module. All of these functions are exported by the top-level DeviceLayout module and are directly accessible to the user.","category":"page"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"    circular_arc\n    draw_pixels\n    hatching_unit\n    radial_cut\n    radial_stub\n    simple_cross\n    simple_ell\n    simple_tee","category":"page"},{"location":"shapes/#DeviceLayout.SimpleShapes.circular_arc","page":"Shape library","title":"DeviceLayout.SimpleShapes.circular_arc","text":"circular_arc(θ, r::T, tolerance; θ_0=0, center=zero(Point{T})) where\n            {T <: Coordinate}\n\nDiscretizes a circular arc to meet a tolerance, ignoring rounding to a grid.\n\nθ is the angular position of the end of the arc and r is its radius. The maximum distance between any segment and the actual circle will be roughly equal to the tolerance (for small tolerance). Returns an array of Points. Includes both endpoints.\n\nIf θ > θ_0, the arc is drawn counterclockwise.\n\n\n\n\n\ncircular_arc(θ::Vector, r::T, tolerance; center=zero(Point{T})) where {T <: Coordinate}\n\nDiscretizes a circular arc of radius r from θ[1] to θ[2], choosing the shorter direction (defaults to counterclockwise for a semicircle). r is its radius. The maximum distance between any segment and the actual circle will be roughly equal to the tolerance (for small tolerance). Returns an array of Points, including both endpoints.\n\n\n\n\n\n","category":"function"},{"location":"shapes/#DeviceLayout.SimpleShapes.draw_pixels","page":"Shape library","title":"DeviceLayout.SimpleShapes.draw_pixels","text":"draw_pixels(pixpattern::AbstractMatrix{Int}, pixsize)\n\nGiven a matrix pixpattern, make a bitmap of Rectangle where the presence of a pixel corresponds to a positive value in the matrix. Returns an array of polygons.\n\n\n\n\n\n","category":"function"},{"location":"shapes/#DeviceLayout.SimpleShapes.hatching_unit","page":"Shape library","title":"DeviceLayout.SimpleShapes.hatching_unit","text":"hatching_unit(w1, w2, pixsize=DEFAULT_HATCHING_PIXSIZE)\n\n\n\n\n\n","category":"function"},{"location":"shapes/#DeviceLayout.SimpleShapes.radial_cut","page":"Shape library","title":"DeviceLayout.SimpleShapes.radial_cut","text":"radial_cut(r, Θ, h; narc::Int=197)\n\nRenders a polygon representing a radial cut (like a radial stub with no metal). The polygon has to be subtracted from a ground plane.\n\nThe parameter h is made available in the method signature rather than a because the focus of the arc (top of polygon) can easily centered in a waveguide. If it is desirable to control a instead, use trig: a/2 = h*tan(Θ/2).\n\nParameters as follows, where X marks the origin and (nothing above the origin is part of the resulting polygon):\n\n                       Λ\n                      /│\\\n                     / │ \\\n                    /  |  \\\n              .    /   │Θ/2\\\n             .    /    │----\\\n            /    /   h │     \\\n           /    /      │      \\\n          /    /       │       \\\n         r    /        │        \\\n        /    /         │         \\\n       /    /----------X----------\\\n      /    /{--------- a ---------}\\\n     .    /                         \\\n    .    /                           \\\n        /                             \\\n       /                               \\\n      /                                 \\\n      --┐                             ┌--\n        └--┐                       ┌--┘\n           └--┐                 ┌--┘\n              └--┐           ┌--┘\n                 └-----------┘\n                 (circular arc)\n\n\n\n\n\n","category":"function"},{"location":"shapes/#DeviceLayout.SimpleShapes.radial_stub","page":"Shape library","title":"DeviceLayout.SimpleShapes.radial_stub","text":"radial_stub(r, Θ, h, t; narc::Int=197)\n\nSee also the documentation for radial_cut.\n\nReturn a polygon for a radial stub. The polygon has to be subtracted from a ground plane, and will leave a defect in the ground plane of uniform width t that outlines the (metallic) radial stub. r refers to the radius of the actual stub, not the radius of the circular arc bounding the ground plane defect. Likewise h has an analogous meaning to that in radial_cut except it refers here to the radial stub, not the ground plane defect.\n\n\n\n\n\n","category":"function"},{"location":"shapes/#DeviceLayout.SimpleShapes.simple_cross","page":"Shape library","title":"DeviceLayout.SimpleShapes.simple_cross","text":"simple_cross(lv_x, lv_y; lh_x=lv_y, lh_y=lv_x)\n\nA simple cross centered at the origin. The only required inputs are lv_x and lv_y, the length of the vertical strip along the x and y directions, respectively. The corresponding dimensions of the horizontal strip are given as keyword arguments, with the defaults producing identical horizontal and vertical strips.\n\n_ |<--------- lh_x ----------->|\n|            |▓▓▓▓|\n|            |▓▓▓▓|\nlv_y         |▓▓▓▓|\n|            |<  >| lv_x\n|            |▓▓▓▓|\n| |▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓| lh_y\n| |▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓|\n|            |▓▓▓▓|\n|            |▓▓▓▓|\n|            |▓▓▓▓|\n|            |▓▓▓▓|\n_            |▓▓▓▓|\n\n\n\n\n\n","category":"function"},{"location":"shapes/#DeviceLayout.SimpleShapes.simple_ell","page":"Shape library","title":"DeviceLayout.SimpleShapes.simple_ell","text":"simple_ell(w1, h1; w2=h1, h2=w1)\n\nReturn an L-shaped polygon with its bottom left corner at the origin.\n\nNote that the parameters describe the L as two overlapping rectangles. The result is identical if you switch \"rectangle 1\" and \"rectangle 2\". By default, the rectangles have the same \"stroke width\" and length.\n\n_           |<------w2------->|\n|           |▓▓▓▓|\n|           |▓▓▓▓|\nh1          |▓▓▓▓|\n|           |<w1>|\n|           |▓▓▓▓|\nv           |▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓| h2\n            ^ (x,y) = (0,0) at the lower-left corner of the L.\n\n\n\n\n\n","category":"function"},{"location":"shapes/#DeviceLayout.SimpleShapes.simple_tee","page":"Shape library","title":"DeviceLayout.SimpleShapes.simple_tee","text":"simple_tee(w1, h1; w2=h1, h2=w1)\n\nParameters are named in typical handwritten stroke order (like cross, vertical stem first). Note that h1 is the full height of the T.\n\n_    _______w2________\n|   |▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓| h2\n|          |▓▓▓▓|\nh1         |▓▓▓▓|\n|          |<w1>|\nv          |▓▓▓▓|\n             ^ (x,y) = (0,0) at center of baseline of T.\n\n\n\n\n\n","category":"function"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"Example:","category":"page"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"using DeviceLayout, DeviceLayout.PreferredUnits, FileIO # hide\nc = Cell(\"main\", nm)\np = radial_cut(20μm, π / 2, 5μm)\nrender!(c, p, GDSMeta(1))\nsave(\"radial_cut.svg\", flatten(c));\nnothing; # hide","category":"page"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"<img src=\"../radial_cut.svg\" style=\"width:2in;\"/>","category":"page"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"Example:","category":"page"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"using DeviceLayout, DeviceLayout.PreferredUnits, FileIO # hide\nc = Cell(\"main\", nm)\np = radial_stub(20μm, π / 2, 5μm, 1μm)\nrender!(c, p, GDSMeta(1))\nsave(\"radial_stub.svg\", flatten(c));\nnothing; # hide","category":"page"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"<img src=\"../radial_stub.svg\" style=\"width:2in;\"/>","category":"page"},{"location":"shapes/#Compound-shapes","page":"Shape library","title":"Compound shapes","text":"","category":"section"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"We also provide methods for a few \"compound shapes\" that render multiple entities to a coordinate system rather than return a single entity.","category":"page"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"    checkerboard!","category":"page"},{"location":"shapes/#DeviceLayout.SimpleShapes.checkerboard!","page":"Shape library","title":"DeviceLayout.SimpleShapes.checkerboard!","text":"checkerboard!(c::Cell{T,S}, pixsize, rows::Integer, alt, meta::Meta=GDSMeta()) where {T,S}\n\nIn cell c, generate a checkerboard pattern suitable for contrast curve measurement, or getting the base dose for PEC.\n\npixsize: length of one side of a square\nrows: number of rows == number of columns\nalt: the square nearest Point(zero(T), zero(T)) is filled (unfilled) if false (true). Use this to create a full tiling of the checkerboard, if you wish.\n\n\n\n\n\n","category":"function"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"Example:","category":"page"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"using DeviceLayout, DeviceLayout.PreferredUnits, FileIO # hide\nc = Cell(\"main\", nm)\ncheckerboard!(c, 20μm, 10, false, GDSMeta(2))\ncheckerboard!(c, 20μm, 10, true, GDSMeta(3))\nsave(\"checkers.svg\", flatten(c));\nnothing; # hide","category":"page"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"<img src=\"../checkers.svg\" style=\"width:2in;\"/>","category":"page"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"    grating!","category":"page"},{"location":"shapes/#DeviceLayout.SimpleShapes.grating!","page":"Shape library","title":"DeviceLayout.SimpleShapes.grating!","text":"grating!(c::Cell{T,S}, line, space, size, meta::Meta=GDSMeta()) where {T,S}\n\nGenerate a square grating suitable e.g. for obtaining the base dose for PEC.\n\n\n\n\n\n","category":"function"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"Example:","category":"page"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"using DeviceLayout, DeviceLayout.PreferredUnits, FileIO # hide\nc = Cell(\"main\", nm)\ngrating!(c, 100nm, 100nm, 5μm, GDSMeta(3))\nsave(\"grating.svg\", flatten(c));\nnothing; # hide","category":"page"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"<img src=\"../grating.svg\" style=\"width:2in;\"/>","category":"page"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"    interdigit!","category":"page"},{"location":"shapes/#DeviceLayout.SimpleShapes.interdigit!","page":"Shape library","title":"DeviceLayout.SimpleShapes.interdigit!","text":"interdigit!(c::AbstractCoordinateSystem{T}, width, length, fingergap, fingeroffset, npairs::Integer,\n    skiplast, meta::Meta=GDSMeta(0,0)) where {T}\n\nCreates interdigitated fingers, e.g. for a lumped element capacitor.\n\nwidth: finger width\nlength: finger length\nfingeroffset: x-offset at ends of fingers\nfingergap: gap between fingers\nnpairs: number of fingers\nskiplast: should we skip the last finger, leaving an odd number?\n\n\n\n\n\n","category":"function"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"Simple usage for interdigit!:","category":"page"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"using DeviceLayout, DeviceLayout.PreferredUnits, FileIO # hide\nfingers = Cell(\"fingers\", nm)\nwide, length, fingergap, fingeroffset, npairs, skiplast = 1μm, 20μm, 1μm, 3μm, 5, true\ninterdigit!(fingers, wide, length, fingergap, fingeroffset, npairs, skiplast, GDSMeta(5))\nsave(\"fingers_only.svg\", flatten(fingers));\nnothing; # hide","category":"page"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"<img src=\"../fingers_only.svg\" style=\"width:2in;\"/>","category":"page"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"Example of how to make an interdigitated capacitor inline with a feedline:","category":"page"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"using DeviceLayout, DeviceLayout.PreferredUnits, FileIO # hide\nc = Cell(\"main\", nm)\np = Path(μm)\ntrace, gap = 17μm, 3μm\nstraight!(p, 50μm, Paths.CPW(trace, gap))\nstraight!(p, 23μm, Paths.NoRender())\nstraight!(p, 50μm, Paths.CPW(trace, gap))\nfingers = Cell(\"fingers\", nm)\nwide, length, fingergap, fingeroffset, npairs, skiplast = 1μm, 20μm, 1μm, 3μm, 5, true\ninterdigit!(fingers, wide, length, fingergap, fingeroffset, npairs, skiplast, GDSMeta(5))\nfinger_mask =\n    Rectangle(width(bounds(fingers)), height(bounds(fingers)) + 2 * gap) - Point(0μm, gap)\ninverse_fingers = Cell(\"invfingers\", nm)\nplgs = difference2d(finger_mask, elements(fingers))\nrender!(inverse_fingers, plgs, GDSMeta(0))\nattach!(\n    p,\n    CellReference(inverse_fingers, Point(0μm, -upperright(bounds(fingers)).y / 2)),\n    0μm,\n    i=2\n)\nrender!(c, p, GDSMeta(0))\nsave(\"fingers.svg\", flatten(c));\nnothing; # hide","category":"page"},{"location":"shapes/","page":"Shape library","title":"Shape library","text":"<img src=\"../fingers.svg\" style=\"width:4in;\"/>","category":"page"},{"location":"faq/#Paths","page":"Troubleshooting/FAQ","title":"Paths","text":"","category":"section"},{"location":"faq/#I-want-to-apply-a-taper-or-attach-bridges-along-an-entire-path.-Can-I-do-this-without-having-to-worry-about-each-individual-segment-in-the-path?","page":"Troubleshooting/FAQ","title":"I want to apply a taper or attach bridges along an entire path. Can I do this without having to worry about each individual segment in the path?","text":"","category":"section"},{"location":"faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"You can use the simplify! function to combine some range of segments into a single compound segment with a single style.","category":"page"},{"location":"faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"A caveat: Decorated styles should not become part of compound styles, for now. Avoid this by decorating / attaching references at the end.","category":"page"},{"location":"faq/#GDS-output","page":"Troubleshooting/FAQ","title":"GDS output","text":"","category":"section"},{"location":"faq/#I-can't-save-my-GDS-file.","page":"Troubleshooting/FAQ","title":"I can't save my GDS file.","text":"","category":"section"},{"location":"faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"Try deleting any file that happens to be at the target path. A corrupted file at the target path may prevent saving.","category":"page"},{"location":"faq/#When-I-refresh-KLayout-after-saving-changes-to-a-file,-everything-disappears.-Where-did-it-go?","page":"Troubleshooting/FAQ","title":"When I refresh KLayout after saving changes to a file, everything disappears. Where did it go?","text":"","category":"section"},{"location":"faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"The most likely answer is that the name of the top-level cell changed. To show the new geometry, right click on the cell name in the upper left panel and choose \"Show As New Top\". To avoid this in the future, make sure your top-level cell has a fixed name, rather than something generated by uniquename. For example, if you are saving the result of a flatten operation, you can use the name keyword argument in flatten.","category":"page"},{"location":"faq/#When-I-look-at-my-final-GDS-file,-there-are-1nm-gaps-between-edges-that-should-coincide.-Why-is-this-happening,-and-can-it-be-avoided?","page":"Troubleshooting/FAQ","title":"When I look at my final GDS file, there are ~1nm gaps between edges that should coincide. Why is this happening, and can it be avoided?","text":"","category":"section"},{"location":"faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"This can happen for at least two reasons, both of which are related to the use of integer coordinates in a database unit (typically 1nm) by the GDSII format.","category":"page"},{"location":"faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"Gaps between elements in the same Cell can occur if you have two line segments that are meant to be collinear but have different endpoints. The four endpoints will be rounded to four points on the integer grid, and these four points will not necessarily be collinear. One solution here is to insert a point in either line segment where any endpoint of the other falls. This is how an open CPW termination created by Paths.terminate! is drawn (when not using rounding), instead of just placing a four-point rectangle at the end of the CPW.\nGaps between elements in different Cells can occur if you're using CellReferences (corresponding to SREF in the GDSII format described here), since coordinates within each cell as well as the origins of cell references are rounded to integers on saving. This occurs particularly often when rotating references by angles other than multiples of 90 degrees. One solution is to flatten cells before saving, since DeviceLayout's internal representation of Cells uses 64-bit floating point precision.","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"DocTestSetup = quote\n    using Unitful, DeviceLayout\n    using Unitful: °\nend","category":"page"},{"location":"transformations/#Coordinate-Transformations","page":"Transformations","title":"Coordinate Transformations","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"The mechanism for affine transformations is largely provided by the CoordinateTransformations.jl package. For convenience, the documentation for Translation and compose is reproduced below from that package. We also provide convenience constructors for Reflection across a specified line and Rotation around a specified point, as well as a ScaledIsometry type that represents transformations restricted to those that preserve angles.","category":"page"},{"location":"transformations/#Creating-transformations","page":"Transformations","title":"Creating transformations","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"    CoordinateTransformations.compose\n    CoordinateTransformations.Translation\n    Reflection\n    XReflection\n    YReflection\n    Rotation\n    RotationPi\n    ScaledIsometry","category":"page"},{"location":"transformations/#CoordinateTransformations.compose","page":"Transformations","title":"CoordinateTransformations.compose","text":"compose(trans1, trans2)\ntrans1 ∘ trans2\n\nTake two transformations and create a new transformation that is equivalent to successively applying trans2 to the coordinate, and then trans1. By default will create a ComposedTransformation, however this method can be overloaded for efficiency (e.g. two affine transformations naturally compose to a single affine transformation).\n\n\n\n\n\n","category":"function"},{"location":"transformations/#CoordinateTransformations.Translation","page":"Transformations","title":"CoordinateTransformations.Translation","text":"Translation(v) <: AbstractAffineMap\nTranslation(dx, dy)         # 2D\nTranslation(dx, dy, dz)     # 3D\n\nConstruct the Translation transformation for translating Cartesian points by an offset v = (dx, dy, ...)\n\n\n\n\n\n","category":"type"},{"location":"transformations/#DeviceLayout.Transformations.Reflection","page":"Transformations","title":"DeviceLayout.Transformations.Reflection","text":"Reflection(α; through_pt=nothing)\nReflection(vec::Point; through_pt=nothing)\nReflection(p1::Point, p2::Point)\n\nConstruct a reflection across a line.\n\nThe line can be specified by two points p1, p2 or by a direction and point through_pt the line passes through. The direction can be a vector or an angle made with the positive x axis (units accepted; no units => radians), and the through_pt is the origin by default.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.Transformations.XReflection","page":"Transformations","title":"DeviceLayout.Transformations.XReflection","text":"XReflection()\n\nConstruct a reflection about the x-axis (y-coordinate changes sign).\n\nExample:\n\njulia> trans = XReflection()\nLinearMap([1 0; 0 -1])\n\njulia> trans(Point(1, 1))\n2-element Point{Int64} with indices SOneTo(2):\n  1\n -1\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.Transformations.YReflection","page":"Transformations","title":"DeviceLayout.Transformations.YReflection","text":"YReflection()\n\nConstruct a reflection about the y-axis (x-coordinate changes sign).\n\nExample:\n\njulia> trans = YReflection()\nLinearMap([-1 0; 0 1])\n\njulia> trans(Point(1, 1))\n2-element Point{Int64} with indices SOneTo(2):\n -1\n  1\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.Transformations.Rotation","page":"Transformations","title":"DeviceLayout.Transformations.Rotation","text":"Rotation(Θ; around_pt=nothing)\n\nConstruct a rotation about the origin or around_pt. Units accepted (no units ⇒ radians).\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.Transformations.RotationPi","page":"Transformations","title":"DeviceLayout.Transformations.RotationPi","text":"RotationPi(Θ_over_pi=1; around_pt=nothing)\n\nConstruct a rotation about the origin or around_pt, with rotation in units of pi (180°).\n\nThis may be useful if you know your rotation will be a multiple of 90° but not necessarily which one, since it can be slightly more precise than Rotation (as sincospi is to sincos).\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.Transformations.ScaledIsometry","page":"Transformations","title":"DeviceLayout.Transformations.ScaledIsometry","text":"struct ScaledIsometry{T<:Union{Point, Nothing}} <: AbstractAffineMap\nScaledIsometry(origin=nothing, rotation=0°, xrefl=false, mag=1.0)\n\nA coordinate transformation that preserves angles.\n\nThe equivalent transformation of f::ScaledIsometry is the composition of the following transformations, ordered with reflection applied first:\n\nIf xrefl(f) is true, a reflection across the x-axis\nRotation by rotation(f)\nMagnification by mag(f)\nTranslation by origin(f)\n\nMay be also be constructed as\n\nScaledIsometry(f::Transformation) = ScaledIsometry(origin(f), rotation(f), xrefl(f), mag(f))\n\nbut a DomainError will be thrown if f is not a scaled isometry (does not preserve angles).\n\nTransformation compositions (with compose or ∘) involving a ScaledIsometry will return a ScaledIsometry if the other transformation also preserves angles.\n\n\n\n\n\n","category":"type"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"Transformations can also be inverted with inv.","category":"page"},{"location":"transformations/#Applying-transformations","page":"Transformations","title":"Applying transformations","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"Coordinate transformations can be applied to any AbstractGeometry object, creating a new object with its coordinates transformed. Transformations created using the constructors in the above section can be applied directly to objects like a function. Here's an example with a Rectangle:","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"julia> r = Rectangle(2, 1)\nRectangle{Int64}((0,0), (2,1))\n\njulia> trans = Translation(10, 10)\nTranslation(10, 10)\n\njulia> trans = Rotation(90°) ∘ trans\nAffineMap([0.0 -1.0; 1.0 0.0], [-10.0, 10.0])\n\njulia> trans(r)\nRectangle{Float64}((-11.0,10.0), (-10.0,12.0))","category":"page"},{"location":"transformations/#Simple-transformations","page":"Transformations","title":"Simple transformations","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"There are methods for conveniently applying simple transformations:","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"    centered\n    magnify\n    reflect_across_line\n    reflect_across_xaxis\n    rotate\n    rotate90\n    translate\n    +(::DeviceLayout.AbstractGeometry, ::Point)\n    -(::DeviceLayout.AbstractGeometry, ::Point)\n    *(::DeviceLayout.AbstractGeometry, a::Real)\n    /(::DeviceLayout.AbstractGeometry, a::Real)","category":"page"},{"location":"transformations/#DeviceLayout.centered","page":"Transformations","title":"DeviceLayout.centered","text":"centered(ent::AbstractGeometry; on_pt=zero(Point{T}))\n\nCenters a copy of ent on on_pt, with promoted coordinates if necessary. This function will not throw an InexactError(), even if ent had integer coordinates.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.magnify","page":"Transformations","title":"DeviceLayout.magnify","text":"magnify(geom, mag)\n\nReturns a copy of geom magnified by a factor of mag.\n\nThe origin is the center of magnification.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.reflect_across_line","page":"Transformations","title":"DeviceLayout.reflect_across_line","text":"reflect_across_line(geom, dir; through_pt=nothing)\nreflect_across_line(geom, p0, p1)\n\nReturn a copy of geom reflected across a line.\n\nThe line is specified through two points p0 and p1 that it passes through, or by a direction dir (vector or angle made with the x-axis) and a point through_pt that it passes through.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.reflect_across_xaxis","page":"Transformations","title":"DeviceLayout.reflect_across_xaxis","text":"reflect_across_xaxis(geom)\n\nReturn a copy of geom reflected across the x-axis.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.rotate","page":"Transformations","title":"DeviceLayout.rotate","text":"rotate(ent, rot)\n\nReturn a copy of geom rotated counterclockwise by rot around the origin.\n\nUnits are accepted (no units => radians).\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.rotate90","page":"Transformations","title":"DeviceLayout.rotate90","text":"rotate90(geom, n)\n\nReturn a copy of geom rotated counterclockwise by n 90° turns.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.translate","page":"Transformations","title":"DeviceLayout.translate","text":"translate(geom, displacement)\n\nReturn a copy of geom translated by displacement.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#Base.:+-Tuple{DeviceLayout.AbstractGeometry, Point}","page":"Transformations","title":"Base.:+","text":"+(ent::AbstractGeometry, p::Point)\n+(p::Point, ent::AbstractGeometry)\n\nTranslate an entity by p.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#Base.:--Tuple{DeviceLayout.AbstractGeometry, Point}","page":"Transformations","title":"Base.:-","text":"-(ent::AbstractGeometry, p::Point)\n\nTranslate an entity by -p.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#Base.:*-Tuple{DeviceLayout.AbstractGeometry, Real}","page":"Transformations","title":"Base.:*","text":"*(ent::AbstractGeometry, a::Real)\n*(a::Real, ent::AbstractGeometry)\n\nMagnify an entity by a.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#Base.:/-Tuple{DeviceLayout.AbstractGeometry, Real}","page":"Transformations","title":"Base.:/","text":"/(ent::AbstractGeometry, a::Real)\n\nMagnify an entity by inv(a).\n\n\n\n\n\n","category":"method"},{"location":"transformations/#Alignment","page":"Transformations","title":"Alignment","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"There are also methods to apply transformations that align objects using the edges of their bounding boxes.","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"    Align.above\n    Align.below\n    Align.leftof\n    Align.rightof\n    Align.flushbottom\n    Align.flushtop\n    Align.flushleft\n    Align.flushright\n    Align.centered_on\n    Align.aligned_to","category":"page"},{"location":"transformations/#DeviceLayout.Align.above","page":"Transformations","title":"DeviceLayout.Align.above","text":"above(source, target; offset=0, centered=false)\n\nAlign a copy of source with its bounding box bottom aligned with the top of target's.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.Align.below","page":"Transformations","title":"DeviceLayout.Align.below","text":"below(source, target; offset=0, centered=false)\n\nAlign a copy of source with its bounding box top aligned with the bottom of target's.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.Align.leftof","page":"Transformations","title":"DeviceLayout.Align.leftof","text":"leftof(source, target; offset=0, centered=false)\n\nAlign a copy of source with its bounding box right side aligned on the left of target's.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.Align.rightof","page":"Transformations","title":"DeviceLayout.Align.rightof","text":"rightof(source, target; offset=0, centered=false)\n\nAlign a copy of source with its bounding box left side aligned on the right of target's.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.Align.flushbottom","page":"Transformations","title":"DeviceLayout.Align.flushbottom","text":"flushbottom(source, target; offset=0, centered=false)\n\nAlign a copy of source with its bounding box bottom flush with that of target.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.Align.flushtop","page":"Transformations","title":"DeviceLayout.Align.flushtop","text":"flushtop(source, target; offset=0, centered=false)\n\nAlign a copy of source with its bounding box top flush with that of target.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.Align.flushleft","page":"Transformations","title":"DeviceLayout.Align.flushleft","text":"flushleft(source, target; offset=0, centered=false)\n\nAlign a copy of source with its bounding box left side flush with that of target.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.Align.flushright","page":"Transformations","title":"DeviceLayout.Align.flushright","text":"flushright(source, target; offset=0, centered=false)\n\nAlign a copy of source with its bounding box right side flush with that of target.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.Align.centered_on","page":"Transformations","title":"DeviceLayout.Align.centered_on","text":"centered_on(source::AbstractGeometry, target::AbstractGeometry)\n\nCenters a copy of source centered on the center of target, promoting coordinates if necessary.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.Align.aligned_to","page":"Transformations","title":"DeviceLayout.Align.aligned_to","text":"aligned_to(source::AbstractGeometry{T}, target::AbstractGeometry{S},\n           align_source::RectAlignRule, align_target::RectAlignRule;\n           offset=convert(S, zero(T))) where {T,S}\n\nAligns a copy of source with its align_source aligned to align_target of target.\n\nFor alignment in only one coordinate, the other coordinate is left unchanged. An optional offset will further displace the result in the aligned coordinate. Coordinates will be promoted if necessary when centering.\n\nalign_source and align_target must match coordinates; that is, both must refer to the x coordinate (Align.LeftEdge, Align.RightEdge, or Align.XCenter) or both to the y coordinate (Align.TopEdge, Align.BottomEdge, or Align.YCenter).\n\nConvenience functions (leftof, rightof, above, below, flushleft, flushright, flushtop, flushbottom) are also defined as wrappers around aligned_to with pre-specified AlignRules.\n\nExamples\n\njulia> Align.aligned_to(Rectangle(2, 2), Rectangle(4, 4), Align.LeftEdge(), Align.XCenter())\nRectangle{Float64}((2.0,0.0), (4.0,2.0))\n\n\n\n\n\naligned_to(source::AbstractGeometry{T}, target::AbstractGeometry{S},\n    align_source::Tuple{XAlignRule, YAlignRule},\n    align_target::Tuple{XAlignRule, YAlignRule};\n    offset::Point = zero(Point{promote_type(S, T)})) where {T,S}\n\nAlign a copy of source to target in x and y coordinates simultaneously.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#Inspecting-transformations","page":"Transformations","title":"Inspecting transformations","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"    isapprox_angle\n    isapprox_cardinal\n    mag\n    origin\n    preserves_angles\n    rotated_direction\n    rotation\n    DeviceLayout.Transformations.rounding_safe\n    xrefl","category":"page"},{"location":"transformations/#DeviceLayout.Transformations.isapprox_angle","page":"Transformations","title":"DeviceLayout.Transformations.isapprox_angle","text":"isapprox_angle(α1, α2; atol=1e-9)\n\nTest whether angles α1 and α2 are approximately equivalent.\n\nUnits may be used for one or both angles (no units => radians).\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.Transformations.isapprox_cardinal","page":"Transformations","title":"DeviceLayout.Transformations.isapprox_cardinal","text":"isapprox_cardinal(α; atol=1e-9)\n\nTest whether α is approximately a cardinal direction (0°, 90°, 180°, or 270°).\n\nUnits may be used. If α has no units, it is treated as an angle in radians.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.Transformations.mag","page":"Transformations","title":"DeviceLayout.Transformations.mag","text":"mag(f::Translation)\n\nReturn the magnification (uniform scaling factor) for f, if it is well defined.\n\nThrows a DomainError if f does not preserve angles (\"scaling\" depends on direction).\n\n\n\n\n\nmag(ref::GeometryReference)\n\nThe magnification (uniform scaling factor) applied by transformation(ref).\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.Transformations.origin","page":"Transformations","title":"DeviceLayout.Transformations.origin","text":"origin(f::Transformation)\n\nReturn the transformed origin if it is translated, or nothing otherwise.\n\nIt's necessary to return nothing rather than a zero(Point{T}) if there's no translation, because such transformations (e.g., LinearMaps) may not supply a coordinate type T.\n\n\n\n\n\norigin(ref::GeometryReference)\n\nThe origin of the structure that ref points to, in ref's parent coordinate system.\n\nEquivalently, the translation part of transformation(ref) (the transformation that ref would apply to structure(ref)).\n\n\n\n\n\norigin(sch::Schematic, node::ComponentNode)\norigin(sch::Schematic, node_idx::Int)\n\nThe origin of node in the global coordinate system of sch.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.Transformations.preserves_angles","page":"Transformations","title":"DeviceLayout.Transformations.preserves_angles","text":"preserves_angles(f::Transformation)\n\nReturn true if fis angle-preserving (has equal-magnitude eigenvalues) andfalse` otherwise.\n\nUses approximate equality to allow for floating point imprecision.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.Transformations.rotated_direction","page":"Transformations","title":"DeviceLayout.Transformations.rotated_direction","text":"rotated_direction(angle, trans)\n\nReturn the new direction that angle maps to under the transformation trans.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.Transformations.rotation","page":"Transformations","title":"DeviceLayout.Transformations.rotation","text":"rotation(f::Transformation; α0=0)\n\nReturn the change in angle when applying f to a line originally at α0 CCW from the x-axis.\n\nBy default, α0 is taken to be 0, and the result is equivalent to the rotation when decomposing the linear part of f into reflection across the x-axis followed by rotation.\n\nUnits are accepted for α0 (no units => radians).\n\nIf f does not preserve angles, a DomainError is thrown.\n\n\n\n\n\nrotation(ref::GeometryReference; α0=0)\n\nThe change in angle when applying transformation(ref) to a line originally at α0 CCW from the x-axis.\n\nEquivalent to rotation(transformation(ref); α0=α0).\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.Transformations.rounding_safe","page":"Transformations","title":"DeviceLayout.Transformations.rounding_safe","text":"rounding_safe(precision, f::Transformation)\n\ntrue when applying f gives the same results before or after rounding to precision.\n\nSpecifically, if f preserves angles, translates by integer precision, scales by an integer multiplier, and rotates by a multiple of 90°, it is \"rounding safe\".\n\nprecision should either be an integer type like Int32 or unitful type like typeof(1nm).\n\n\n\n\n\n","category":"function"},{"location":"transformations/#DeviceLayout.Transformations.xrefl","page":"Transformations","title":"DeviceLayout.Transformations.xrefl","text":"xrefl(f::Transformation)\n\nReturn true if f applies a reflection (has negative determinant) and false otherwise.\n\n\n\n\n\nxrefl(ref::GeometryReference)\n\nA Bool indicating whether transformation(ref) includes a reflection.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#Implementation-details","page":"Transformations","title":"Implementation details","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"Geometry objects implement specializations of the transform function that determine how they behave under transformations:","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"    transform","category":"page"},{"location":"transformations/#DeviceLayout.transform","page":"Transformations","title":"DeviceLayout.transform","text":"transform(geom::AbstractGeometry, f::Transformation)\ntransform(\n    geom::AbstractGeometry{S};\n    origin=zero(Point{S}),\n    rot=0°,\n    xrefl=false,\n    mag=1\n)\n\nReturn a new AbstractGeometry obtained by applying f to geom.\n\nFor generic geom and transformation, attempts to decompose f into a scaled isometry: translate ∘ magnify ∘ rotate ∘ reflect_across_xaxis. In that case, if f does not preserve angles, a DomainError will be thrown.\n\nA concrete subtype of AbstractGeometry must implement\n\ntransform(ent::MyEntity, f::Transformation)\n\nIt is not, however, required that an arbitrary Transformation be valid on MyEntity. For example, one might write\n\ntransform(ent::MyEntity, f::Transformation) = transform(ent, ScaledIsometry(f))\nfunction transform(ent::MyEntity, f::ScaledIsometry)\n    # ... create and return transformed entity\nend\n\nwhich will throw a DomainError if !preserves_angles(f) (f is not a scaled isometry).\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"This allows special handling for certain types paired with certain transformations. For example, a Rectangle is by definition axis-aligned. If a transformed Rectangle would still be axis-aligned (for example, the result of a translation or 90° rotation), the result will still be a Rectangle, as in the example above; otherwise, it will be a Polygon.","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"\"Chiral\" geometry objects (those that can be either left- or right-handed) can also implement special handling for transformations that include a reflection (which changes handedness).","category":"page"},{"location":"geometry/#AbstractGeometry","page":"Geometry","title":"AbstractGeometry","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Any AbstractGeometry subtype will have a bounding box and associated methods. It will also support the transformation interface.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"    DeviceLayout.AbstractGeometry\n    coordinatetype\n    bounds(::DeviceLayout.AbstractGeometry)\n    center\n    lowerleft\n    upperright\n    footprint","category":"page"},{"location":"geometry/#DeviceLayout.AbstractGeometry","page":"Geometry","title":"DeviceLayout.AbstractGeometry","text":"AbstractGeometry{S <: Coordinate}\n\nAbstract supertype for things that have a geometric representation.\n\nAbstract subtypes include GeometryStructure, GeometryEntity, and GeometryReference. Provides an interface for coordinate transformations and bounding boxes.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#DeviceLayout.coordinatetype","page":"Geometry","title":"DeviceLayout.coordinatetype","text":"coordinatetype(::Type{S}) where {T, S <: AbstractGeometry{T}}\ncoordinatetype(S) where {T, S <: AbstractGeometry{T}}\n\nReturn the coordinate type of the geometry.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#DeviceLayout.bounds-Tuple{DeviceLayout.AbstractGeometry}","page":"Geometry","title":"DeviceLayout.bounds","text":"bounds(geo::AbstractGeometry)\nbounds(geo0::AbstractGeometry, geo1::AbstractGeometry, geo::AbstractGeometry...)\nbounds(geos)\n\nReturn the minimum bounding Rectangle for geo or a collection/iterator geos.\n\nIf geo is empty or has no extent, a rectangle with zero width and height is returned.\n\nFor a collection or a structure that may contain multiple entities and references to other structures, geometries with bounds having zero width and height are excluded from the calculation.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#DeviceLayout.center","page":"Geometry","title":"DeviceLayout.center","text":"center(p::Polygon)\n\nReturn the center of a polygon's bounding box (Point object). Note that this point doesn't have to be in the polygon.\n\n\n\n\n\ncenter(geo::AbstractGeometry)\ncenter(geos)\n\nReturn the center of the bounding rectangle bounds(geo) or bounds(geos).\n\nWill not throw an InexactError even if geo has integer coordinates, but instead return floating point coordinates.\n\nSee also: lowerleft, upperright.\n\n\n\n\n\ncenter(sch::Schematic, node::ComponentNode)\ncenter(sch::Schematic, node_idx::Int)\n\nThe center of the bounds of node's component in the global coordinate system of sch.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#DeviceLayout.Points.lowerleft","page":"Geometry","title":"DeviceLayout.Points.lowerleft","text":"lowerleft(x::Polygon)\n\nReturn the lower-left-most corner of a rectangle bounding polygon x. Note that this point doesn't have to be in the polygon.\n\n\n\n\n\nlowerleft{T}(A::AbstractArray{Point{T}})\n\nReturn the lower-left Point of the smallest bounding rectangle (with sides parallel to the x- and y-axes) that contains all points in A.\n\nExample:\n\njulia> lowerleft([Point(2, 0), Point(1, 1), Point(0, 2), Point(-1, 3)])\n2-element Point{Int64} with indices SOneTo(2):\n -1\n  0\n\n\n\n\n\nlowerleft(r::Rectangle)\n\nReturn the lower-left corner of a rectangle (Point object).\n\n\n\n\n\nlowerleft(ent::AbstractGeometry)\nlowerleft(ents)\n\nReturn the lower-left-most corner of a rectangle bounding ent or ents. Note that this point doesn't have to be in ent.\n\nFor iterable ents, entities with bounding rectanges of zero width and height will be excluded.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#DeviceLayout.Points.upperright","page":"Geometry","title":"DeviceLayout.Points.upperright","text":"upperright(x::Polygon)\n\nReturn the upper-right-most corner of a rectangle bounding polygon x. Note that this point doesn't have to be in the polygon.\n\n\n\n\n\nupperright{T}(A::AbstractArray{Point{T}})\n\nReturn the upper-right Point of the smallest bounding rectangle (with sides parallel to the x- and y-axes) that contains all points in A.\n\nExample:\n\njulia> upperright([Point(2, 0), Point(1, 1), Point(0, 2), Point(-1, 3)])\n2-element Point{Int64} with indices SOneTo(2):\n 2\n 3\n\n\n\n\n\nupperright(r::Rectangle)\n\nReturn the upper-right corner of a rectangle (Point object).\n\n\n\n\n\nupperright(ent::AbstractGeometry)\nupperright(ents)\n\nReturn the upper-right-most corner of a rectangle bounding ent or ents. Note that this point doesn't have to be in ent.\n\nFor iterable ents, entities with bounding rectanges of zero width and height will be excluded.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#DeviceLayout.footprint","page":"Geometry","title":"DeviceLayout.footprint","text":"footprint(geo::AbstractGeometry)\nfootprint(geos)\n\nReturn the footprint of geo.\n\nBy default, this falls back to bounds(geo), but it may be any single GeometryEntity fully containing geo.\n\nThe footprint of a collection or iterator geos is bounds(geos).\n\n\n\n\n\n","category":"function"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"There are three important subtypes of AbstractGeometry: GeometryEntity, GeometryStructure, and GeometryReference.","category":"page"},{"location":"geometry/#Entities","page":"Geometry","title":"Entities","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Entities are \"simple\" geometric elements. An entity can be placed in a single layer and rendered to an output model. For example, rendering a Rectangle to a Cell creates a Polygon representation suitable for the GDSII format.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"DeviceLayout.GeometryEntity\nDeviceLayout.to_polygons\nhalo(::GeometryEntity, ::Any, ::Any)","category":"page"},{"location":"geometry/#DeviceLayout.GeometryEntity","page":"Geometry","title":"DeviceLayout.GeometryEntity","text":"GeometryEntity{T <: Coordinate}\n\nA geometric entity that can be placed in a coordinate system.\n\nNew concrete GeometryEntity subtypes must implement the following:\n\nto_polygons(::MyEntity)\ntransform(ent::MyEntity, f)\n\nA subtype may also implement specialized transformations like transform(::MyEntity, ::ScaledIsometry), for example if special handling is possible for angle-preserving transformations, as well as specializations for\n\nmagnify\nrotate\nrotate90\nreflect_across_xaxis\ntranslate\n\nwhich otherwise construct the corresponding ScaledIsometry and call transform.\n\nNew subtypes may also implement\n\nfootprint\nhalo\nlowerleft\nupperright\n\nif there are better ways to calculate these than with to_polygons (the default), which may be slow and expensive. The bounding rectangle returned by bounds is derived from lowerleft and upperright. By default, halo is derived from footprint and offset.\n\nNew subtypes may also implement any application functions required for valid styles. Not all styles need be valid for any given entity type.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#DeviceLayout.to_polygons","page":"Geometry","title":"DeviceLayout.to_polygons","text":"to_polygons(ent::GeometryEntity; kwargs...)\n\nReturn a single polygon, an iterator, or Vector of Polygons equivalent to ent.\n\nIf ent is a StyledEntity, all styles will be applied before conversion to polygons.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#DeviceLayout.halo-Tuple{GeometryEntity, Any, Any}","page":"Geometry","title":"DeviceLayout.halo","text":"halo(ent::GeometryEntity{T}, outer_delta, inner_delta=nothing)\n\nReturn the \"halo\" of ent using an offset of outer_delta.\n\nBy default, the halo is a vector containing offset(footprint(ent), outer_delta), but it may contain any number of GeometryEntitys that together fully cover ent with a margin of outer_delta. It is not guaranteed to cover footprint(ent).\n\nIf inner_delta is provided, then the offset at inner_delta is subtracted from the result.\n\nA GeometryEntity should implement a specialized halo if there is an efficient non-Polygon representation of the halo. If it does not, then by default offset will be used, which first resolves the entity into Polygons using to_polygons.\n\n\n\n\n\n","category":"method"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Entity subtypes include AbstractPolygon (Polygon and Rectangle) and the individual pieces (\"nodes\") of a Path.","category":"page"},{"location":"geometry/#Structures","page":"Geometry","title":"Structures","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Structures are \"composite\" geometric objects, containing any number of GeometryEntity elements and their metadata, accessed with the elements and element_metadata methods. They can also contain references to other structures, accessed with refs. Structures also have a name can be flattened. Metadata can be recursively changed in-place with map_metadata! or in a copy with map_metadata. The type parameter of a GeometryStructure determines the coordinate type of its elements.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"DeviceLayout.GeometryStructure\nelements(::DeviceLayout.GeometryStructure)\nelementtype(::DeviceLayout.GeometryStructure)\nelement_metadata(::DeviceLayout.GeometryStructure)\nmap_metadata\nmap_metadata!\nname(::DeviceLayout.GeometryStructure)\nrefs(::DeviceLayout.GeometryStructure)","category":"page"},{"location":"geometry/#DeviceLayout.GeometryStructure","page":"Geometry","title":"DeviceLayout.GeometryStructure","text":"abstract type GeometryStructure{S} <: AbstractGeometry{S}\n\nSupertype for structures that may contain entities and references to other structures.\n\nSubtypes include DeviceLayout.AbstractCoordinateSystem and Path.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#DeviceLayout.elements-Tuple{DeviceLayout.GeometryStructure}","page":"Geometry","title":"DeviceLayout.elements","text":"elements(s::GeometryStructure)\n\nReturn a vector of GeometryEntity in the structure.\n\nFor a Cell, these are Polygons. For a CoordinateSystem, these can be any GeometryEntity.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#DeviceLayout.elementtype-Tuple{DeviceLayout.GeometryStructure}","page":"Geometry","title":"DeviceLayout.elementtype","text":"elementtype(cs::GeometryStructure)\n\nReturn the type of elements in the structure.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#DeviceLayout.element_metadata-Tuple{DeviceLayout.GeometryStructure}","page":"Geometry","title":"DeviceLayout.element_metadata","text":"element_metadata(s::GeometryStructure)\n\nReturn a vector of metadata associated one-to-one with elements(s) in the structure.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#DeviceLayout.map_metadata","page":"Geometry","title":"DeviceLayout.map_metadata","text":"function map_metadata(geom::GeometryStructure, map_meta)\n\nCreate a copy of geom and change original metadata m to map_meta(m) for all elements.\n\nRecursive on the copies of referenced structures.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#DeviceLayout.map_metadata!","page":"Geometry","title":"DeviceLayout.map_metadata!","text":"function map_metadata!(geom::GeometryStructure, map_meta)\n\nFor every element in geom with original meta m, set its metadata to map_meta(m).\n\nRecursive on referenced structures.\n\n\n\n\n\nfunction map_metadata(comp::AbstractComponent, map_meta)\n\nFor every element in geometry(comp) with original meta m, set its metadata to map_meta(m).\n\nRecursive on referenced structures.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#DeviceLayout.name-Tuple{DeviceLayout.GeometryStructure}","page":"Geometry","title":"DeviceLayout.name","text":"name(s::GeometryStructure)\n\nReturn a name String for s.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#DeviceLayout.refs-Tuple{DeviceLayout.GeometryStructure}","page":"Geometry","title":"DeviceLayout.refs","text":"refs(s::GeometryStructure)\n\nReturn a vector of references to sub-structures.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#Unique-names","page":"Geometry","title":"Unique names","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"It's generally desirable to give unique names to structures. In particular, the GDSII format references cells by name, leading to errors or undefined behavior if different cells have the same name. The uniquename function makes it possible to ensure unique names on a per-Julia-session basis or until reset_uniquename! resets the name counter. Structures that are not constructed directly by the user will generally have names generated by uniquename.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"    uniquename\n    reset_uniquename!","category":"page"},{"location":"geometry/#DeviceLayout.uniquename","page":"Geometry","title":"DeviceLayout.uniquename","text":"uniquename(str, dlm=\"\\$\"; modify_first=false, counter=GLOBAL_NAME_COUNTER)\n\nGiven string input str for the nth time, return str * dlm * string(n).\n\nIf str is already formatted as str0 * dlm * n, where n is an integer, then str0 will be used with the larger of n and the number of times str0 has been counted plus one.\n\nIf modify_first is false, then str will be returned the first time uniquename(str, dlm; modify_first=false) is called.\n\nUseful if programmatically making Cells and all of them will eventually be saved into a GDSII file.\n\nThe uniqueness is expected on a per-Julia session basis or until reset_uniquename! is called, so if you load an existing GDSII file and try to save unique cells on top of that you may get an unlucky clash. Calling uniquename on all loaded Cell names will effectively \"register\" them, making subsequent uniquename calls aware of them.\n\nExample\n\njulia> reset_uniquename!();\n\njulia> uniquename(\"name\"; modify_first=true)\n\"name\\$1\"\n\njulia> uniquename(\"name\\$4\")\n\"name\\$4\"\n\njulia> uniquename(\"name\\$3\")\n\"name\\$5\"\n\njulia> uniquename(\"name\")\n\"name\\$6\"\n\ncounter is the Dict{String,Int} that counts how many times each name has been seen. The default is a global counter that persists until the end of the Julia session or until reset_uniquename! is called.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#DeviceLayout.reset_uniquename!","page":"Geometry","title":"DeviceLayout.reset_uniquename!","text":"reset_uniquename!(counter=GLOBAL_NAME_COUNTER)\n\nReset uniquename counters for all strings.\n\ncounter is the Dict{String,Int} that counts how many times each name has been seen. The default is the same default global counter used by uniquename.\n\n\n\n\n\nreset_uniquename!(str::String, counter=GLOBAL_NAME_COUNTER)\n\nReset uniquename counter for str.\n\ncounter is the Dict{String,Int} that counts how many times each name has been seen. The default is the same default global counter used by uniquename.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#References","page":"Geometry","title":"References","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"References point to a structure together with a transformation that positions it relative to the structure holding the reference. An ArrayReference also contains parameters specifying a 2d grid of instantiations of the referenced structure. The methods sref and aref are convenient for creating StructureReferences and ArrayReferences, respectively.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"DeviceLayout.GeometryReference\nStructureReference\nArrayReference\ncopy(::DeviceLayout.GeometryReference)\naref\nsref\nstructure\ntransformation(::DeviceLayout.GeometryReference)\norigin(::DeviceLayout.GeometryReference)\nmag(::DeviceLayout.GeometryReference)\nrotation(::DeviceLayout.GeometryReference)\nxrefl(::DeviceLayout.GeometryReference)","category":"page"},{"location":"geometry/#DeviceLayout.GeometryReference","page":"Geometry","title":"DeviceLayout.GeometryReference","text":"GeometryReference{S<:Coordinate, T<:GeometryStructure} <: AbstractGeometry{S}\n\nAbstract supertype for references to geometry structures.\n\nSubtypes are StructureReference and ArrayReference.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#DeviceLayout.StructureReference","page":"Geometry","title":"DeviceLayout.StructureReference","text":"mutable struct StructureReference{S, T} <: GeometryReference{S, T}\n    structure::T\n    origin::Point{S}\n    xrefl::Bool\n    mag::Float64\n    rot::Float64\nend\n\nReference to a structure positioned at origin, with optional x-reflection xrefl, magnification factor mag, and rotation angle rot. If an angle is given without units it is assumed to be in radians.\n\nThat is, the transformation applied by the reference is the composition of the following transformations, ordered with reflection applied first:\n\nIf xrefl(f) is true, a reflection across the x-axis\nRotation by rotation(f)\nMagnification by mag(f)\nTranslation by origin(f)\n\nThe type variable T is to avoid circular definitions.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#DeviceLayout.ArrayReference","page":"Geometry","title":"DeviceLayout.ArrayReference","text":"mutable struct ArrayReference{S,T} <: GeometryReference{S,T}\n    structure::T\n    origin::Point{S}\n    deltacol::Point{S}\n    deltarow::Point{S}\n    col::Int\n    row::Int\n    xrefl::Bool\n    mag::Float64\n    rot::Float64\nend\n\nArray of structure starting at origin with row rows and col columns, spanned by vectors deltacol and deltarow. Optional x-reflection xrefl, magnification factor mag, and rotation angle rot for the array as a whole. If an angle is given without units it is assumed to be in radians.\n\nThe type variable T is to avoid circular definitions.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#Base.copy-Tuple{DeviceLayout.GeometryReference}","page":"Geometry","title":"Base.copy","text":"copy(x::GeometryReference)\n\nCreates a shallow copy of x (does not copy the referenced structure).\n\n\n\n\n\n","category":"method"},{"location":"geometry/#DeviceLayout.aref","page":"Geometry","title":"DeviceLayout.aref","text":"aref(x::GeometryStructure{S}, origin::Point{T}=zero(Point{S}); kwargs...) where\n    {S <: Coordinate, T <: Coordinate}\n\nConstruct a ArrayReference{float(T),typeof(x)} object.\n\nKeyword arguments specify the column vector, row vector, number of columns, number of rows, x-reflection, magnification factor, and rotation.\n\nSynonyms are accepted for these keywords:\n\nColumn vector dc::Point{T}: :deltacol, :dcol, :dc, :vcol, :colv, :colvec, :colvector, :columnv, :columnvec, :columnvector\nRow vector: :deltarow, :drow, :dr, :vrow, :rv, :rowvec, :rowvector\nNumber of columns: :nc, :numcols, :numcol, :ncols, :ncol\nNumber of rows: :nr, :numrows, :numrow, :nrows, :nrow\nX-reflection: :xrefl, :xreflection, :refl, :reflect, :xreflect, :xmirror, :mirror\nMagnification: :mag, :magnification, :magnify, :zoom, :scale\nRotation: :rot, :rotation, :rotate, :angle\n\n\n\n\n\naref(x, c::AbstractRange, r::AbstractRange; kwargs...)\n\nConstruct an ArrayReference based on ranges (probably LinSpace or FloatRange). c specifies column coordinates and r for the rows. Pairs from c and r specify the origins of the repeated cells. The extrema of the ranges therefore do not specify the extrema of the resulting ArrayReference's bounding box; some care is required.\n\nKeyword arguments specify x-reflection, magnification factor, and rotation, with synonyms allowed:\n\nX-reflection: :xrefl, :xreflection, :refl, :reflect, :xreflect, :xmirror, :mirror\nMagnification: :mag, :magnification, :magnify, :zoom, :scale\nRotation: :rot, :rotation, :rotate, :angle\n\n\n\n\n\n","category":"function"},{"location":"geometry/#DeviceLayout.sref","page":"Geometry","title":"DeviceLayout.sref","text":"sref(x::GeometryStructure{T}, origin=zero(Point{T}); kwargs...)\n\nConvenience constructor for StructureReference{float(T), typeof(x)}.\n\nSynonyms are accepted for these keywords:\n\n- X-reflection: `:xrefl`, `:xreflection`, `:refl`, `:reflect`, `:xreflect`,\n`:xmirror`, `:mirror`\n- Magnification: `:mag`, `:magnification`, `:magnify`, `:zoom`, `:scale`\n- Rotation: `:rot`, `:rotation`, `:rotate`, `:angle`\n\n\n\n\n\n","category":"function"},{"location":"geometry/#DeviceLayout.structure","page":"Geometry","title":"DeviceLayout.structure","text":"structure(ref::GeometryReference)\n\nThe GeometryStructure that ref points to.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#DeviceLayout.transformation-Tuple{DeviceLayout.GeometryReference}","page":"Geometry","title":"DeviceLayout.transformation","text":"transformation(c::GeometryReference)\n\nReturn the angle-preserving transformation to be applied to the referenced structure.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#DeviceLayout.Transformations.origin-Tuple{DeviceLayout.GeometryReference}","page":"Geometry","title":"DeviceLayout.Transformations.origin","text":"origin(ref::GeometryReference)\n\nThe origin of the structure that ref points to, in ref's parent coordinate system.\n\nEquivalently, the translation part of transformation(ref) (the transformation that ref would apply to structure(ref)).\n\n\n\n\n\n","category":"method"},{"location":"geometry/#DeviceLayout.Transformations.mag-Tuple{DeviceLayout.GeometryReference}","page":"Geometry","title":"DeviceLayout.Transformations.mag","text":"mag(ref::GeometryReference)\n\nThe magnification (uniform scaling factor) applied by transformation(ref).\n\n\n\n\n\n","category":"method"},{"location":"geometry/#DeviceLayout.Transformations.rotation-Tuple{DeviceLayout.GeometryReference}","page":"Geometry","title":"DeviceLayout.Transformations.rotation","text":"rotation(ref::GeometryReference; α0=0)\n\nThe change in angle when applying transformation(ref) to a line originally at α0 CCW from the x-axis.\n\nEquivalent to rotation(transformation(ref); α0=α0).\n\n\n\n\n\n","category":"method"},{"location":"geometry/#DeviceLayout.Transformations.xrefl-Tuple{DeviceLayout.GeometryReference}","page":"Geometry","title":"DeviceLayout.Transformations.xrefl","text":"xrefl(ref::GeometryReference)\n\nA Bool indicating whether transformation(ref) includes a reflection.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#Resolving-references","page":"Geometry","title":"Resolving references","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Sometimes it can be helpful to transform between coordinate systems and the coordinate systems they reference. This package provides methods to generate affine transforms to do this as easily as possible.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"    transformation(::DeviceLayout.GeometryStructure, ::DeviceLayout.GeometryReference)\n    transformation(c::DeviceLayout.GeometryStructure, d::DeviceLayout.GeometryReference, e::DeviceLayout.GeometryReference, f::DeviceLayout.GeometryReference...)","category":"page"},{"location":"geometry/#DeviceLayout.transformation-Tuple{DeviceLayout.GeometryStructure, DeviceLayout.GeometryReference}","page":"Geometry","title":"DeviceLayout.transformation","text":"transformation(c::GeometryStructure, d::GeometryReference)\n\nGiven a GeometryStructure c containing GeometryReference d in its tree of references, this function returns a Transformations.ScaledIsometry object that lets you translate from the coordinate system of d to the coordinate system of c.\n\nIf the same exact GeometryReference (as in ===, same address in memory) is included multiple times in the tree of references, then the resulting transform will be based on the first time it is encountered. The tree is traversed one level at a time to find the reference (optimized for shallow references).\n\nExample: You want to translate (2.0,3.0) in the coordinate system of the referenced coordinate system d to the coordinate system of c:\n\njulia> trans = transformation(c,d)\n\njulia> trans(Point(2.0,3.0))\n\n\n\n\n\n","category":"method"},{"location":"geometry/#DeviceLayout.transformation-Tuple{DeviceLayout.GeometryStructure, DeviceLayout.GeometryReference, DeviceLayout.GeometryReference, Vararg{DeviceLayout.GeometryReference}}","page":"Geometry","title":"DeviceLayout.transformation","text":"transformation(c::GeometryStructure, d::GeometryReference, e::GeometryReference, f::GeometryReference...)\n\nGiven a geometry structure c containing GeometryReference last(f) in its tree of references, this function returns a Transformations.ScaledIsometry object that lets you translate from the coordinate system of last(f) to the coordinate system of c. This method is needed when you want to specify intermediate GeometryReferences explicitly.\n\nFor example, suppose for instance you have a hierarchy of coordinate systems, where coordinate system A references B1 and B2, which both reference C. Schematically, it might look like this:\n\na -- b1 -- c\n  \\      /\n   \\ b2 /\n\nCoordinate system C appears in two places inside coordinate system A, owing to the fact that it is referenced by both B1 and B2. If you need to get the coordinate system of C via B2, then you need to do transformation(coordinatesystemA, coordsysrefB2, coordsysrefC), rather than simply transform(coordinatesystemA, coordsysrefC), because the latter will just take the first path to C available, via B1.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#Flattening","page":"Geometry","title":"Flattening","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Sometimes it's also helpful use an operation called \"flattening\" to produce an equivalent coordinate system with no references—that is, with all its elements at the top level.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"    flatten(::DeviceLayout.GeometryStructure)\n    flatten(::DeviceLayout.GeometryReference)","category":"page"},{"location":"geometry/#DeviceLayout.flatten-Tuple{DeviceLayout.GeometryStructure}","page":"Geometry","title":"DeviceLayout.flatten","text":"flatten(c::GeometryStructure; depth::Integer=-1, name=uniquename(\"flatten_\"*name(c)))\n\nReturn a new coordinate system with name name with recursively flattened references and arrays up to a hierarchical depth.\n\nFlattening a CoordinateSystem or Cell produces a coordinate system of the same type (meaning these can also be flattened in-place with flatten!), while flattening other structures generally produces a CoordinateSystem with the same coordinate type.\n\nFlattening adds the elements of references to the top-level structure with appropriate transformations, then discards those references. Deeper references and arrays are brought upwards and are not discarded.\n\nThis function has no effect on references for depth == 0, and unlimited depth by default.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#DeviceLayout.flatten-Tuple{DeviceLayout.GeometryReference}","page":"Geometry","title":"DeviceLayout.flatten","text":"flatten(c::GeometryReference; depth::Integer=-1, name=uniquename(\"flatten_\"*name(structure(c))), metadata_filter=nothing)\n\nReturn a new structure with name name with recursively flattened references and arrays up to a hierarchical depth.\n\nFlattening adds the elements of references to the top-level coordinate system with appropriate transformations, then discards those references. Deeper references and arrays are brought upwards and are not discarded. If depth=0, a new coordinate system is returned containing only the reference.\n\nmetadata_filter can be a function that takes a DeviceLayout.Meta and returns a Bool, like a function returned by layer_inclusion. In that case, only elements whose metadata m have metadata_filter(m) == true will be retained while flattening. Elements of deeper references and arrays are not filtered.\n\nThe reference c remains unmodified.\n\n\n\n\n\n","category":"method"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"These methods take a metadata_filter keyword argument, which is a function that can be generated using layer_inclusion and lists of layers to include or ignore:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"    layer_inclusion","category":"page"},{"location":"geometry/#DeviceLayout.layer_inclusion","page":"Geometry","title":"DeviceLayout.layer_inclusion","text":"layer_inclusion(only_layers, ignore_layers)\n\nReturn a function f(m::Meta) that returns a Bool based on inclusion/exclusion rules.\n\nBoth only_layers and ignore_layers are  DeviceLayout.Meta, layer name Symbols, and/or collections of either.\n\nIf only_layers is empty, then only ignore_layers is used, and f(m) checks that neither m nor layer(m) is in ignore_layers. Otherwise, f(m) also checks that m or layer(m) is in only_layers.\n\n\n\n\n\n","category":"function"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"For convenience, if you want to get just the list of elements in a flattened structure that match a layer or set of layers, you can use flat_elements:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"    flat_elements","category":"page"},{"location":"geometry/#DeviceLayout.flat_elements","page":"Geometry","title":"DeviceLayout.flat_elements","text":"flat_elements(geom::Union{GeometryStructure,GeometryReference}, only_layers=[], ignore_layers=[])\nflat_elements(geom_layer::Pair{<:Union{GeometryStructure,GeometryReference}})\n\nReturn a list of GeometryEntity elements in flatten(cs), optionally filtering metadata.\n\nonly_layers and ignore_layers can be layer name Symbols, DeviceLayout.Meta, or collections of either. The metadata filtering function is produced using layer_inclusion(only_layers, ignore_layers). This means that the default empty only_layers is the same as listing all layers.\n\nUsing an argument pair geom => layer is equivalent to flat_elements(geom, layer).\n\n\n\n\n\n","category":"function"},{"location":"geometry/#Indexing","page":"Geometry","title":"Indexing","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"For convenience, you can get referenced structures by indexing their parent with the structure name, as in cs[\"referenced_cs\"][\"deeper_cs\"].","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"    Base.getindex(::DeviceLayout.GeometryStructure, ::AbstractString, ::Integer)\n    Base.getindex(::DeviceLayout.GeometryReference, ::AbstractString, ::Integer)","category":"page"},{"location":"geometry/#Base.getindex-Tuple{DeviceLayout.GeometryStructure, AbstractString, Integer}","page":"Geometry","title":"Base.getindex","text":"getindex(c::GeometryStructure, nom::AbstractString, index::Integer=1)\n\nIf c references a structure with name nom, this method will return the corresponding GeometryReference. If there are several references to that coordinate system, then index specifies which one is returned (in the order they are found in refs(c)). e.g. to specify an index of 2: myCS[\"myreferencedCS\",2].\n\n\n\n\n\n","category":"method"},{"location":"geometry/#Base.getindex-Tuple{DeviceLayout.GeometryReference, AbstractString, Integer}","page":"Geometry","title":"Base.getindex","text":"getindex(c::GeometryReference, nom::AbstractString, index::Integer=1)\n\nIf the structure referenced by c references a structure with name nom, this method will return the corresponding GeometryReference. If there are several references to that structure, then index specifies which one is returned (in the order they are found in refs(structure(c))).\n\nThis method is typically used so that we can type the first line instead of the second line in the following:\n\nmyCS[\"myreferencedCS\"][\"onedeeper\"]\nmyCS[\"myreferencedCS\"].structure[\"onedeeper\"]\n\n\n\n\n\n","category":"method"},{"location":"autofill/#Autofill","page":"Autofill","title":"Autofill","text":"","category":"section"},{"location":"autofill/","page":"Autofill","title":"Autofill","text":"There are some utility methods for generating \"halos\" of structures for use as exclusion zones and automatically filling in non-excluded areas with references.","category":"page"},{"location":"autofill/","page":"Autofill","title":"Autofill","text":"Autofill.autofill!\nAutofill.halo\nAutofill.make_halo","category":"page"},{"location":"autofill/#DeviceLayout.Autofill.autofill!","page":"Autofill","title":"DeviceLayout.Autofill.autofill!","text":"autofill!(cs::AbstractCoordinateSystem,\n    filler_cs::AbstractCoordinateSystem,\n    grid_x::AbstractArray,\n    grid_y::AbstractArray,\n    exclusion)\n\nAdd references to filler_cs inside cs at grid points not in any exclusion polygon.\n\nThe exclusion argument may be\n\na Coordinate denoting an offset used to generate the excluded region from shapes in cs\na CoordinateSystem or Cell containing the geometry of the excluded region\na Function creating a CoordinateSystem or Cell from cs\nan AbstractArray{<:AbstractPolygon}\n\nReturns the origins of references.\n\n\n\n\n\n","category":"function"},{"location":"autofill/#DeviceLayout.halo","page":"Autofill","title":"DeviceLayout.halo","text":"halo(pa::Path, outer_delta, inner_delta; only_layers=[], ignore_layers=[])\n\nReturn a Path forming the halo of pa, equivalent to offsetting the geometry by outer_delta, then subtracting the offset by inner_delta if it is not nothing.\n\nExtends the start and/or end by delta (for each inner/outer offset) when pa has nonzero extent at the endpoints. Each segment's style is the halo style of the original segment.\n\nFor the segments of the Path and any attached references, any entities in layers in ignore_layers will be skipped. Note that even if the segments are ignored, attachments may not be. If only_layers is not empty, only those layers will be used to generate the halo. Layers for inclusion and exclusion can be provided as layer name Symbols, in which case only the layer name needs to be matched, or as full DeviceLayout.Meta objects, in which case all metadata fields (e.g., index and level for SemanticMeta) must match.\n\nReturns a Path.\n\n\n\n\n\nhalo(sty::Paths.Style, outer_delta, inner_delta=nothing; kwargs...)\n\nReturn a Trace or CPW style covering the extent of sty from an offset of inner_delta to outer_delta.\n\n\n\n\n\nhalo(ent::GeometryEntity{T}, outer_delta, inner_delta=nothing)\n\nReturn the \"halo\" of ent using an offset of outer_delta.\n\nBy default, the halo is a vector containing offset(footprint(ent), outer_delta), but it may contain any number of GeometryEntitys that together fully cover ent with a margin of outer_delta. It is not guaranteed to cover footprint(ent).\n\nIf inner_delta is provided, then the offset at inner_delta is subtracted from the result.\n\nA GeometryEntity should implement a specialized halo if there is an efficient non-Polygon representation of the halo. If it does not, then by default offset will be used, which first resolves the entity into Polygons using to_polygons.\n\n\n\n\n\nhalo(cs::CoordinateSystem, outer_delta, inner_delta=nothing; only_layers=[],\n    ignore_layers=[])\nhalo(cs::Cell, outer_delta, inner_delta=nothing; only_layers=[], ignore_layers=[])\n\nA coordinate system of type typeof(cs) with halos for all entities in cs, tracing through cs.refs.\n\nAny entities in layers in ignore_layers will be skipped. If only_layers is not empty, only those layers will be used to generate the halo. Layers for inclusion and exclusion can be provided as layer name Symbols, in which case only the layer name needs to be matched, or as full DeviceLayout.Meta objects, in which case all metadata fields (e.g., index and level for SemanticMeta) must match.\n\nThe orientations of polygons must be consistent, such that outer polygons share the same orientation, and any holes have the opposite orientation. Additionally, any holes should be contained within outer polygons; offsetting hole edges may create positive artifacts at corners.\n\n\n\n\n\nhalo(c::AbstractComponent, delta, inner_delta=nothing; only_layers=[], ignore_layers=[])\n\nA component's halo, intended for use as an exclusion zone parameterized by a bias delta.\n\nBy default, this applies a delta halo to all geometry elements whose metadata matches the inclusion/exclusion requirements. For example, polygons are offset by delta (enlarged by growing delta away from each original edge). Any entities in layers in ignore_layers will be skipped. If only_layers is not empty, only those layers will be used to generate the halo. Layers for inclusion and exclusion can be provided as layer name Symbols, in which case only the layer name needs to be matched, or as full DeviceLayout.Meta objects, in which case all metadata fields (e.g., index and level for SemanticMeta) must match.\n\nAn inner_delta may be specified to subtract the halo at that bias from the result.\n\nAbstractComponents may define their own halo methods.\n\n\n\n\n\n","category":"function"},{"location":"autofill/#DeviceLayout.Autofill.make_halo","page":"Autofill","title":"DeviceLayout.Autofill.make_halo","text":"make_halo(delta, inner_delta=nothing; only_layers=[], ignore_layers=[])\n\nReturns a function (c)->halo(c, delta, inner_delta; only_layers, ignore_layers) for generating GeometryStructure halos.\n\nAny entities in layers in ignore_layers will be skipped. If only_layers is not empty, only those layers will be used to generate the halo. Layers for inclusion and exclusion can be provided as layer name Symbols, in which case only the layer name needs to be matched, or as full DeviceLayout.Meta objects, in which case all metadata fields (e.g., index and level for SemanticMeta) must match.\n\n\n\n\n\n","category":"function"},{"location":"coordinate_systems/#Coordinate-Systems","page":"Coordinate Systems","title":"Coordinate Systems","text":"","category":"section"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"Coordinate systems (subtypes of AbstractCoordinateSystem) group geometric objects into a single structure with a common origin and coordinate axes. They can contain references to other DeviceLayout.GeometryStructures, a GeometryEntity list, and metadata for each entity.","category":"page"},{"location":"coordinate_systems/#AbstractCoordinateSystems","page":"Coordinate Systems","title":"AbstractCoordinateSystems","text":"","category":"section"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"    DeviceLayout.AbstractCoordinateSystem","category":"page"},{"location":"coordinate_systems/#DeviceLayout.AbstractCoordinateSystem","page":"Coordinate Systems","title":"DeviceLayout.AbstractCoordinateSystem","text":"AbstractCoordinateSystem{S<:Coordinate} <: GeometryStructure{S}\n\nAbstract supertype for coordinate systems, including CoordinateSystem and Cell.\n\nAlso exists to avoid circular definitions involving the concrete AbstractCoordinateSystem types and subtypes of GeometryReference.\n\n\n\n\n\n","category":"type"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"Because these are subtypes of GeometryStructure, they can be used with the transformation interface as well as the structure interface including bounds and other operations.","category":"page"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"DeviceLayout.jl defines the concrete CoordinateSystem as a backend-agnostic (or \"native\") representation that can be converted to other representations as necessary, and Cell as the concrete representation corresponding to the GDSII format. There is also the subtype SchematicDrivenLayout.Schematic, which composes a CoordinateSystem with schematic-level information about component connectivity.","category":"page"},{"location":"coordinate_systems/#Referenced-coordinate-systems","page":"Coordinate Systems","title":"Referenced coordinate systems","text":"","category":"section"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"Coordinate systems can be arrayed or referenced within other coordinate systems. These can be accessed in the array returned by refs(cs) or by indexing the parent coordinate system or reference with the referenced structure's name, as in cs[\"referenced_cs\"][\"deeper_cs\"].","category":"page"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"The methods addref! and addarr! are provided for adding structure references and array references.","category":"page"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"    addref!\n    addarr!","category":"page"},{"location":"coordinate_systems/#DeviceLayout.CoordinateSystems.addref!","page":"Coordinate Systems","title":"DeviceLayout.CoordinateSystems.addref!","text":"addref!(c1::AbstractCoordinateSystem, cr::GeometryReference)\n\nAdd the reference cr to the list of references in c1.\n\n\n\n\n\naddref!(c1::AbstractCoordinateSystem{T},\n    c2::GeometryStructure,\n    origin=zero(Point{T});\n    kwargs...)\n\nAdd a reference to c2 to the list of references in c1.\n\nThe reference to c2 has origin origin; x-reflection, magnification factor, and rotation are set by keywords arguments.\n\nSynonyms are accepted for these keywords:\n\nX-reflection: :xrefl, :xreflection, :refl, :reflect, :xreflect, :xmirror, :mirror\nMagnification: :mag, :magnification, :magnify, :zoom, :scale\nRotation: :rot, :rotation, :rotate, :angle\n\n\n\n\n\n","category":"function"},{"location":"coordinate_systems/#DeviceLayout.CoordinateSystems.addarr!","page":"Coordinate Systems","title":"DeviceLayout.CoordinateSystems.addarr!","text":"addarr!(\n    c1::AbstractCoordinateSystem{T},\n    c2::GeometryStructure,\n    origin::Point=zero(Point{T});\n    kwargs...\n)\n\nAdd an ArrayReference to c2 to the list of references in c1.\n\nThe reference to c2 has origin origin. Keyword arguments specify the column vector, row vector, number of columns, number of rows, x-reflection, magnification factor, and rotation.\n\nSynonyms are accepted for these keywords:\n\nColumn vector dc::Point{T}: :deltacol, :dcol, :dc, :vcol, :colv, :colvec, :colvector, :columnv, :columnvec, :columnvector\nRow vector: :deltarow, :drow, :dr, :vrow, :rv, :rowvec, :rowvector\nNumber of columns: :nc, :numcols, :numcol, :ncols, :ncol\nNumber of rows: :nr, :numrows, :numrow, :nrows, :nrow\nX-reflection: :xrefl, :xreflection, :refl, :reflect, :xreflect, :xmirror, :mirror\nMagnification: :mag, :magnification, :magnify, :zoom, :scale\nRotation: :rot, :rotation, :rotate, :angle\n\n\n\n\n\naddarr!(\n    c1::AbstractCoordinateSystem,\n    c2::GeometryStructure,\n    c::AbstractRange,\n    r::AbstractRange;\n    kwargs...\n)\n\nAdd an ArrayReference to c2 to the list of references in c1, based on ranges.\n\nc specifies column coordinates and r for the rows. Pairs from c and r specify the origins of the repeated cells. The extrema of the ranges therefore do not specify the extrema of the resulting ArrayReference's bounding box; some care is required.\n\nKeyword arguments specify x-reflection, magnification factor, and rotation, with synonyms allowed:\n\nX-reflection: :xrefl, :xreflection, :refl, :reflect, :xreflect, :xmirror, :mirror\nMagnification: :mag, :magnification, :magnify, :zoom, :scale\nRotation: :rot, :rotation, :rotate, :angle\n\n\n\n\n\n","category":"function"},{"location":"coordinate_systems/#Flattening","page":"Coordinate Systems","title":"Flattening","text":"","category":"section"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"Sometimes it's also helpful use the flatten operation to produce an equivalent coordinate system with no references—that is, with all its elements at the top level. CoordinateSystems and Cells can also be flattened in place with flatten!.","category":"page"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"    flatten!(::DeviceLayout.AbstractCoordinateSystem)","category":"page"},{"location":"coordinate_systems/#DeviceLayout.CoordinateSystems.flatten!-Tuple{DeviceLayout.AbstractCoordinateSystem}","page":"Coordinate Systems","title":"DeviceLayout.CoordinateSystems.flatten!","text":"flatten!(c::AbstractCoordinateSystem, depth::Integer=-1, metadata_filter=nothing, max_copy=Inf)\n\nRecursively flatten references and arrays up to a hierarchical depth, adding their elements to c with appropriate transformations.\n\nThe references and arrays that were flattened are then discarded. Deeper references and arrays are brought upwards and are not discarded.\n\nThis function has no effect for depth == 0, and unlimited depth by default.\n\n\n\n\n\n","category":"method"},{"location":"coordinate_systems/#Cells","page":"Coordinate Systems","title":"Cells","text":"","category":"section"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"Cells are the concrete AbstractCoordinateSystem representation corresponding to the GDSII format. Accordingly, they hold Polygons with metadata of type GDSMeta (added using render!). They can also hold Text objects, and they can be saved directly to a .gds file.","category":"page"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"    Cell\n    Cell(::AbstractString)\n    Cells.dbscale(::Cell)\n    Cells.dbscale(::Cell, ::Cell, ::Cell...)\n    CellArray\n    CellReference\n    GDSMeta\n    render!(::Cell, ::Polygon, ::GDSMeta)\n    DeviceLayout.save(::File{format\"GDS\"}, ::Cell, ::Cell...)","category":"page"},{"location":"coordinate_systems/#DeviceLayout.Cells.Cell","page":"Coordinate Systems","title":"DeviceLayout.Cells.Cell","text":"mutable struct Cell{S<:Coordinate}\n\nA cell has a name and contains polygons and references to CellArray or CellReference objects. It also records the time of its own creation. As currently implemented it mirrors the notion of cells in GDSII files.\n\nTo add elements, use render!. To add references, use addref! or addarr!. To add text, use text!.\n\n\n\n\n\n","category":"type"},{"location":"coordinate_systems/#DeviceLayout.Cells.Cell-Tuple{AbstractString}","page":"Coordinate Systems","title":"DeviceLayout.Cells.Cell","text":"Cell(name::AbstractString)\n\nConvenience constructor for Cell{typeof(1.0UPREFERRED)}.\n\nDeviceLayout.UPREFERRED is a constant set according to the unit preference in Project.toml or LocalPreferences.toml. The default (\"PreferNanometers\") gives const UPREFERRED = DeviceLayout.nm, with mixed-unit operations preferring conversion to nm.\n\nUnit preference does not affect the database scale for GDS export.\n\n\n\n\n\n","category":"method"},{"location":"coordinate_systems/#DeviceLayout.Cells.dbscale-Tuple{Cell}","page":"Coordinate Systems","title":"DeviceLayout.Cells.dbscale","text":"dbscale(c::Cell)\n\nGive the database scale for a cell. The database scale is the smallest increment of length that will be represented in the output CAD file. This is different from the working coordinate type T of the Cell.\n\nThe database scale defaults to 1nm (1.0nm if T <: FloatCoordinate), but can be changed by updating c.dbscale to a new Unitful.Length quantity.\n\n\n\n\n\n","category":"method"},{"location":"coordinate_systems/#DeviceLayout.Cells.dbscale-Tuple{Cell, Cell, Vararg{Cell}}","page":"Coordinate Systems","title":"DeviceLayout.Cells.dbscale","text":"dbscale(cell::Cell...)\n\nChoose an appropriate database scale for a GDSII file given Cells of different types. The smallest database scale of all cells considered is returned.\n\n\n\n\n\n","category":"method"},{"location":"coordinate_systems/#DeviceLayout.Cells.CellArray","page":"Coordinate Systems","title":"DeviceLayout.Cells.CellArray","text":"const CellArray\n\nAlias for ArrayReferences to Cells.\n\n\n\n\n\n","category":"type"},{"location":"coordinate_systems/#DeviceLayout.Cells.CellReference","page":"Coordinate Systems","title":"DeviceLayout.Cells.CellReference","text":"const CellReference\n\nAlias for StructureReferences to Cells.\n\n\n\n\n\n","category":"type"},{"location":"coordinate_systems/#DeviceLayout.GDSMeta","page":"Coordinate Systems","title":"DeviceLayout.GDSMeta","text":"struct GDSMeta <: DeviceLayout.Meta\n    layer::Int\n    datatype::Int\n    GDSMeta() = new(DEFAULT_LAYER, DEFAULT_DATATYPE)\n    GDSMeta(l) = new(l, DEFAULT_DATATYPE)\n    GDSMeta(l, d) = new(l, d)\nend\n\nMetadata associated with GDSII format. Default layer and datatype are 0.\n\n\n\n\n\n","category":"type"},{"location":"coordinate_systems/#DeviceLayout.render!-Tuple{Cell, Polygon, GDSMeta}","page":"Coordinate Systems","title":"DeviceLayout.render!","text":"render!(c::Cell, p::Polygon, meta::GDSMeta=GDSMeta())\n\nRender a polygon p to cell c, defaulting to plain styling. If p has more than 8190 (set by DeviceLayout's GDS_POLYGON_MAX constant), then it is partitioned into smaller polygons which are then rendered. Environment variable ENV[\"GDS_POLYGON_MAX\"] will override this constant. The partitioning algorithm implements guillotine cutting, that goes through at least one existing vertex and in manhattan directions. Cuts are selected by ad hoc optimzation for \"nice\" partitions.\n\n\n\n\n\n","category":"method"},{"location":"coordinate_systems/#DeviceLayout.save-Tuple{File{DataFormat{:GDS}}, Cell, Vararg{Cell}}","page":"Coordinate Systems","title":"DeviceLayout.save","text":"save(::Union{AbstractString,IO}, cell0::Cell{T}, cell::Cell...)\nsave(f::File{format\"GDS\"}, cell0::Cell, cell::Cell...;\n    name=\"GDSIILIB\", userunit=1μm, modify=now(), acc=now(),\n    verbose=false)\n\nThis bottom method is implicitly called when you use the convenient syntax of the top method: save(\"/path/to/my.gds\", cells_i_want_to_save...)\n\nKeyword arguments include:\n\nname: used for the internal library name of the GDSII file and probably inconsequential for modern workflows.\nuserunit: sets what 1.0 corresponds to when viewing this file in graphical GDS editors with inferior unit support.\nmodify: date of last modification.\nacc: date of last accession. It would be unusual to have this differ from now().\nverbose: monitor the output of traverse! and order! to see if something funny is happening while saving.\n\n\n\n\n\n","category":"method"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"The type parameter S of a Cell{S} object determine the type of the coordinates of all polygons in a cell, including the units and whether integer or floating-point values are used. Currently, you cannot do a whole lot (particularly with regard to paths) if the cell has integer coordinates. However, they do have an inherent advantage because the coordinates are exact, and ultimately the GDSII file represents shapes with integer coordinates.","category":"page"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"Separately, the Cell has a \"database scale\" (the dbscale field) applied when saving that defaults to 1nm but can be changed.","category":"page"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"For most cases, if you want to use units, Cell(\"my_cell_name\", nm) is a good way to construct a cell which will ultimately have all coordinates rounded to the nearest nm when exported into GDSII. You can add polygons with whatever length units you want to such a cell, and the coordinates will be converted automatically to nm.","category":"page"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"If you don't want units, just construct the cell with a name only: Cell(\"my_cell_name\") will return a Cell{Float64} object unless you have set a unit preference. In this case too, the ultimate database resolution is 1nm; until exporting the cell into a GDSII file, the coordinates are interpreted to be in units of 1μm.","category":"page"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"When saving cells to disk, keep in mind that cells should have unique names. We don't have an automatic renaming scheme implemented to avoid clashes. To help with this, we provide a function uniquename to generate unique names based on human-readable prefixes.","category":"page"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"When saving cells to disk, there will be a tree of interdependencies and logically one would prefer to write the leaf nodes of the tree before any dependent cells. These functions are used to traverse the tree and then find the optimal ordering.","category":"page"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"    traverse!\n    order!","category":"page"},{"location":"coordinate_systems/#DeviceLayout.CoordinateSystems.traverse!","page":"Coordinate Systems","title":"DeviceLayout.CoordinateSystems.traverse!","text":"traverse!(a::AbstractArray, c::GeometryStructure, level=1)\n\nGiven a coordinate system, recursively traverse its references for other coordinate systems and add to array a some tuples: (level, c). level corresponds to how deep the coordinate system was found, and c is the found coordinate system.\n\n\n\n\n\n","category":"function"},{"location":"coordinate_systems/#DeviceLayout.CoordinateSystems.order!","page":"Coordinate Systems","title":"DeviceLayout.CoordinateSystems.order!","text":"order!(a::AbstractArray)\n\nGiven an array of tuples like that coming out of traverse!, we sort by the level, strip the level out, and then retain unique entries. The aim of this function is to determine an optimal writing order when saving pattern data (although the GDSII spec does not require cells to be in a particular order, there may be performance ramifications).\n\nFor performance reasons, this function modifies a but what you want is the returned result array.\n\n\n\n\n\n","category":"function"},{"location":"coordinate_systems/#CoordinateSystems","page":"Coordinate Systems","title":"CoordinateSystems","text":"","category":"section"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"CoordinateSystems are \"DeviceLayout-native\" AbstractCoordinateSystems. Unlike Cells, they can hold any GeometryEntity, not just Polygons, as well as references to any GeometryStructure, not just Cells. The idea is to work with an exact or logical representation of geometric elements as long as possible, deferring decisions about output representations until rendering time. This allows things like calculating intersection points between Paths in a hierarchy of CoordinateSystems and references, or rendering exact curves to a SolidModel.","category":"page"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"Because of this, we add entities to a CoordinateSystem with place! rather than render!. The different verb is meant to convey that the entity is added as-is rather than potentially converted to some other representation. (For convenience, render! still works with CoordinateSystems, but it's just an alias for place!.)","category":"page"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"    CoordinateSystem\n    CoordinateSystemReference\n    CoordinateSystemArray\n    place!","category":"page"},{"location":"coordinate_systems/#DeviceLayout.CoordinateSystems.CoordinateSystem","page":"Coordinate Systems","title":"DeviceLayout.CoordinateSystems.CoordinateSystem","text":"mutable struct CoordinateSystem{S<:Coordinate} <: AbstractCoordinateSystem{S}\n    name::String\n    elements::Vector{GeometryEntity{S}}\n    meta::Vector{Meta}\n    refs::Vector{GeometryReference}\n    create::DateTime\n\n    CoordinateSystem{S}(x, y, ym, z, t) where {S} = new{S}(x, y, ym, z, t)\n    CoordinateSystem{S}(x, y, ym, z) where {S} = new{S}(x, y, ym, z, now())\n    CoordinateSystem{S}(x, y, ym) where {S} = new{S}(x, y, ym, GeometryReference[], now())\n    CoordinateSystem{S}(x) where {S} =\n        new{S}(x, GeometryEntity{S}[], Meta[], GeometryReference[], now())\n    CoordinateSystem{S}() where {S} = begin\n        c = new{S}()\n        c.elements = GeometryEntity{S}[]\n        c.meta = Meta[]\n        c.refs = GeometryReference[]\n        c.create = now()\n        c\n    end\nend\n\nA CoordinateSystem has a name and contains geometry entities (Polygons, Rectangles) and references to GeometryStructure objects. It also records the time of its own creation.\n\nTo add elements, use place!, or use render! to be agnostic between CoordinateSystem and Cell. To add references, use addref! or addarr!.\n\n\n\n\n\n","category":"type"},{"location":"coordinate_systems/#DeviceLayout.CoordinateSystems.CoordinateSystemReference","page":"Coordinate Systems","title":"DeviceLayout.CoordinateSystems.CoordinateSystemReference","text":"const CoordinateSystemReference\n\nAlias for StructureReferences to CoordinateSystems.\n\n\n\n\n\n","category":"type"},{"location":"coordinate_systems/#DeviceLayout.CoordinateSystems.CoordinateSystemArray","page":"Coordinate Systems","title":"DeviceLayout.CoordinateSystems.CoordinateSystemArray","text":"const CoordinateSystemArray\n\nAlias for ArrayReferences to CoordinateSystems.\n\n\n\n\n\n","category":"type"},{"location":"coordinate_systems/#DeviceLayout.CoordinateSystems.place!","page":"Coordinate Systems","title":"DeviceLayout.CoordinateSystems.place!","text":"place!(cs::CoordinateSystem, ent::GeometryEntity, metadata)\n\nPlace ent in cs with metadata metadata.\n\n\n\n\n\nplace!(cs::CoordinateSystem, s::GeometryStructure)\n\nPlace a reference to s in cs.\n\n\n\n\n\nplace!(cs::CoordinateSystem, p::Path, metadata=p.metadata)\n\nPlace a reference to p in cs and set metadata to metadata.\n\n\n\n\n\n","category":"function"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"As with a Cell{S}, a CoordinateSystem{S} has a coordinate type parameter S. Unlike Cells, a CoordinateSystem is not tied to a database unit (a GDSII concept).","category":"page"},{"location":"coordinate_systems/#Semantic-metadata-and-rendering-to-cells","page":"Coordinate Systems","title":"Semantic metadata and rendering to cells","text":"","category":"section"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"Since CoordinateSystems are intended to be backend-agnostic, a useful pattern is to give coordinate objects \"semantic\" metadata, consisting of a layer name Symbol as well as level and index attributes. This metadata can then be processed with designer-provided methods when rendering to an output format.","category":"page"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"    SemanticMeta\n    layer\n    layerindex\n    layername\n    level","category":"page"},{"location":"coordinate_systems/#DeviceLayout.SemanticMeta","page":"Coordinate Systems","title":"DeviceLayout.SemanticMeta","text":"struct SemanticMeta <: DeviceLayout.Meta\n    layer::Symbol\n    index::Int = 1\n    level::Int = 1\nend\nSemanticMeta(layer::String; kwargs...)\nSemanticMeta(meta::Meta; kwargs...)\n\nDeviceLayout-native representation of an object's layer information and attributes.\n\nSemantic metadata refers to the meaning of an element without reference to a fixed encoding. For example, “this polygon is in the negative of the ground plane” is semantic, while “this polygon is in GDS layer 1, datatype 2” is not. The semantic metadata is used in the final render step, where a layout is converted from a CoordinateSystem to a representation corresponding to a particular output format (e.g., a Cell for GDSII). A call to render!(cell::Cell{S}, cs::CoordinateSystem; map_meta = identity, kwargs...) will use the map_meta function to map each GeometryEntity's metadata to GDSMeta.\n\nThe level and index fields do not have a strict interpretation imposed by DeviceLayout. (In this sense they are similar to GDS datatype.) The suggested use is as follows:\n\nindex distinguishes numbered instances within a layer, for example in greyscale lithography or port numbering\nlevel distinguishes instances of a layer occurring in different contexts, such as in a 3D stack where equivalent layers may be present in multiple levels\n\n\n\n\n\n","category":"type"},{"location":"coordinate_systems/#DeviceLayout.layer","page":"Coordinate Systems","title":"DeviceLayout.layer","text":"layer(m::Meta)\n\nThe layer specified by m, as a Symbol.\n\nFor example, layer(GDSMeta(1, 2)) is :GDS1_2, and layername(SemanticMeta(:base)) is :base.\n\n\n\n\n\n","category":"function"},{"location":"coordinate_systems/#DeviceLayout.layerindex","page":"Coordinate Systems","title":"DeviceLayout.layerindex","text":"layerindex(m::Meta)\n\nThe index specified by metadata m. Defaults to 1 for metadata types without an index.\n\n\n\n\n\n","category":"function"},{"location":"coordinate_systems/#DeviceLayout.layername","page":"Coordinate Systems","title":"DeviceLayout.layername","text":"layername(m::Meta)\n\nThe layer specified by m, as a String.\n\nFor example, layer(GDSMeta(1, 2)) is \"GDS1_2\", and layername(SemanticMeta(:base)) is \"base\".\n\n\n\n\n\n","category":"function"},{"location":"coordinate_systems/#DeviceLayout.level","page":"Coordinate Systems","title":"DeviceLayout.level","text":"level(m::Meta)\n\nThe level specified by metadata s. Defaults to 1 for metadata types without a level.\n\n\n\n\n\n","category":"function"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"This means that a CoordinateSystem can be rendered to a Cell for output to a GDS format. During rendering, an entity::GeometryEntity with metadata SemanticMeta(:ground_plane) would be mapped to to_polygons(entity) with GDS layer number and datatype (for example, GDSMeta(1,0)) corresponding to the ground plane according to a mapping function map_meta provided to render!.","category":"page"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"    Cell(::CoordinateSystem{S}) where {S}\n    render!(::Cell, ::DeviceLayout.GeometryStructure)","category":"page"},{"location":"coordinate_systems/#DeviceLayout.Cells.Cell-Union{Tuple{CoordinateSystem{S}}, Tuple{S}} where S","page":"Coordinate Systems","title":"DeviceLayout.Cells.Cell","text":"Cell(cs::CoordinateSystem{S}) = Cell{S}(cs)\nCell(cs::CoordinateSystem, unit::CoordinateUnits) = Cell{typeof(1.0unit)}(cs)\nCell{S}(cs::CoordinateSystem) where {S}\n\nConstruct a Cell from a CoordinateSystem by rendering its contents, reproducing the reference hierarchy.\n\n\n\n\n\n","category":"method"},{"location":"coordinate_systems/#DeviceLayout.render!-Tuple{Cell, DeviceLayout.GeometryStructure}","page":"Coordinate Systems","title":"DeviceLayout.render!","text":"render!(cell::Cell{S}, cs::GeometryStructure;\n    memoized_cells=Dict{CoordinateSystem, Cell}(),\n    map_meta = identity,\n    kwargs...) where {S}\n\nRender a geometry structure (e.g., CoordinateSystem) to a cell.\n\nPasses each element and its metadata (mapped by map_meta if a method is supplied) to render!(::Cell, element, ::Meta), traversing the references such that if a CoordinateSystem is referred to in multiple places, it will become a single cell referred to in multiple places.\n\nRendering a GeometryEntity to a Cell uses the optional keyword arguments\n\nmap_meta, a function that takes a Meta object and returns another Meta object (or nothing, in which case rendering is skipped)\n\nUsage note: calling this function with non-empty dictionary memoized_cells = Dict{CoordinateSystem, Cell}(cs => cell) is effectively a manual override that forces cs to render as cell.\n\n\n\n\n\n","category":"method"},{"location":"coordinate_systems/","page":"Coordinate Systems","title":"Coordinate Systems","text":"Note that Cells inherit the names of rendered CoordinateSystems, so the original coordinate systems ought to have unique names (for example using uniquename).","category":"page"},{"location":"schematicdriven/pdks/#Process-Design-Kit","page":"PDKs","title":"Process Design Kit","text":"","category":"section"},{"location":"schematicdriven/pdks/","page":"PDKs","title":"PDKs","text":"A process design kit (PDK) defines process-specific tools used to assemble designs for fabrication. For example, a typical PDK defines a set of layer names along with the GDS layer and datatype for each of those names. It also defines a set of components using those layers.","category":"page"},{"location":"schematicdriven/pdks/","page":"PDKs","title":"PDKs","text":"In DeviceLayout.jl terms, a PDK would define a layer record mapping names to GDS metadata, as well as a ProcessTechnology and Target for each desired method of creating artwork and simulation files from schematics:","category":"page"},{"location":"schematicdriven/pdks/","page":"PDKs","title":"PDKs","text":"module MyPDK\nusing DeviceLayout, DeviceLayout.SchematicDrivenLayout, DeviceLayout.PreferredUnits\n\nconst my_layer_record = (;\n    metal=GDSMeta(0, 0),\n    dielectric=GDSMeta(1, 0),\n    chip_area=GDSMeta(100, 0),\n    simulated_area=GDSMeta(200, 0)\n    # ...\n)\n\nconst my_process_params = (; # From ExamplePDK: Unrealistic thicknesses for clearer visualizations\n    chip_thicknesses=[100μm, 100μm], # [Bottom chip, top chip] (for calculating z height by level)\n    flipchip_gaps=[80μm], # Space between chip surfaces (for calculating z height by level)\n    height=(; simulated_area=-1mm), # z height at the bottom of simulation volume\n    thickness=(; # Extrusion distances for various layers\n        simulated_area=2mm,\n        dielectric=[2μm, 5μm], # For levelwise layers, specify thickness for each level\n        chip_area=[100μm, 100μm]\n        # ...\n    )\n    # ...\n)\n\nconst MyFlipchipProcess = ProcessTechnology(my_layer_record, my_process_params)\n\nconst BottomChipTarget = ArtworkTarget(MyFlipchipProcess, levels=[1])\nconst TopChipTarget = ArtworkTarget(MyFlipchipProcess, levels=[2])\nconst SimulationTarget = SolidModelTarget(\n    MyFlipchipProcess;\n    bounding_layers=[:simulated_area],\n    substrate_layers=[:chip_area],\n    levelwise_layers=[:chip_area],\n    simulation=true\n)\nend","category":"page"},{"location":"schematicdriven/pdks/","page":"PDKs","title":"PDKs","text":"A DeviceLayout.jl PDK would also define any Components to be used in building schematics. We provide ExamplePDK as a module within DeviceLayout.jl as an example.","category":"page"},{"location":"schematicdriven/pdks/","page":"PDKs","title":"PDKs","text":"One way we recommend organizing your own PDK for use with DeviceLayout.jl is as a single version-controlled repository, with a MyPDK.jl package at the top level, defining a module like the above snippet, and independently versioned component packages in a subdirectory. For example:","category":"page"},{"location":"schematicdriven/pdks/","page":"PDKs","title":"PDKs","text":"MyPDK/\n├─ Project.toml\n├─ README.md\n├─ ...\n├─ components/\n│  ├─ MyInterdigitalCapacitors/\n│  │  ├─ Project.toml\n│  │  ├─ README.md\n│  │  ├─ src/\n│  │  │  └─ MyInterdigitalCapacitors.jl\n│  │  ├─ examples/\n│  │  │  └─ example.jl\n│  │  └─ test/\n│  ├─ MyMeanderInductors/\n│  ├─ MySpiralInductors/\n│  └─ ...\n├─ src/\n│  └─ MyPDK.jl\n└─ test/","category":"page"},{"location":"schematicdriven/pdks/","page":"PDKs","title":"PDKs","text":"MyPDK.jl would have DeviceLayout.jl as a dependency, and each component package would depend on MyPDK.jl (and possibly other components) for layer names and other information or functionality held in common.","category":"page"},{"location":"schematicdriven/pdks/","page":"PDKs","title":"PDKs","text":"Here, component packages have their own Project.toml file distinct from MyPDKPackage because they are separate packages despite living in the same repository. Like with all Julia packages it is not advised to actually commit Manifest.toml files, although it is useful to commit them to one-off \"projects\" like analyses and layout scripts to enable fully reproducible environments.","category":"page"},{"location":"schematicdriven/pdks/","page":"PDKs","title":"PDKs","text":"This structure can be combined with LocalRegistry to make the PDK and component packages available from a private registry. Doing so allows you to use the full power of the Julia package manager by versioning physical designs using semantic versioning, seamlessly tracking and switching between versions as needed.","category":"page"},{"location":"schematicdriven/components/#Components","page":"Components","title":"Components","text":"","category":"section"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"SchematicDrivenLayout.AbstractComponent\nSchematicDrivenLayout.Component","category":"page"},{"location":"schematicdriven/components/#DeviceLayout.AbstractComponent","page":"Components","title":"DeviceLayout.AbstractComponent","text":"abstract type AbstractComponent{T} <: GeometryStructure{T}\n\nA parameterized layout element, to be used as a building block in schematic-driven design.\n\nThe alias Component = AbstractComponent{typeof(1.0nm)} is provided for convenience.\n\nEach AbstractComponent comes with the necessary parameters and methods to render its geometry and to attach it to other components in a schematic. Something similar to this concept may be familiar from other electronic design automation tools as a PCell (\"parameterized cell\").\n\nYou might call something a component if you would include it in a schematic or diagram rather than abstracting it away, if it can be described as a black box with ports, or if you might want to simulate it independently. For example, a series interdigital capacitor could be defined as a AbstractComponent, with attachment points (Hooks) at the end of each lead.\n\nAbstractComponents provide a common interface:\n\nname(c::MyComponent): The name of the component.\nparameters(c::MyComponent): The parameters of the component as a NamedTuple.\ngeometry(c::MyComponent): A coordinate system containing c's rendered geometry.\nhooks(c::MyComponent): A NamedTuple of Hooks and Hook arrays that specify how connections are made with c.\nhooks(c::MyComponent, h::Symbol): The specific hook identified by h.\ndefault_parameters(c::Union{MyComponent, Type{MyComponent}}): Default parameters as a NamedTuple.\nparameter_names(c::Union{MyComponent, Type{MyComponent}}): Parameter names as a collection of Symbols.\nA keyword constructor that merges keyword arguments into default_parameters non-recursively. (That is, a NamedTuple keyword argument will overwrite the default parameter entirely, meaning every \"subparameter\" in the NamedTuple needs to be specified.)\ncreate_component(::Type{MyComponent}, name::String=default_parameters(MyComponent).name, base_parameters::NamedTuple=default_parameters(MyComponent); kwargs...): Constructor that recursively merges kwargs into base_parameters. (That is, a NamedTuple keyword argument will be merged into the corresponding NamedTuple base parameter, meaning not every \"subparameter\" needs to be fully specified.)\nset_parameters(mycomp::MyComponent, name::String=name(mycomp), params::NamedTuple=parameters(c); kwargs...): Shorthand for create_component using mycomp for base parameters\n(mycomp::MyComponent)(name::String=name(mycomp), params::NamedTuple=parameters(mycomp)=; kwargs...): Shorter shorthand for the above\n\nSince AbstractComponent is a subtype of GeometryStructure, they can also be referenced by a StructureReference. Other GeometryStructure interface methods, including elements, element_metadata, refs, flatten,  footprint, halo, and transform operate on geometry(mycomp).\n\nThe name of a component is not guaranteed to be unique. Instances of components within schematics as well as coordinate systems within a layout will always have unique identifiers, which are automatically constructed from a component's name using uniquename if it is not already unique. For this reason, it is often best for designers to give important components unique names, guaranteeing that the corresponding identifiers are the same.\n\n\n\n\n\n","category":"type"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.Component","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.Component","text":"const Component = AbstractComponent{typeof(1.0UPREFERRED)}\n\nComponent is an alias for AbstractComponent with the coordinate type typeof(1.0UPREFERRED).\n\nDeviceLayout.UPREFERRED is a constant set according to the unit preference in Project.toml or LocalPreferences.toml. The default (\"PreferNanometers\") gives const UPREFERRED = DeviceLayout.nm, with mixed-unit operations preferring conversion to nm.\n\n\n\n\n\n","category":"type"},{"location":"schematicdriven/components/#Defining-components","page":"Components","title":"Defining components","text":"","category":"section"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"The recommended way to define a component is the @compdef macro, which specifies the parameters names and defaults as part of the struct definition. It creates the keyword constructor (like Base.@kwdef does) as well as the default_parameters method that are required to allow the above interface to work.","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"SchematicDrivenLayout.@compdef","category":"page"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.@compdef","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.@compdef","text":"@compdef typedef\n\nThis is a helper macro that extends Base.@kwdef, which automatically defines a keyword-based constructor for the type declared in the expression typedef, which must be a struct or mutable struct expression. The default argument is supplied by declaring fields of the form field::T = default or field = default. If no default is provided then the keyword argument becomes a required keyword argument in the resulting type constructor. Inner constructors can still be defined, but at least one should accept arguments in the same form as the default inner constructor (i.e. one positional argument per field) in order to function correctly with the keyword outer constructor.\n\nThis generates a default_parameters method for the defined type, which returns the default parameters as a NamedTuple. If any parameters are required (have no default), they do not appear in default_parameters.\n\nThe new type will also have a _geometry field for caching geometry, or _graph and _schematic fields for composite components. Note that if you want to use your own abstract composite supertype you should define SchematicDrivenLayout.iscomposite(::Val{:MyAbstractCompositeComponent}) = true.\n\nExamples\n\njulia> @compdef struct MyComp <: Component\n           name::String = \"mycomp\"\n           a::Int = 1         # specified default\n           b::String          # required keyword\n       end\n\njulia> default_parameters(MyComp)\n(name = \"mycomp\", a = 1)\n\n\n\n\n\n","category":"macro"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"An AbstractComponent should include a name field, and also implement the following specializations:","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"_geometry!(cs::CoordinateSystem, comp::MyComponent): Render the component's geometry to a CoordinateSystem cs.\nhooks(::MyComponent): a NamedTuple of Hooks and/or Vector{Hook}s that specify where and how attachments are made","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"Validation or reconciling of parameters should be done in an inner constructor. At least one inner constructor should accept arguments in the same form as the default inner constructor (i.e. one positional argument per field) in order to function correctly with the keyword outer constructor.","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"An AbstractComponent may also override GeometryStructure methods like footprint and halo.","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"The methods check_rotation and allowed_rotation_angles can be implemented to enforce a requirement for the orientation of the component in the global coordinate system:","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"SchematicDrivenLayout.check_rotation\nSchematicDrivenLayout.allowed_rotation_angles","category":"page"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.check_rotation","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.check_rotation","text":"check_rotation(::AbstractComponent)\n\nDetermines whether the global orientation of a component will be checked by check!(::Schematic). check_rotation(::AbstractComponent) returns false, so any components of type T requiring rotation checks must overload this method as check_rotation(::T) = true. Checkable components must also overload the method allow_rotation_angles(::T).\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.allowed_rotation_angles","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.allowed_rotation_angles","text":"allowed_rotation_angles(::AbstractComponent)\n\nReturn a vector of allowed rotation angles. If the net rotation of a component in a planned Schematic (the rotation of its native axes relative to the axes of the global coordinate system) matches a number in this list, the component passes the check.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"Finally, an AbstractComponent may define methods to specify default hooks for fusion with other components in a schematic:","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"matching_hooks(::MyComponent1, ::MyComponent2)\nmatching_hooks(::MyComponent2, ::MyComponent1)\nmatching_hook(::MyComponent1, hook1::Symbol, ::MyComponent2)\n...","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"Methods for both argument orders in matching_hooks should generally be defined. Although SchematicGraphs are undirected, certain components may treat the different argument orders differently. For example, matching_hooks(::Path, <:AbstractComponent) will attach the second argument to the endpoint hook :p1 on the Path, while the reverse order will attach the start point hook :p0 to the first argument.","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"SchematicDrivenLayout.matching_hooks\nSchematicDrivenLayout.matching_hook","category":"page"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.matching_hooks","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.matching_hooks","text":"matching_hooks(c1::S, c2::T) where {S <: AbstractComponent, T <: AbstractComponent}\n\nReturn the hooks on c1 and c2 that should be fused together (as a Tuple{Symbol,Symbol}).\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.matching_hook","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.matching_hook","text":"matching_hook(c1::S, h1::Symbol, c2::T) where {S <: AbstractComponent, T <: AbstractComponent}\n\nReturn the hook on c2 that goes with h1 on c1 (as a Symbol).\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"Components support the following API:","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"SchematicDrivenLayout.geometry\nSchematicDrivenLayout.hooks\nSchematicDrivenLayout.default_parameters\nhalo(::SchematicDrivenLayout.AbstractComponent, ::Any, ::Any)\nSchematicDrivenLayout.name(::SchematicDrivenLayout.AbstractComponent)\nSchematicDrivenLayout.non_default_parameters\nSchematicDrivenLayout.parameters\nSchematicDrivenLayout.parameter_names","category":"page"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.geometry","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.geometry","text":"geometry(comp::AbstractComponent)\n\nA CoordinateSystem containing the AbstractComponent's geometry with metadata.\n\nThe result for each unique comp (by ===) is memoized.\n\nThe result has result.name == uniquename(name(comp)).\n\n\n\n\n\ngeometry(cc:AbstractCompositeComponent)\n\nReturn the CoordinateSystem resulting from build!(plan(graph(cc))).\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/components/#DeviceLayout.hooks","page":"Components","title":"DeviceLayout.hooks","text":"hooks(pa::Path)\n\n:p0: A HandedPointHook looking into the start of path pa.\n:p1: A HandedPointHook looking into the end of path pa.\n:p0_lh: A left-handed HandedPointHook looking into the start of path pa.\n:p1_lh: A left-handed HandedPointHook looking into the end of path pa.\n\n\n\n\n\nhooks(rres::ExampleClawedMeanderReadout)\n\nHooks for attaching a readout resonator claw to a qubit and coupling section to a feedline.\n\nqubit: The \"palm\" of the claw on the outside edge of the \"shield\". Matches (eq::ExampleRectangleTransmon) => :rres.\nfeedline: A distance coupling_gap from the edge of the ground plane, vertically aligned with the claw.\n\n\n\n\n\nhooks(sch::Schematic, node::ComponentNode)\n\nThe hooks belonging to the component in node in the global coordinate system of sch.\n\n\n\n\n\nhooks(comp::AbstractComponent)\n\nA component's Hooks (a set of locations and rules for attaching to other components).\n\nReturns a NamedTuple of Hooks and/or arrays of Hooks for a AbstractComponent instance. To access a Hook directly whether or not it's in an array, use hooks(::AbstractComponent, ::Symbol).\n\n\n\n\n\nhooks(comp::AbstractComponent, h::Symbol)\n\nA component's Hook identified by h.\n\nPreferred way to retrieve a hook over accessing the NamedTuple directly (hooks(comp).h). Allows access to hooks in arrays by interpreting :hookname_i as hooks(comp).hookname[i] if :hookname_i is not itself a key in hooks(comp).\n\n\n\n\n\nhooks(cc::AbstractCompositeComponent)\n\nHooks for the composite geometry, placed at corresponding hooks of the subcomponents.\n\nHooks\n\nA hook hcc is returned for each hook (name h) of every subcomponent node (index i). If keys(map_hooks(cc)) contains i => h, then the corresponding composite hook is map_hooks(cc)[h]. Otherwise, it is _$(i)_$h.\n\n\n\n\n\nhooks(cc::AbstractCompositeComponent, subcompname::String, h::Symbol)\n\nAttempts to retrieve the composite hook corresponding to hook h of a Component with name subcompname (either its unique name or its name parameters). Will emit an error if the name is ambiguous.\n\n\n\n\n\nhooks(cc::AbstractCompositeComponent, i::Int, h::Symbol)\nhooks(cc::AbstractCompositeComponent, (i=>h)::Pair{Int, Symbol})\n\nThe composite hook corresponding to hook h of components(cc)[i].\n\n\n\n\n\nhooks(::ExampleRectangleTransmon)\n\nHooks for attaching control lines and readout to the transmon.\n\nreadout: The center edge of the ground plane on the opposite side of the island from the SQUID.\nxy: The left side of the capacitor gap.\nz: The center edge of the ground plane in the SQUID loop.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.default_parameters","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.default_parameters","text":"default_parameters(::Type{T}) where T <: AbstractComponent\ndefault_parameters(::T) where T <: AbstractComponent\n\nA NamedTuple of default parameters for component type T.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/components/#DeviceLayout.halo-Tuple{DeviceLayout.AbstractComponent, Any, Any}","page":"Components","title":"DeviceLayout.halo","text":"halo(c::AbstractComponent, delta, inner_delta=nothing; only_layers=[], ignore_layers=[])\n\nA component's halo, intended for use as an exclusion zone parameterized by a bias delta.\n\nBy default, this applies a delta halo to all geometry elements whose metadata matches the inclusion/exclusion requirements. For example, polygons are offset by delta (enlarged by growing delta away from each original edge). Any entities in layers in ignore_layers will be skipped. If only_layers is not empty, only those layers will be used to generate the halo. Layers for inclusion and exclusion can be provided as layer name Symbols, in which case only the layer name needs to be matched, or as full DeviceLayout.Meta objects, in which case all metadata fields (e.g., index and level for SemanticMeta) must match.\n\nAn inner_delta may be specified to subtract the halo at that bias from the result.\n\nAbstractComponents may define their own halo methods.\n\n\n\n\n\n","category":"method"},{"location":"schematicdriven/components/#DeviceLayout.name-Tuple{DeviceLayout.AbstractComponent}","page":"Components","title":"DeviceLayout.name","text":"name(comp::AbstractComponent)\n\nThe component's name.\n\n\n\n\n\n","category":"method"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.non_default_parameters","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.non_default_parameters","text":"non_default_parameters(c::AbstractComponent)\n\nA NamedTuple of the parameters of c that were set to values other than their defaults.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/components/#DeviceLayout.parameters","page":"Components","title":"DeviceLayout.parameters","text":"parameters(comp::AbstractComponent)\n\nThe component's NamedTuple of parameters.\n\n\n\n\n\nparameters(cc::BasicCompositeComponent)\n\nRetrieve the parameters set indirectly by cc's internal SchematicGraph:\n\nname: g.name, from which the component's unique name is generated\nsub_parameters: A tuple of NamedTuples containing the subcomponent parameters in order\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.parameter_names","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.parameter_names","text":"parameter_names(::Type{T}) where T <: AbstractComponent\nparameter_names(::T) where T <: AbstractComponent\n\nParameter name Symbols for component type T.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"Components can be created by several methods. In addition to the keyword constructor, the create_component and set_parameters method allow the use of a set of base parameters or a prototype component to effectively provide a new set of defaults. The @component macro can also be used with either a component type or an instance.","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"SchematicDrivenLayout.@component\nSchematicDrivenLayout.create_component\nSchematicDrivenLayout.set_parameters","category":"page"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.@component","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.@component","text":"@component comp = MyComponent param1=val1 param2=val2 ...\n@component comp = MyComponent begin\n    param1 = val1\n    param2 = val2\n    ...\nend\n@component comp[1:10] = MyComponent begin \n    param1 .= vals1_vec\n    param2 = val2\n    ...\nend\n@component comp[1:10, 1:10] = MyComponent begin\n    param1 .= vals1_arr\n    param2 = val2\n    ...\nend\n\nCreate a Component or vector of components with specified name and parameters.\n\nFor a single component, the symbol on the left-hand side is passed as the name of the component. Parameters can be provided like keyword arguments on the same line or in a block (multiple lines enclosed by begin and end).\n\nIf the left-hand side is written as comp[1:n], then comp will be an array of n components with names comp1, comp2, ..., comp$n. A parameter can be passed to all instances using the same syntax as for a single component, or each component can be passed its parameter out of a vector of parameters values vals_vec by using broadcast assignment (param .= vals_vec).\n\nSimilarly, multidimensional arrays of components can be created using @component comp[1:m, 1:n].\n\nA component instance can also be used in place of the component type, in which case the \"default\" values for unspecified parameters will be those of that component.\n\n\n\n\n\n","category":"macro"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.create_component","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.create_component","text":"create_component(\n    ::Type{T},\n    name::String=default_parameters(T).name,\n    base_parameters::NamedTuple=default_parameters(T);\n    kwargs...\n) where {T <: AbstractComponent}\n\nCreate an instance of type T with name name and parameters derived by merging kwargs into base_parameters.\n\nThe parameter merge is recursive, meaning that a NamedTuple keyword argument will be merged into the corresponding NamedTuple base parameter. This can be convenient because not every \"subparameter\" within that NamedTuple needs to be specified. This is in contrast to the default component keyword constructor, which does not merge recursively.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.set_parameters","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.set_parameters","text":"set_parameters(\n    c::AbstractComponent,\n    name::String=name(c),\n    params::NamedTuple=parameters(c);\n    kwargs...\n)\n\nCreate an instance of type typeof(c) with name name and parameters derived by merging kwargs into `params.\n\nThe parameter merge is recursive, meaning that a NamedTuple keyword argument will be merged into the corresponding NamedTuple base parameter. This can be convenient because not every \"subparameter\" within that NamedTuple needs to be specified. This is in contrast to the default component keyword constructor, which does not merge recursively.\n\nThis can also be written by calling the component instance c like a function: c(name, params; kwargs...).\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/components/#Built-in-components","page":"Components","title":"Built-in components","text":"","category":"section"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"We provide some other predefined components that may be generally useful.","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"SchematicDrivenLayout.ArrowAnnotation\nSchematicDrivenLayout.BasicComponent\nSchematicDrivenLayout.GDSComponent\nSchematicDrivenLayout.Spacer\nSchematicDrivenLayout.WeatherVane","category":"page"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.ArrowAnnotation","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.ArrowAnnotation","text":"struct ArrowAnnotation{T} <: AbstractComponent{T}\n    name::String = \"arrow\"\n    length = 0.032mm\n    width = 0.005mm\n    text::String = \"\"\n    textsize = 0.025mm\n    meta = SemanticMeta(:annotation)\nend\n\nAn arrow with a given length and width along with a text annotation in the layer given by meta.\n\nHooks\n\nnock: The base of the arrow, with inward direction along the arrow\ntip: The tip of the arrow, with inward direction opposite the arrow\n\n\n\n\n\n","category":"type"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.BasicComponent","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.BasicComponent","text":"struct BasicComponent{T} <: AbstractComponent{T}\nBasicComponent(cs::CoordinateSystem{T}, hooks=(;))\n\nA simple AbstractComponent that acts as a lightweight wrapper for a CoordinateSystem.\n\nThe component geometry is a fixed CoordinateSystem, provided to the constructor along with hooks.\n\n\n\n\n\n","category":"type"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.GDSComponent","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.GDSComponent","text":"struct GDSComponent{T} <: AbstractComponent{T}\n    name::String\n    cell::Cell{T}\n    hooks::NamedTuple\n    meta::DeviceLayout.Meta\nend\n\nA component with geometry corresponding to an explicit Cell.\n\nThe meta field does not affect metadata inside the Cell, but can still be used by a LayoutTarget to decide whether the component should be rendered or not.\n\nHooks are supplied by the user, with a default of compass().\n\n\n\n\n\n","category":"type"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.Spacer","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.Spacer","text":"Spacer{T} <: AbstractComponent{T}\n\nProvides an 8-point compass of hooks at each of two points separated by p1.\n\nParameters\n\np1: The endpoint of the spacer\n\nHooks\n\np0_east: Hook at the origin, with in_direction pointing \"east\" (positive x direction)\np0_northeast\np0_north\n...\np0_southeast\np1_east: Hook at p1, with in_direction pointing \"east\" (positive x direction)\np1_northeast\n...\np1_southeast\n\n\n\n\n\n","category":"type"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.WeatherVane","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.WeatherVane","text":"WeatherVane{T} <: AbstractComponent{T}\n\nA component with empty geometry and an 8-point compass of hooks at the origin.\n\n\n\n\n\n","category":"type"},{"location":"schematicdriven/components/#Paths-as-components","page":"Components","title":"Paths as components","text":"","category":"section"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"Another component already showed up in geometry-level layout: DeviceLayout.Path is an AbstractComponent with hooks p0 and p1 corresponding to its start and end. Path supports the interface described above and can be added directly to a schematic just like any other component.","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"DeviceLayout.hooks(::Path) ","category":"page"},{"location":"schematicdriven/components/#DeviceLayout.hooks-Tuple{Path}","page":"Components","title":"DeviceLayout.hooks","text":"hooks(pa::Path)\n\n:p0: A HandedPointHook looking into the start of path pa.\n:p1: A HandedPointHook looking into the end of path pa.\n:p0_lh: A left-handed HandedPointHook looking into the start of path pa.\n:p1_lh: A left-handed HandedPointHook looking into the end of path pa.\n\n\n\n\n\n","category":"method"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"Recall that Path supports a geometry-level attach! method that can place references to other structures along it. It also supports a schematic-level attach! with a similar syntax, which positions components along the path by defining an edge in the schematic graph.","category":"page"},{"location":"schematicdriven/components/#Composite-components","page":"Components","title":"Composite components","text":"","category":"section"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"A \"composite\" component is one that's at least partly made up of other components. Nothing stops you from \"baking in\" subcomponents in your component's geometry function by deriving parameters and getting geometries for those subcomponents yourself. You could even construct a SchematicGraph then plan, check!, and build! it to get a coordinate system of subcomponents fused together. But in that case, your top-level schematic won't know anything about what's inside your composite component.","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"As an alternative, we define abstract type AbstractCompositeComponent <: AbstractComponent, which is minimally a Component with a graph(cc::MyCompositeComponent) method that produces a SchematicGraph of the subcomponents it's made from, such that the composite component's geometry is just build!(plan(graph(cc))).","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"SchematicDrivenLayout provides a concrete composite component: BasicCompositeComponent, which is really just a graph defined by the user and wrapped in a Component. It maps parameters and hook names exposed by the composite component by prefixing their names with _i_, where i is the index of the subcomponent node in graph(cc).","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"A new subtype of CompositeComponent can be defined to use a custom reparameterization and mapping of hook names in the subgraph.","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"SchematicDrivenLayout.AbstractCompositeComponent\nSchematicDrivenLayout.CompositeComponent\nSchematicDrivenLayout.BasicCompositeComponent\nSchematicDrivenLayout.components(::SchematicDrivenLayout.CompositeComponent)\nSchematicDrivenLayout.flatten(::SchematicDrivenLayout.SchematicGraph)\nSchematicDrivenLayout.graph\nSchematicDrivenLayout.map_hooks","category":"page"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.AbstractCompositeComponent","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.AbstractCompositeComponent","text":"abstract type AbstractCompositeComponent{T} <: AbstractComponent{T}\n\nA Component with geometry derived from that of a SchematicGraph of subcomponents.\n\nThe alias CompositeComponent = AbstractCompositeComponent{typeof(1.0nm)} is provided for convenience.\n\nA standard Component c is described by its geometry(c), parameters(c), and hooks(c). In contrast, a CompositeComponent cc also has parameters, but is otherwise described at the level of graph(cc) and map_hooks(cc), which define a relationship between the CompositeComponent and the geometry and hooks of its subcomponents.\n\nIf a SchematicGraph g contains a node with a CompositeComponent, then the subgraph graph(cc) will be accessible to inspection tools for g. For example, find_components can return nodes in the subgraph. You can also flatten!(g) to simply replace cc's node with graph(cc).\n\nThe list of subcomponents in the graph can be obtained with components(cc) (equivalent to components(graph(cc))).\n\nIn order to take advantage of this interface, the implementation of a CompositeComponent should contain the following fields, in order:\n\nparameters::NamedTuple: A collection of parameters\n\nA CompositeComponent must also implement the following specializations:\n\n_build_subcomponents: Returns a Tuple of subcomponents\n_graph!(g::SchematicGraph, cc::MyComponent, subcomps::NamedTuple): Populates and connects the schematic graph corresponding to cc, where subcomps contains the results of _build_subcomponents keyed by name\nmap_hooks(::Type{MyComponent}): A Dict{Pair{Int, Symbol}, Symbol mapping subcomponent hooks to hooks presented by the composite component.\n\nValidation or reconciling of parameters should be done in an inner constructor that replaces the default inner constructor.\n\nIf you define your own abstract composite component subtype you should define SchematicDrivenLayout.iscomposite(::Val{:MyAbstractCompositeComponent}) = true to allow the @compdef macro to recognize that the component is composite.\n\n\n\n\n\n","category":"type"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.CompositeComponent","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.CompositeComponent","text":"const CompositeComponent = AbstractCompositeComponent{typeof(1.0UPREFERRED)}\n\nCompositeComponent is an alias for AbstractCompositeComponent with the coordinate type typeof(1.0UPREFERRED).\n\nDeviceLayout.UPREFERRED is a constant set according to the unit preference in Project.toml or LocalPreferences.toml. The default (\"PreferNanometers\") gives const UPREFERRED = DeviceLayout.nm, with mixed-unit operations preferring conversion to nm.\n\n\n\n\n\n","category":"type"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.BasicCompositeComponent","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.BasicCompositeComponent","text":"struct BasicCompositeComponent{T} <: AbstractCompositeComponent{T}\n\nA simple AbstractCompositeComponent that acts as a lightweight wrapper for a SchematicGraph.\n\nThe component scc = BasicCompositeComponent(g::SchematicGraph) copies g and generates its geometry as build!(check!(plan(g))).\n\nhooks(scc) returns a NamedTuple with the hook h of the ith subcomponent as _i_h.\n\nParameters are set indirectly by the internal SchematicGraph:\n\nname: g.name, from which the component's unique name is generated\nsub_parameters: A tuple of NamedTuples containing the subcomponent parameters in order\n\nA BasicCompositeComponent instance can also be used as a constructor, taking the argument param_sets (a tuple of parameters for each subcomponent, in order), along with keyword arguments _i_param for a parameter named param in subcomponent i. Default values are provided by the components in g.\n\n    (cc::BasicCompositeComponent)(\n        param_sets::Tuple = ();\n        kwargs...)\n\nCreate a version of cc with different subcomponent parameters.\n\nArgument param_sets is a tuple of NamedTuples containing each subcomponent's parameters. If it is not empty, it must have a NamedTuples for each subcomponent, even an empty one.\n\nKeyword arguments are _i_param for a parameter named param in subcomponent i. Default values are provided by the components in g.\n\n\n\n\n\n","category":"type"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.components-Tuple{DeviceLayout.SchematicDrivenLayout.CompositeComponent}","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.components","text":"components(cc::AbstractCompositeComponent)\n\nA list of the components in the subgraph of cc. Equivalent to components(graph(cc))\n\nUnlike subcomponents, components will return a component for every node, even if multiple nodes use the same component.\n\n\n\n\n\n","category":"method"},{"location":"schematicdriven/components/#DeviceLayout.flatten-Tuple{DeviceLayout.SchematicDrivenLayout.SchematicGraph}","page":"Components","title":"DeviceLayout.flatten","text":"flatten(g::SchematicGraph; depth=-1)\n\nCreate a copy of g with all AbstractCompositeComponents replaced by their graphs.\n\nFor non-composite components, the identical ComponentNodes will be preserved.\n\nKeywords\n\ndepth: How many times to iteratively flatten top-level AbstractCompositeComponents. If negative, will repeat until no AbstractCompositeComponents remain.\n\n\n\n\n\n","category":"method"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.graph","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.graph","text":"graph(cc::AbstractCompositeComponent)\n\nThe SchematicGraph represented by cc.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.map_hooks","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.map_hooks","text":"map_hooks(cc::AbstractCompositeComponent)\nmap_hooks(cc::Type{<:AbstractCompositeComponent})\n\nA Dict{Pair{Int, Symbol}, Symbol} mapping subcomponent hooks to composite hooks.\n\nFor example, the entry (2 => :readout) => :readout_2 means the readout hook for the subcomponent in graph(cc)'s node 2 will be available as hooks(cc).readout_2 in the composite geometry.\n\nSubcomponent Hooks that are not mapped will still be available as :_$(i)_$h, where i is the subcomponent's node index in graph(cc) and h is the hook name. In other words, the above example would have the fallback default :_2_readout.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/components/#Modifying-components","page":"Components","title":"Modifying components","text":"","category":"section"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"Sometimes we want to use components in ways the component designer didn't predict. For example, we might want to draw a Qubit component on the top chip in a flipchip assembly, but the metadata in the generated geometry corresponds to the bottom chip.","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"There are a couple ways to do this concisely. One is to take a Qubit and run map_metadata! on it:","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"q = Qubit()\nmap_metadata!(q, facing)","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"This applies facing to each piece of metadata in geometry(q). Any function of metadata that returns metadata can be used as the second argument, so if you only wanted to flip the :jj layer, you could write map_metadata!(q, m -> layer(m) == :jj ? facing(m) : m).","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"Note that geometry(q) is associated only with q, and changes to it are not tracked elsewhere. If, in a later step, you were to apply junction width corrections by replacing q with q2 = typeof(q)(; parameters(q)..., jj_width=new_width), then q2 would not be on the flip chip.","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"For larger changes, we can make a new Component type. Rather than copy the Qubit definition and find-and-replace its metadata, we can use the @variant macro.","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"@variant FlipchipQubit Qubit map_meta = facing\nfq = FlipchipQubit()\nall(level.(element_metadata(geometry(fq))) .== 2)","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"This creates a new type, FlipchipQubit, and automatically defines the required methods for Component implementation using the Qubit implementation. It has the same default_parameters, hooks, and almost the same _geometry!. Since we supplied the optional keyword map_meta, the geometry method for the new type creates a Qubit and then applies facing to each element (and referenced structure, recursively), as in the map_metadata! example above. But unlike with using map_metadata! on a single Qubit instance, you can replace fq with another typeof(fq) without losing the level information.","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"You can also go further with manual modifications. You could add a cutout on the bottom chip, along with a parameter to control the size of the cutout:","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"@variant CutoutFlipchipQubit Qubit map_meta = facing new_defaults = (; cutout_margin=20μm)\nfunction SchematicDrivenLayout._geometry!(cs::CoordinateSystem, fq::CutoutFlipchipQubit)\n    _geometry!(cs, base_variant(fq)) # base_variant gives you the equivalent `Qubit`\n    map_metadata!(cs, facing)\n    # The above lines are what we would get from @variant Qubit map_meta=facing\n    # Below, we add a cutout on the bottom chip\n    return place!(cs, offset(bounds(cs), parameters(fq).cutout_margin)[1], BASE_NEGATIVE)\nend","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"Note that if Qubit were a CompositeComponent, we would have to use the macro @composite_variant instead.","category":"page"},{"location":"schematicdriven/components/","page":"Components","title":"Components","text":"SchematicDrivenLayout.base_variant\nSchematicDrivenLayout.flipchip!\nSchematicDrivenLayout.@variant\nSchematicDrivenLayout.@composite_variant","category":"page"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.base_variant","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.base_variant","text":"base_variant(comp::AbstractComponent)\n\nIf comp is a @variant of some other component type T <: AbstractComponent, return an instance of T with the same name as comp; otherwise, return comp.\n\nWhen the base component shares a parameter with comp, then in the returned component, that parameter will take the value it has in comp.\n\n\n\n\n\nbase_variant(comptype::Type{<:AbstractComponent})\n\nIf comptype is a @variant of some other component type T <: AbstractComponent, return T; otherwise, return comptype.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.flipchip!","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.flipchip!","text":"flipchip!(geom::GeometryStructure)\n\nMap all metadata in geom to facing copies. Recursive on referenced structures.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.@variant","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.@variant","text":"@variant NewType BaseType new_defaults=(;) map_meta=nothing\n\nCreate NewType <: AbstractComponent based on BaseType, with optional new_defaults and map_meta.\n\nDefault parameters for the new type will be new_defaults merged into default_parameters(T). You can override the original defaults or add entirely new parameters this way.\n\nIf provided, map_meta should be a function of DeviceLayout.Meta that returns another DeviceLayout.Meta. It will be applied recursively to the geometry of the base component using map_metadata!.\n\nIndividual methods like hooks and _geometry! can then be overridden to create variant behavior.\n\n\n\n\n\n","category":"macro"},{"location":"schematicdriven/components/#DeviceLayout.SchematicDrivenLayout.@composite_variant","page":"Components","title":"DeviceLayout.SchematicDrivenLayout.@composite_variant","text":"@composite_variant NewType BaseType new_defaults=(;) map_meta=nothing\n\nCreate NewType <: AbstractCompositeComponent based on BaseType, with optional new_defaults and map_meta.\n\nDefault parameters for the new type will be new_defaults merged into default_parameters(T).\n\nIf provided, map_meta should be a function of DeviceLayout.Meta that returns another DeviceLayout.Meta. It will be applied recursively to the geometry of the base component using map_metadata!.\n\nIndividual methods like hooks and _geometry! can then be overridden to create variant behavior.\n\n\n\n\n\n","category":"macro"},{"location":"schematicdriven/#Schematic-driven-design","page":"Overview","title":"Schematic-driven design","text":"","category":"section"},{"location":"schematicdriven/","page":"Overview","title":"Overview","text":"SchematicDrivenLayout provides an interface for schematic-driven design, intended to","category":"page"},{"location":"schematicdriven/","page":"Overview","title":"Overview","text":"Support a formal schematic-level description of a device\nMake placing and connecting components and routing wires easier and more automated\nAllow inspection/analysis/modification of a design at a higher level\nKeep layers of abstraction separate, except for deliberate abstraction-breaking \"escape hatches\" to allow detailed, flexible control over layouts","category":"page"},{"location":"schematicdriven/","page":"Overview","title":"Overview","text":"The schematic-driven design flow goes like this:","category":"page"},{"location":"schematicdriven/","page":"Overview","title":"Overview","text":"Define the Components that will appear in the device\nConstruct a SchematicGraph by adding these Components and their connections using add_node!, fuse!, route!(::SchematicGraph, ...), and attach!(::SchematicGraph, ...)\nUse this to create a Schematic that calculates where the components go (but does not yet render them) using plan\nCheck that the Schematic satisfies critical constraints using check!\nMake any further changes now that components are placed but not rendered\nRender to an output format with render!, with rendering options and layer record described by a Target","category":"page"},{"location":"schematicdriven/","page":"Overview","title":"Overview","text":"Here's what that looks like as a diagram, for comparison with geometry-level flows:","category":"page"},{"location":"schematicdriven/","page":"Overview","title":"Overview","text":"<img src=\"../assets/schematic_dataflow.jpg\"/>","category":"page"},{"location":"schematicdriven/#Quick-start","page":"Overview","title":"Quick start","text":"","category":"section"},{"location":"schematicdriven/#Defining-a-component","page":"Overview","title":"Defining a component","text":"","category":"section"},{"location":"schematicdriven/","page":"Overview","title":"Overview","text":"We'll define an arrow similar to SchematicDrivenLayout.ArrowAnnotation but without any text:","category":"page"},{"location":"schematicdriven/","page":"Overview","title":"Overview","text":"using DeviceLayout, .SchematicDrivenLayout\nimport DeviceLayout: mm, μm, nm\nimport DeviceLayout.SchematicDrivenLayout: AbstractComponent\nimport DeviceLayout.Graphics: inch\nusing FileIO\n\n### Define the component type\n\"\"\"\n    struct ArrowComponent <: AbstractComponent{typeof(1.0nm)}\n        name = \"arrow\"\n        length = 0.05mm\n        width = 0.005mm\n    end\n\nAn arrow with a given length and width.\n\nThe arrow is drawn in the `SemanticMeta(:annotation)` layer.\n\n# Hooks\n\n  - `nock`: The base of the arrow, with inward direction along the arrow\n  - `tip`: The tip of the arrow, with inward direction opposite the arrow\n\"\"\"\n@compdef struct ArrowComponent <: AbstractComponent{typeof(1.0nm)}\n    name = \"arrow\"\n    length = 0.05mm\n    width = 0.005mm\nend\n\n# Draw an arrow from left to right\nfunction SchematicDrivenLayout._geometry!(cs::CoordinateSystem, ac::ArrowComponent)\n    (; length, width) = parameters(ac)\n    rect = centered(Rectangle(length, width))\n    zer = zero(width)\n    tip_edge = [Point(zer, zer), Point(3 * width, 3 * width), Point(zer, 6 * width)]\n    tip = Polygon(vcat(tip_edge, reverse(tip_edge) .- Point(width, zer)))\n    tip = Align.flushright(tip, rect, offset=width, centered=true)\n    arrow = union2d(rect, tip)\n\n    return place!(cs, arrow, :annotation)\nend\n\n# Define a hook at the base of the arrow, pointing in the same direction\n# Define a hook at the tip of the arrow, pointing in the opposite direction \nfunction SchematicDrivenLayout.hooks(ac::ArrowComponent)\n    nockhook = PointHook(Point(-ac.length / 2, zero(ac.length)), 0°)\n    tip = PointHook(Point(ac.length / 2, zero(ac.length)), 180°)\n    return (nock=nockhook, tip=tip)\nend\n\n### Demo a component instance\narrow = ArrowComponent()\narrow_cs = geometry(arrow)\n\n# Render to Cell for SVG export\ntarget = ArtworkTarget(ProcessTechnology((; annotation=GDSMeta()), (;)))\narrowcell = Cell(\"arrow\", nm)\nrender!(arrowcell, arrow_cs, target)\nsave(\"arrow_geom.svg\", arrowcell, width=4inch, height=2inch);\nnothing; # hide","category":"page"},{"location":"schematicdriven/","page":"Overview","title":"Overview","text":"<img src=\"arrow_geom.svg\" style=\"width:4in;\"/>","category":"page"},{"location":"schematicdriven/#Defining-a-Schematic","page":"Overview","title":"Defining a Schematic","text":"","category":"section"},{"location":"schematicdriven/","page":"Overview","title":"Overview","text":"Now we'll make a Schematic that attaches two arrows at the base, rotating the second so that it points in the opposite direction:","category":"page"},{"location":"schematicdriven/","page":"Overview","title":"Overview","text":"g = SchematicGraph(\"double_arrow\")\na1_node = add_node!(g, arrow)\nfuse!(g, a1_node => :nock, arrow => :nock)\nsch = plan(g; log_dir=nothing)\ncheck!(sch)\n\ncell = Cell(\"double_arrow\", nm)\nrender!(cell, sch, target)\nsave(\"double_arrow.svg\", flatten(cell), width=4inch, height=1inch);\nnothing; # hide","category":"page"},{"location":"schematicdriven/","page":"Overview","title":"Overview","text":"<img src=\"double_arrow.svg\" style=\"width:4in;\"/>","category":"page"},{"location":"fileio/","page":"File Formats","title":"File Formats","text":"DocTestSetup = quote\n    using Unitful, DeviceLayout, FileIO\n    using Unitful: °\nend","category":"page"},{"location":"fileio/","page":"File Formats","title":"File Formats","text":"To save or load patterns in any format, make sure you are using FileIO.","category":"page"},{"location":"fileio/#Saving-patterns","page":"File Formats","title":"Saving patterns","text":"","category":"section"},{"location":"fileio/","page":"File Formats","title":"File Formats","text":"This package can load/save patterns in the GDSII format for use with e-beam lithography systems. In the future it may be useful to implement machine-specific pattern formats to force fracturing or dosing in an explicit manner.","category":"page"},{"location":"fileio/","page":"File Formats","title":"File Formats","text":"    DeviceLayout.save","category":"page"},{"location":"fileio/#DeviceLayout.save","page":"File Formats","title":"DeviceLayout.save","text":"save(file::File{format\"DXF\"}, c::Cell, python::String)\n\nExport a Cell to a DXF file. Uses the ezdxf program in Python, and requires the python executable path that has that package installed (could simply be python, or /Users/user/.julia/conda/3/bin/python). Generates a Python script and runs it, to avoid PyCall dependency.\n\n\n\n\n\nsave(::Union{AbstractString,IO}, cell0::Cell{T}, cell::Cell...)\nsave(f::File{format\"GDS\"}, cell0::Cell, cell::Cell...;\n    name=\"GDSIILIB\", userunit=1μm, modify=now(), acc=now(),\n    verbose=false)\n\nThis bottom method is implicitly called when you use the convenient syntax of the top method: save(\"/path/to/my.gds\", cells_i_want_to_save...)\n\nKeyword arguments include:\n\nname: used for the internal library name of the GDSII file and probably inconsequential for modern workflows.\nuserunit: sets what 1.0 corresponds to when viewing this file in graphical GDS editors with inferior unit support.\nmodify: date of last modification.\nacc: date of last accession. It would be unusual to have this differ from now().\nverbose: monitor the output of traverse! and order! to see if something funny is happening while saving.\n\n\n\n\n\nsave(file::File, sm::SolidModel)\nsave(filename::String, sm::SolidModel)\n\nSave a SolidModel instance to a file or filename.\n\nSupported filetypes for OpenCASCADE geometries are .brep and .stp. Meshes can be exported as .msh2 (compatible with Palace) or .msh (most recent Gmsh format) files.\n\n\n\n\n\n","category":"function"},{"location":"fileio/","page":"File Formats","title":"File Formats","text":"Using the Cairo graphics library, it is possible to save cells into SVG, PDF, and EPS vector graphics formats, or into the PNG raster graphic format. This enables patterns to be displayed in web browsers, publications, presentations, and so on. You can save a cell to a graphics file by, e.g. save(\"/path/to/file.svg\", mycell). Note that cell references and arrays are not saved, so you should flatten cells if desired before saving them.","category":"page"},{"location":"fileio/","page":"File Formats","title":"File Formats","text":"Possible keyword arguments include:","category":"page"},{"location":"fileio/","page":"File Formats","title":"File Formats","text":"width: Specifies the width parameter. A unitless number will give the width in pixels, 72dpi. You can also give a length in any unit using a Unitful.Quantity, e.g. u\"4inch\" if you had previously done using Unitful.\nheight: Specifies the height parameter. A unitless number will give the width in pixels, 72dpi. You can also give a length in any unit using a Unitful.Quantity. The aspect ratio of the output is always preserved so specify either width or height.\nlayercolors: Should be a dictionary with Int keys for layers and RGBA tuples as values. For example, (1.0, 0.0, 0.0, 0.5) is red with 50% opacity.\nbboxes: Specifies whether to draw bounding boxes around the bounds of cell arrays or cell references (true/false).","category":"page"},{"location":"fileio/#Loading-patterns","page":"File Formats","title":"Loading patterns","text":"","category":"section"},{"location":"fileio/","page":"File Formats","title":"File Formats","text":"    DeviceLayout.load","category":"page"},{"location":"fileio/#DeviceLayout.load","page":"File Formats","title":"DeviceLayout.load","text":"load(f::File{format\"GDS\"}; verbose::Bool=false, nounits::Bool=false)\n\nA dictionary of top-level cells (Cell objects) found in the GDSII file is returned. The dictionary keys are the cell names. The other cells in the GDSII file are retained by CellReference or CellArray objects held by the top-level cells. Currently, cell references and arrays are not implemented.\n\nThe FileIO package recognizes files based on \"magic bytes\" at the start of the file. To permit any version of GDSII file to be read, we consider the magic bytes to be the GDS HEADER tag (0x0002), preceded by the number of bytes in total (0x0006) for the entire HEADER record. The last well-documented version of GDSII is v6.0.0, encoded as 0x0258 == 600. LayoutEditor appears to save a version 7 as 0x0007, which as far as I can tell is unofficial, and probably just permits more layers than 64, or extra characters in cell names, etc.\n\nIf the database scale is 1μm, 1nm, or 1pm, then the corresponding unit is used for the resulting imported cells. Otherwise, an \"anonymous unit\" is used that will display as u\"2.4μm\" if the database scale is 2.4μm, say.\n\nWarnings are thrown if the GDSII file does not begin with a BGNLIB record following the HEADER record, but loading will proceed.\n\nProperty values and attributes (PROPVALUE and PROPATTR records) will be ignored.\n\nEncountering an ENDLIB record will discard the remainder of the GDSII file without warning. If no ENDLIB record is present, a warning will be thrown.\n\nThe content of some records are currently discarded (mainly the more obscure GDSII record types, but also BGNLIB and LIBNAME).\n\nIf nounits is true, Cell{Float64} objects will be returned, where 1.0 corresponds to one micron.\n\n\n\n\n\n","category":"function"},{"location":"paths/#Paths","page":"Paths","title":"Paths","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"A Paths.Path is an ordered collection of Paths.Nodes, each of which has a Paths.Segment and a Paths.Style. The nodes are linked to each other, so each node knows what the previous and next nodes are.","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"Because Path is a subtype of GeometryStructure, paths can be used with the transformation interface as well as the structure interface including bounds and other operations.","category":"page"},{"location":"paths/#Segments","page":"Paths","title":"Segments","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"Segments describe the curve a Paths.Node follows. For example, Paths.Straight or Paths.Turn are used frequently. In general, each subtype of Segment can represent a class of parametric functions t->Point(x(t),y(t)).","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"note: Note\nThis package assumes that the parametric functions are implemented such that sqrt((dxdt)^2 + (dydt)^2) = 1. In other words, t ranges from zero to the path length of the segment.","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"Instances of these subtypes of Segment specify a particular path in the plane. Instances of Turn, for example, will capture an initial and final angle, a radius, and an origin. All circular turns may be parameterized with these variables.","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"Another useful Segment subtype is Paths.BSpline, which interpolates between two or more points with specified start and end tangents.","category":"page"},{"location":"paths/#Styles","page":"Paths","title":"Styles","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"Each subtype of Style describes how to render a segment. They define a one-dimensional cross-section that is swept along the Segment and that can vary with arclength along the segment. You can create the most common styles using the constructors Paths.Trace (a trace with some width) and Paths.CPW (a coplanar waveguide style).","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"One can implement new styles by writing rendering methods (for GDSII, that would be to_polygons) that dispatch on different pairs of segment and style types. In this way, the rendering code can be specialized for the task at hand, improving performance and shrinking generated file sizes (ideally).","category":"page"},{"location":"paths/#Tapers","page":"Paths","title":"Tapers","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"As a convenience, this package provides functions for the automatic tapering of both Paths.Trace and Paths.CPW via the Paths.Taper constructor. Alternatively, one can specify the tapers concretely by calling their respective constructors.","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"The following example illustrates the use of automatic tapering. First, we construct a taper with two different traces surrounding it:","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"using DeviceLayout, FileIO;\nimport DeviceLayout: nm, μm; # hide\n\np = Path(μm)\nstraight!(p, 10μm, Paths.Trace(2.0μm))\nstraight!(p, 10μm, Paths.Taper())\nstraight!(p, 10μm, Paths.Trace(4.0μm))","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"The taper is automatically chosen to be a Paths.Trace, with appropriate initial (2.0 μm) and final (4.0 μm) widths. The next segment shows that we can even automatically taper between the current Paths.Trace and a hard-coded taper (of concrete type Paths.TaperTrace), matching to the dimensions at the beginning of the latter taper.","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"straight!(p, 10μm, Paths.Taper())\nstraight!(p, 10μm, Paths.TaperTrace(2.0μm, 1.0μm))","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"As a final example, Paths.Taper can also be used in turn! segments, and as a way to automatically transition from a Paths.Taper to a Paths.CPW, or vice-versa:","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"turn!(p, -π / 2, 10μm, Paths.Taper())\nstraight!(p, 10μm, Paths.Trace(2.0μm))\nstraight!(p, 10μm, Paths.Taper())\nstraight!(p, 10μm, Paths.CPW(2.0μm, 1.0μm))\n\nc = Cell(\"tapers\", nm)\nrender!(c, p, GDSMeta(0))\nnothing # hide","category":"page"},{"location":"paths/#Corners","page":"Paths","title":"Corners","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"Sharp turns in a path can be accomplished with Paths.corner!. Sharp turns pose a challenge to the path abstraction in that they have zero length, and when rendered effectively take up some length of the neighboring segments. Originally, the segment lengths were tweaked at render time to achieve the intended output. As other code began taking advantage of the path abstractions, the limitations of this approach became apparent.","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"Currently, corners are implemented such that the preceding Paths.Node is split using Paths.split near the corner when corner! is used, and a short resulting section near the corner has the style changed to Paths.SimpleNoRender. When this is followed by Paths.straight! to create the next segment, a similar operation is done, to ensure the corner is not twice-rendered. This change was necessary to be able to use Intersect.intersect! on paths with corners.","category":"page"},{"location":"paths/#Attachments","page":"Paths","title":"Attachments","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"attach! is one of the most useful functions defined in this package.","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"When you call attach!, you are defining a coordinate system local to somewhere along the target Path, saying that a StructureReference should be placed at the origin of that coordinate system (or slightly away from it if you want the cell to be one one side of the path or the other). The local coordinate system will rotate as the path changes orientations. The origin of the StructureReference corresponds how the referenced cell should be displaced with respect to the origin of the local coordinate system. This differs from the usual meaning of the origin of a StructureReference, which is how the referenced cell should be displaced with respect to the origin of a containing Cell.","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"The same StructureReference can be attached to multiple points along multiple paths. If the reference is modified (e.g. rotation, origin, magnification) before rendering to a Cell, the changes should be reflected at all attachment points. The attachment of the cell reference is not a perfect abstraction: a CellReference must ultimately live inside a Cell, but an unrendered Path does not necessarily live inside any cell. If the path is modified further before rendering, the attachment points will follow the path modifications, moving the origins of the local coordinate systems. The origin fields of the cell references do not change as the path is modified.","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"Attachments are implemented by introducing a Paths.DecoratedStyle, which is kind of a meta-Style: it remembers where to attach StructureReference, but how the path itself is actually drawn is deferred to a different Style object that it retains a reference to. One can repeat a DecoratedStyle with one attachment to achieve a periodic placement of StructureReference (like an ArrayReference, but along the path). Or, one long segment with a DecoratedStyle could have several attachments to achieve a similar effect.","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"When a Path is rendered, it is turned into Polygons living in some Cell. The attachments remain CellReferences, now living inside of a Cell and not tied to an abstract path. The notion of local coordinate systems along the path no longer makes sense because the abstract path has been made concrete, and the polygons are living in the coordinate system of the containing cell. Each attachment to the former path now must have its origin referenced to the origin of the containing cell, not to local path coordinate systems. Additionally, the references may need to rotate according to how the path was locally oriented. As a result, even if the same CellReference was attached multiple times to a path, now we need distinct CellReference objects for each attachment, as well as for each time a corresponding DecoratedStyle is rendered.","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"Suppose we want the ability to transform between coordinate systems, especially between the coordinate system of a referenced cell and the coordinate system of a parent cell. At first glance it would seem like we could simply define a transform function, taking the parent cell and the cell reference we are interested in. But how would we actually identify the particular cell reference we want? Looking in the tree of references for an attached CellReference will not work: distinct CellReferences needed to be made after the path was rendered, and so the particular CellReference object initially attached is not actually in the Cell containing the rendered path.","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"To overcome this problem, we make searching for the appropriate CellReference easier. Suppose a path with attachments has been rendered to a Cell, which is bound to symbol aaa. A CellReference referring to a cell named \"bbb\" was attached twice. To recall the second attachment: aaa[\"bbb\",2] (the index defaults to 1 if unspecified). We can go deeper if we want to refer to references inside that attachment: aaa[\"bbb\",2][\"ccc\"]. In this manner, it is easy to find the right CellReference to use with transformation(::DeviceLayout.GeometryStructure, ::StructureReference).","category":"page"},{"location":"paths/#Intersections","page":"Paths","title":"Intersections","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"How to do the right thing when paths intersect is often tedious. Intersect.intersect! provides a useful function to modify existing paths automatically to account for intersections according to intersection styles (Intersect.IntersectStyle). Since this is done prior to rendering, further modification can be done easily. Both self-intersections and pairwise intersections can be handled for any reasonable number of paths.","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"For now, one intersection style is implemented, but the heavy-lifting to add more has been done already. Here's an example (consult API docs below for further information):","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"pa1 = Path(μm)\nturn!(pa1, -360°, 100μm, Paths.CPW(10μm, 6μm))\npa2 = Path(Point(0, 100)μm, α0=-90°)\nstraight!(pa2, 400μm, Paths.CPW(10μm, 6μm))\nturn!(pa2, 270°, 200μm)\nstraight!(pa2, 400μm)\n\nintersect!(\n    Intersect.AirBridge(\n        scaffold_meta=GDSMeta(3, 0),\n        air_bridge_meta=GDSMeta(4, 0),\n        crossing_gap=2μm,\n        foot_gap=2μm,\n        foot_length=2μm,\n        extent_gap=2μm,\n        scaffold_gap=2μm\n    ),\n    pa1,\n    pa2\n)\n\nc = Cell(\"test\", nm)\nrender!(c, pa1, GDSMeta(0))\nrender!(c, pa2, GDSMeta(1))\nsave(\n    \"intersect_circle.svg\",\n    flatten(c);\n    layercolors=merge(DeviceLayout.Graphics.layercolors, Dict(1 => (0, 0, 0, 1)))\n);\nnothing; # hide","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"<img src=\"../intersect_circle.svg\" style=\"width:4in;\"/>","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"Here's another example:","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"pa = Path(μm, α0=90°)\nstraight!(pa, 130μm, Paths.Trace(2μm))\ncorner!(pa, 90°, Paths.SimpleTraceCorner())\nlet L = 5μm\n    for i = 1:50\n        straight!(pa, L)\n        corner!(pa, 90°, Paths.SimpleTraceCorner())\n        L += 5μm\n    end\nend\nstraight!(pa, 5μm)\n\nintersect!(\n    Intersect.AirBridge(\n        scaffold_meta=GDSMeta(3, 0),\n        air_bridge_meta=GDSMeta(4, 0),\n        crossing_gap=2μm,\n        foot_gap=2μm,\n        foot_length=2μm,\n        extent_gap=2μm,\n        scaffold_gap=2μm\n    ),\n    pa\n)\n\nc = Cell(\"test\", nm)\n\nrender!(c, pa, GDSMeta(1))\nsave(\n    \"intersect_spiral.svg\",\n    flatten(c);\n    layercolors=merge(DeviceLayout.Graphics.layercolors, Dict(1 => (0, 0, 0, 1)))\n);\nnothing; # hide","category":"page"},{"location":"paths/","page":"Paths","title":"Paths","text":"<img src=\"../intersect_spiral.svg\" style=\"width:4in;\"/>","category":"page"},{"location":"paths/#Path-API","page":"Paths","title":"Path API","text":"","category":"section"},{"location":"paths/#Path-construction","page":"Paths","title":"Path construction","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"    Paths.Path","category":"page"},{"location":"paths/#DeviceLayout.Paths.Path","page":"Paths","title":"DeviceLayout.Paths.Path","text":"mutable struct Path{T<:Coordinate} <: GeometryStructure{T}\n\nType for abstracting an arbitrary styled path in the plane. Iterating returns Paths.Node objects.\n\nConvenience constructors for Path{T} object:\n\nPath{T}(p0::Point=zero(Point{T}), α0::typeof(1.0°)=0.0°, metadata::Meta=UNDEF_META)\nPath{T}(name::String, p0::Point=zero(Point{T}), α0::Float64=0.0, metadata::Meta=UNDEF_META)\nPath(p0::Point=zero(Point{typeof(1.0UPREFERRED)}); α0=0.0, name=uniquename(\"path\"), metadata=UNDEF_META)\nPath(p0x::Coordinate, p0y::Coordinate; α0=0.0, name=uniquename(\"path\"), metadata=UNDEF_META)\nPath(u::CoordinateUnits; α0=0.0, name=uniquename(\"path\"), metadata=UNDEF_META)\nPath(v::Vector{Node{T}}; name=uniquename(\"path\"), metadata=UNDEF_META) where {T}\n\n\n\n\n\n","category":"type"},{"location":"paths/#Path-interrogation","page":"Paths","title":"Path interrogation","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"    Paths.direction\n    Paths.pathlength\n    Paths.p0\n    Paths.α0\n    Paths.p1\n    Paths.α1\n    Paths.style0\n    Paths.style1\n    Paths.discretestyle1\n    Paths.contstyle1","category":"page"},{"location":"paths/#DeviceLayout.Paths.direction","page":"Paths","title":"DeviceLayout.Paths.direction","text":"direction(s, t)\n\nReturn the angle at which some function t->Point(x(t),y(t)) is pointing.\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.pathlength","page":"Paths","title":"DeviceLayout.Paths.pathlength","text":"pathlength(p::Path)\npathlength(array::AbstractArray{Node{T}}) where {T}\npathlength(array::AbstractArray{T}) where {T<:Segment}\npathlength(node::Node)\n\nPhysical length of a path. Note that length will return the number of segments in a path, not the physical length of the path.\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.p0","page":"Paths","title":"DeviceLayout.Paths.p0","text":"p0(s::Segment{T}) where {T}\n\nReturn the first point in a segment (calculated).\n\n\n\n\n\np0(p::Path)\n\nFirst point of a path, returns p.p0.\n\n\n\n\n\np0(r::Route)\n\nFirst point of a route, returns r.p0.\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.α0","page":"Paths","title":"DeviceLayout.Paths.α0","text":"α0(s::Segment)\n\nReturn the first angle in a segment (calculated).\n\n\n\n\n\nα0(p::Path)\n\nFirst angle of a path, returns p.α0.\n\n\n\n\n\nα0(r::Route)\n\nFirst angle of a route, returns r.α0.\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.p1","page":"Paths","title":"DeviceLayout.Paths.p1","text":"p1(s::Segment{T}) where {T}\n\nReturn the last point in a segment (calculated).\n\n\n\n\n\np1(p::Path)\n\nLast point of a path.\n\n\n\n\n\np1(r::Route)\n\nLast point of a route, returns r.p1.\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.α1","page":"Paths","title":"DeviceLayout.Paths.α1","text":"α1(s::Segment)\n\nReturn the last angle in a segment (calculated).\n\n\n\n\n\nα1(p::Path)\n\nLast angle of a path.\n\n\n\n\n\nα1(r::Route)\n\nLast angle of a route, returns r.α1.\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.style0","page":"Paths","title":"DeviceLayout.Paths.style0","text":"style0(p::Path)\n\nStyle of the first segment of a path.\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.style1","page":"Paths","title":"DeviceLayout.Paths.style1","text":"style1(p::Path)\n\nUndecorated style of the last user-provided (non-virtual) segment of a path.\n\nThrows an error if the path is empty.\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.discretestyle1","page":"Paths","title":"DeviceLayout.Paths.discretestyle1","text":"discretestyle1(p::Path)\n\nReturn the last-used discrete style in the path.\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.contstyle1","page":"Paths","title":"DeviceLayout.Paths.contstyle1","text":"contstyle1(p::Path)\n\nReturn the undecorated last user-provided (non-virtual) continuous style in the path.\n\nThrows an error if the path is empty.\n\n\n\n\n\n","category":"function"},{"location":"paths/#Path-manipulation","page":"Paths","title":"Path manipulation","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"    Paths.setp0!\n    Paths.setα0!\n    append!(::Path, ::Path)\n    attach!(::Path{T}, ::DeviceLayout.GeometryReference{T}, ::DeviceLayout.Coordinate) where {T}\n    bspline!\n    corner!\n    intersect!\n    launch!\n    meander!\n    overlay!\n    reconcile!\n    simplify\n    simplify!\n    straight!\n    terminate!\n    turn!","category":"page"},{"location":"paths/#DeviceLayout.Paths.setp0!","page":"Paths","title":"DeviceLayout.Paths.setp0!","text":"setp0!(s::Straight, p::Point)\n\nSet the p0 of a straight segment.\n\n\n\n\n\nsetp0!(s::Turn, p::Point)\n\nSet the p0 of a turn.\n\n\n\n\n\nsetp0!(b::BSpline, p::Point)\n\nTranslate the interpolated segment so its initial point is p.\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.setα0!","page":"Paths","title":"DeviceLayout.Paths.setα0!","text":"setα0!(s::Straight, α0′)\n\nSet the angle of a straight segment.\n\n\n\n\n\nsetα0!(s::Turn, α0′)\n\nSet the starting angle of a turn.\n\n\n\n\n\nsetα0!(b::BSpline, α0′)\n\nSet the starting angle of an interpolated segment.\n\n\n\n\n\n","category":"function"},{"location":"paths/#Base.append!-Tuple{Path, Path}","page":"Paths","title":"Base.append!","text":"append!(p::Path, p′::Path; reconcile=true)\n\nGiven paths p and p′, path p′ is appended to path p. The p0 and initial angle of the first segment from path p′ is modified to match the last point and last angle of path p.\n\n\n\n\n\n","category":"method"},{"location":"paths/#DeviceLayout.Paths.attach!-Union{Tuple{T}, Tuple{Path{T}, DeviceLayout.GeometryReference{T}, Union{Real, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {T, U, L, S}, Unitful.Quantity{T, 𝐋} where T}}} where T","page":"Paths","title":"DeviceLayout.Paths.attach!","text":"attach!(p::Path, c::GeometryReference, t::Coordinate;\n    i::Integer=length(p), location::Integer=0)\nattach!(p::Path, c::GeometryReference, t;\n    i::Integer=length(p), location=zeros(Int, length(t)))\n\nAttach c along a path. The second method permits ranges or arrays of t and location to be specified (if the lengths do not match, location is cycled).\n\nBy default, the attachment(s) occur at t ∈ [zero(pathlength(s)),pathlength(s)] along the most recent path segment s, but a different path segment index can be specified using i. The reference is oriented with zero rotation if the path is pointing at 0°, otherwise it is rotated with the path.\n\nThe origin of the cell reference tells the method where to place the cell with respect to a coordinate system that rotates with the path. Suppose the path is a straight line with angle 0°. Then an origin of Point(0.,10.) will put the cell at 10 above the path, or 10 to the left of the path if it turns left by 90°.\n\nThe location option is for convenience. If location == 0, nothing special happens. If location == -1, then the point of attachment for the reference is on the leftmost edge of the waveguide (the rendered polygons; the path itself has no width). Likewise if location == 1, the point of attachment is on the rightmost edge. This option does not automatically rotate the cell reference, apart from what is already done as described in the first paragraph. You can think of this option as setting a special origin for the coordinate system that rotates with the path. For instance, an origin for the cell reference of Point(0.,10.) together with location == -1 will put the cell at 10 above the edge of a rendered (finite width) path with angle 0°.\n\n\n\n\n\n","category":"method"},{"location":"paths/#DeviceLayout.Paths.bspline!","page":"Paths","title":"DeviceLayout.Paths.bspline!","text":"bspline!(p::Path{T}, nextpoints, α_end, sty::Style=contstyle1(p), endpoints_speed=2500μm)\n\nAdd a BSpline interpolation from the current endpoint of p through nextpoints.\n\nThe interpolation reaches nextpoints[end] making the angle α_end with the positive x-axis. The endpoints_speed is \"how fast\" the interpolation leaves and enters its endpoints. Higher speed means that the start and end angles are approximately α1(p) and α_end over a longer distance.\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.corner!","page":"Paths","title":"DeviceLayout.Paths.corner!","text":"corner!(p::Path, α, sty::Style=discretestyle1(p))\n\nAppend a sharp turn or \"corner\" to path p with angle α.\n\nThe style chosen for this corner, if not specified, is the last DiscreteStyle used in the path.\n\n\n\n\n\n","category":"function"},{"location":"paths/#Base.intersect!","page":"Paths","title":"Base.intersect!","text":"intersect!(sty::IntersectStyle, paths::Path...;\n    intersections=prepared_intersections(paths...))\n\nAutomatically modify paths to handle cases where they intersect.\n\nPaths later in the argument list cross over paths earlier in the argument list. For self-intersection (path with itself), segments later in a path will cross over segments earlier in the same path (perhaps later this will be configurable by an option).\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.launch!","page":"Paths","title":"DeviceLayout.Paths.launch!","text":"launch!(p::Path; kwargs...)\n\nAdd a coplanar-waveguide \"launcher\" structure to p.\n\nIf p is empty, start the path with a launcher; otherwise, terminate with a launcher.\n\nThis method exists mainly for use in demonstrations. The launcher design is not optimized for microwave properties.\n\nKeywords:\n\nextround = 5.0μm: Rounding of the \"back\" of the pad and external ground plane \"behind\" the launcher\ntrace0 = 300.0μm: Trace width of the pad\ntrace1 = 10.0μm: Trace width of the launched CPW\ngap0 = 150.0μm: Gap width of the pad\ngap1 = 6.0μm: Gap width of the final CPW\nflatlen = 250.0μm: Length of the pad\ntaperlen = 250.0μm: Length of the taper between pad and launched CPW\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.meander!","page":"Paths","title":"DeviceLayout.Paths.meander!","text":"meander!(p::Path, len, straightlen, r, α)\n\nAlternate between going straight with length straightlen and turning with radius r and angle α. Each turn goes the opposite direction of the previous. The total length is len. Useful for making resonators.\n\nThe straight and turn segments are combined into a CompoundSegment and appended to the path p.\n\n\n\n\n\nmeander!(p::Path, endpoint::Point, len, nseg::Int, r, sty::Paths.Style = style1(p); offset = 0)\n\nAnother meander method, this one extends Path p from its current end-point to meet endpoint, such that the resulting final total path length will be len.\n\nnseg: the number of U-turns in the meander will be 2*nseg\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.overlay!","page":"Paths","title":"DeviceLayout.Paths.overlay!","text":"overlay!(path::Path, oversty::Style, metadata::DeviceLayout.Meta; i::Int=length(path))\n\nApply the style oversty in layer metadata on top of the segment at path[i].\n\nBy default, the overlay is applied to the most recent segment.\n\nOverlays generally count as \"decorations\". For example, they appear in refs(path) and not elements(path). They are removed by undecorated(sty), and they are ignored when choosing the default style for continuing a Path with methods like straight!.\n\nOverlay styles should not be generic Paths.Tapers, since they can't see neighboring styles to resolve the taper style.\n\nYou can use overlay! after attach!, in which case the overlay is applied to the style underlying the DecoratedStyle that holds the attachments.\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.reconcile!","page":"Paths","title":"DeviceLayout.Paths.reconcile!","text":"reconcile!(path::Path, endpoint::Point, end_direction, rule::RouteRule, waypoints, waydirs;\n    initialize_waydirs = false)\n\nEnsure that path can be routed to endpoint at end_direction using rule, waypoints, waydirs, or throw an error.\n\nDoes nothing for a generic RouteRule. Subtypes of RouteRule may implement specialized methods to do their own validation when route! is called.\n\nMay insert inferred constraints to waypoints and waydirs to allow the path to be drawn leg-by-leg. For example, reconcile! with rule::StraightAnd90, no waypoints, and α1(path) == end_direction will insert a waypoint halfway between p1(path) and endpoint, allowing two successive StraightAnd90 legs with opposite bends.\n\n\n\n\n\nreconcile!(p::Path, n::Integer=1)\n\nReconcile all inconsistencies in a path starting from index n. Used internally whenever segments are inserted into the path, but can be safely used by the user as well.\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.simplify","page":"Paths","title":"DeviceLayout.Paths.simplify","text":"simplify(p::Path, inds::UnitRange=firstindex(p):lastindex(p))\n\nAt inds, segments of a path are turned into a CompoundSegment and styles of a path are turned into a CompoundStyle. The method returns a Paths.Node, (segment, style).\n\nIndexing the path becomes more sane when you can combine several path segments into one logical element. A launcher would have several indices in a path unless you could simplify it.\nYou don't need to think hard about boundaries between straights and turns when you want a continuous styling of a very long path.\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.simplify!","page":"Paths","title":"DeviceLayout.Paths.simplify!","text":"simplify!(p::Path, inds::UnitRange=firstindex(p):lastindex(p))\n\nIn-place version of simplify.\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.straight!","page":"Paths","title":"DeviceLayout.Paths.straight!","text":"straight!(p::Path, l::Coordinate, sty::Style=contstyle1(p))\n\nExtend a path p straight by length l in the current direction. By default, we take the last continuous style in the path.\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.terminate!","page":"Paths","title":"DeviceLayout.Paths.terminate!","text":"terminate!(pa::Path{T}; gap=Paths.terminationlength(pa), rounding=zero(T), initial=false) where {T}\n\nEnd a Paths.Path with a termination.\n\nIf the preceding style is a CPW, this is a \"short termination\" if iszero(gap) and is an \"open termination\" with a gap of gap otherwise, defaulting to the gap of the preceding CPW.\n\nRounding of corners may be specified with radius given by rounding. Rounding keeps the trace length constant by removing some length from the preceding segment and adding a rounded section of equivalent maximum length. (This produces a small quirk if you terminate a curved segment with rounding—the termination is \"straight\" starting at rounding away from the end of the curve, meaning that the α0(pa))\n\nIf the preceding style is a trace, the termination only rounds the corners at the end of the segment or does nothing if iszero(rounding).\n\nIf initial, the termination is applied at the beginning of the Path.\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.turn!","page":"Paths","title":"DeviceLayout.Paths.turn!","text":"turn!(p::Path, α, r::Coordinate, sty::Style=contstyle1(p))\n\nTurn a path p by angle α with a turning radius r in the current direction. Positive angle turns left. By default, we take the last continuous style in the path.\n\n\n\n\n\nturn!(p::Path, str::String, r::Coordinate, sty::Style=contstyle1(p))\n\nTurn a path p with direction coded by string str:\n\n\"l\": turn by 90° (left)\n\"r\": turn by -90° (right)\n\"lrlrllrrll\": do those turns in that order\n\nBy default, we take the last continuous style in the path.\n\n\n\n\n\n","category":"function"},{"location":"paths/#Path-intersection-styles","page":"Paths","title":"Path intersection styles","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"    Intersect.IntersectStyle\n    Intersect.AirBridge","category":"page"},{"location":"paths/#DeviceLayout.Intersect.IntersectStyle","page":"Paths","title":"DeviceLayout.Intersect.IntersectStyle","text":"IntersectStyle{N}\n\nAbstract type specifying \"2-body interactions\" for path intersection.\n\n\n\n\n\n","category":"type"},{"location":"paths/#DeviceLayout.Intersect.AirBridge","page":"Paths","title":"DeviceLayout.Intersect.AirBridge","text":"AirBridge(; crossing_gap, foot_gap, foot_length, extent_gap, scaffold_gap,\n    scaffold_meta=SemanticMeta(:scaffold), air_bridge_meta=SemanticMeta(:air_bridge), \n    name=\"airbridge\", unit=[nm or NoUnits])\n\nStyle for automatically leaping one path over another with scaffolded air bridges.\n\nParameters (\"lengths\" are along path direction, \"extents\" are transverse from the center)\n\nname: Prefix for unique CoordinateSystem name\nscaffold_meta: Scaffold layer metadata\nair_bridge_meta: Air bridge layer metadata\ncrossing_gap: Extra length beyond extent of path being crossed (on one side)\nfoot_gap: Extra length beyond original path termination before bridge foot starts\nfoot_length: Length of bridge foot\nextent_gap: Gap between edge of bridge trace and edge of original path trace\nscaffold_gap: Gap between edge of original trace and edge of scaffold\nrounding: Rounding radius for scaffold and air bridge rectangles\nunit: Coordinate system unit\n\n\n\n\n\n","category":"type"},{"location":"paths/#Node-API","page":"Paths","title":"Node API","text":"","category":"section"},{"location":"paths/#Node-construction","page":"Paths","title":"Node construction","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"    Paths.Node","category":"page"},{"location":"paths/#DeviceLayout.Paths.Node","page":"Paths","title":"DeviceLayout.Paths.Node","text":"Node(a::Segment{T}, b::Style) where {T}\n\nCreate a node with segment a and style b.\n\n\n\n\n\n","category":"type"},{"location":"paths/#Node-methods","page":"Paths","title":"Node methods","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"    Paths.previous\n    Paths.next\n    Paths.segment\n    Paths.split(::Paths.Node, ::DeviceLayout.Coordinate)\n    Paths.style\n    Paths.setsegment!\n    Paths.setstyle!","category":"page"},{"location":"paths/#DeviceLayout.Paths.previous","page":"Paths","title":"DeviceLayout.Paths.previous","text":"previous(x::Node)\n\nReturn the node before x in a doubly linked list.\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.next","page":"Paths","title":"DeviceLayout.Paths.next","text":"next(x::Node)\n\nReturn the node after x in a doubly linked list.\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.segment","page":"Paths","title":"DeviceLayout.Paths.segment","text":"segment(x::Node)\n\nReturn the segment associated with node x.\n\n\n\n\n\n","category":"function"},{"location":"paths/#Base.split-Tuple{DeviceLayout.Paths.Node, Union{Real, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {T, U, L, S}, Unitful.Quantity{T, 𝐋} where T}}","page":"Paths","title":"Base.split","text":"split(n::Node, x::Coordinate)\nsplit(n::Node, x::AbstractVector{<:Coordinate}; issorted=false)\n\nSplits a path node at position(s) x along the segment, returning a path. If issorted, don't sort x first (otherwise required for this to work).\n\nA useful idiom, splitting and splicing back into a path: splice!(path, i, split(path[i], x))\n\n\n\n\n\n","category":"method"},{"location":"paths/#DeviceLayout.style","page":"Paths","title":"DeviceLayout.style","text":"style(x::Node)\n\nReturn the style associated with node x.\n\n\n\n\n\nstyle(styled_ent::StyledEntity)\n\nReturn the GeometryEntityStyle of styled_ent.\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.setsegment!","page":"Paths","title":"DeviceLayout.Paths.setsegment!","text":"setsegment!(n::Node, s::Segment)\n\nSet the segment associated with node n to s. If reconcile, then modify fields as appropriate for internal consistency (possibly including other linked nodes).\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.setstyle!","page":"Paths","title":"DeviceLayout.Paths.setstyle!","text":"setstyle!(n::Node, s::Style; reconcile=true)\n\nSet the style associated with node n to s. If reconcile, then modify fields as appropriate for internal consistency.\n\n\n\n\n\n","category":"function"},{"location":"paths/#Segment-API","page":"Paths","title":"Segment API","text":"","category":"section"},{"location":"paths/#Abstract-types","page":"Paths","title":"Abstract types","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"    Paths.Segment","category":"page"},{"location":"paths/#DeviceLayout.Paths.Segment","page":"Paths","title":"DeviceLayout.Paths.Segment","text":"abstract type Segment{T<:Coordinate} end\n\nPath segment in the plane. All Segment objects should have the implement the following methods:\n\npathlength\np0\nα0\nsetp0!\nsetα0!\nα1\n\n\n\n\n\n","category":"type"},{"location":"paths/#Concrete-types","page":"Paths","title":"Concrete types","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"    Paths.Straight\n    Paths.Turn\n    Paths.Corner\n    Paths.CompoundSegment\n    Paths.BSpline","category":"page"},{"location":"paths/#DeviceLayout.Paths.Straight","page":"Paths","title":"DeviceLayout.Paths.Straight","text":"mutable struct Straight{T} <: ContinuousSegment{T}\n\nA straight line segment is parameterized by its length. It begins at a point p0 with initial angle α0.\n\n\n\n\n\n","category":"type"},{"location":"paths/#DeviceLayout.Paths.Turn","page":"Paths","title":"DeviceLayout.Paths.Turn","text":"mutable struct Turn{T} <: ContinuousSegment{T}\n\nA circular turn is parameterized by the turn angle α and turning radius r. It begins at a point p0 with initial angle α0.\n\n\n\n\n\n","category":"type"},{"location":"paths/#DeviceLayout.Paths.Corner","page":"Paths","title":"DeviceLayout.Paths.Corner","text":"mutable struct Corner{T} <: DiscreteSegment{T}\n\nA corner, or sudden kink in a path. The only parameter is the angle α of the corner. The corner begins at a point p0 with initial angle α0. It will also end at p0, since the corner has zero path length. However, during rendering, neighboring segments will be tweaked slightly so that the rendered path is properly centered about the path function (the rendered corner has a finite width).\n\n\n\n\n\n","category":"type"},{"location":"paths/#DeviceLayout.Paths.CompoundSegment","page":"Paths","title":"DeviceLayout.Paths.CompoundSegment","text":"struct CompoundSegment{T} <: ContinuousSegment{T}\n\nConsider an array of segments as one contiguous segment. Useful e.g. for applying styles, uninterrupted over segment changes. The array of segments given to the constructor is copied and retained by the compound segment.\n\nNote that Corners introduce a discontinuity in the derivative of the path function, and are not allowed in a CompoundSegment.\n\n\n\n\n\n","category":"type"},{"location":"paths/#DeviceLayout.Paths.BSpline","page":"Paths","title":"DeviceLayout.Paths.BSpline","text":"mutable struct BSpline{T} <: ContinuousSegment{T}\n\nInterpolate between points p with start and end tangents t0, t1.\n\nComputes the interpolated coordinate r(t) as a function of a dimensionless parameter t, using b-spline interpolation knots spaced uniformly in t. That is, r(0) == p[1] and r(1) == p[end], and generally r((i-1)*tinc) == p[i] where tinc is the knot value spacing 1/(length(p)-1).\n\nA BSpline instance itself can be called as a parametric function of a length that ranges from zero to the total path length.\n\n\n\n\n\n","category":"type"},{"location":"paths/#Style-API","page":"Paths","title":"Style API","text":"","category":"section"},{"location":"paths/#Style-construction","page":"Paths","title":"Style construction","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"    Paths.Trace\n    Paths.CPW\n    Paths.Taper\n    Paths.Strands\n    Paths.NoRender","category":"page"},{"location":"paths/#DeviceLayout.Paths.Trace","page":"Paths","title":"DeviceLayout.Paths.Trace","text":"Trace(width)\nTrace(width::Coordinate)\nTrace(width_start::Coordinate, width_end::Coordinate)\n\nConstructor for Trace styles. Automatically chooses SimpleTrace, GeneralTrace, and TaperTrace as appropriate.\n\n\n\n\n\n","category":"type"},{"location":"paths/#DeviceLayout.Paths.CPW","page":"Paths","title":"DeviceLayout.Paths.CPW","text":"CPW(trace::Coordinate, gap::Coordinate)\nCPW(trace, gap::Coordinate)\nCPW(trace::Coordinate, gap)\nCPW(trace, gap)\nCPW(trace_start::Coordinate, gap_start::Coordinate, trace_end::Coordinate, gap_end::Coordinate)\n\nConstructors for CPW styles. Automatically chooses between SimpleCPW, GeneralCPW, or TaperCPW styles as appropriate.\n\n\n\n\n\n","category":"type"},{"location":"paths/#DeviceLayout.Paths.Taper","page":"Paths","title":"DeviceLayout.Paths.Taper","text":"Taper()\n\nConstructor for generic Taper style. Will automatically create a linearly tapered region between an initial CPW or Trace and an end CPW or Trace of different dimensions.\n\n\n\n\n\n","category":"type"},{"location":"paths/#DeviceLayout.Paths.Strands","page":"Paths","title":"DeviceLayout.Paths.Strands","text":"Strands(offset::Coordinate, width::Coordinate, spacing::Coordinate, num::Int)\nStrands(offset, width::Coordinate, spacing::Coordinate, num::Int)\nStrands(offset::Coordinate, width, spacing::Coordinate, num::Int)\nStrands(offset::Coordinate, width::Coordinate, spacing, num::Int)\nStrands(offset::Coordinate, width, spacing, num::Int)\nStrands(offset, width::Coordinate, spacing, num::Int)\nStrands(offset, width, spacing::Coordinate, num::Int)\nStrands(offset, width, spacing, num::Int)\n\n              example for num = 2\n|||     |||                         |||     |||\n|||     |||                         |||     |||\n|||     |||                         |||     |||\n|||     |||                         |||     |||\n<-><---><-><-----------|-----------><-><---><->\n w   s   w    offset                 w   s   w\n\nConstructors for Strands styles. Automatically chooses between SimpleStrandsor GeneralStrands styles as appropriate.\n\n\n\n\n\n","category":"type"},{"location":"paths/#DeviceLayout.Paths.NoRender","page":"Paths","title":"DeviceLayout.Paths.NoRender","text":"struct NoRender <: Style\n\nStyle for suppressing rendering. When asked, it will claim to have zero width. Converts to a continuous or discrete style as needed by straight!, turn!, corner!, etc.\n\n\n\n\n\n","category":"type"},{"location":"paths/#Style-manipulation","page":"Paths","title":"Style manipulation","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"    Paths.pin\n    Paths.translate\n    Paths.undecorated","category":"page"},{"location":"paths/#DeviceLayout.Paths.pin","page":"Paths","title":"DeviceLayout.Paths.pin","text":"pin(s::ContinuousStyle; start=nothing, stop=nothing)\n\nImagine having a styled segment of length L split into two, the first segment having length l and the second having length L-l. In all but the simplest styles, the styles need to be modified in order to maintain the rendered appearances. A style appropriate for the segment of length l (L-l) is given by pin(s; stop=l) (pin(s; start=l)).\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.translate","page":"Paths","title":"DeviceLayout.Paths.translate","text":"translate(s::ContinuousStyle, x)\n\nCreates a style s′ such that all properties f(s′, t) == f(s, t+x). Basically, advance the style forward by path length x.\n\n\n\n\n\n","category":"function"},{"location":"paths/#DeviceLayout.Paths.undecorated","page":"Paths","title":"DeviceLayout.Paths.undecorated","text":"undecorated(s::DecoratedStyle)\nundecorated(s::Style)\n\nReturn the underlying, undecorated style if decorated; otherwise just return the style.\n\n\n\n\n\n","category":"function"},{"location":"paths/#Abstract-types-2","page":"Paths","title":"Abstract types","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"    Paths.Style\n    Paths.ContinuousStyle\n    Paths.DiscreteStyle","category":"page"},{"location":"paths/#DeviceLayout.Paths.Style","page":"Paths","title":"DeviceLayout.Paths.Style","text":"abstract type Style end\n\nHow to render a given path segment.\n\n\n\n\n\n","category":"type"},{"location":"paths/#DeviceLayout.Paths.ContinuousStyle","page":"Paths","title":"DeviceLayout.Paths.ContinuousStyle","text":"abstract type ContinuousStyle{CanStretch} <: Style end\n\nAny style that applies to segments which have non-zero path length. For most styles, CanStretch == false. An example of an exception is a linear taper, e.g. Paths.TaperTrace, where you fix the starting and ending trace widths and let the segment length dictate the abruptness of the transition (hence, stretching the style). Concrete types inheriting from ContinuousStyle{true} should have a length field as the last field of their structure.\n\n\n\n\n\n","category":"type"},{"location":"paths/#DeviceLayout.Paths.DiscreteStyle","page":"Paths","title":"DeviceLayout.Paths.DiscreteStyle","text":"abstract type DiscreteStyle <: Style end\n\nAny style that applies to segments which have zero path length.\n\n\n\n\n\n","category":"type"},{"location":"paths/#Concrete-types-2","page":"Paths","title":"Concrete types","text":"","category":"section"},{"location":"paths/","page":"Paths","title":"Paths","text":"    Paths.SimpleNoRender\n    Paths.SimpleTrace\n    Paths.GeneralTrace\n    Paths.SimpleCPW\n    Paths.GeneralCPW\n    Paths.TaperTrace\n    Paths.TaperCPW\n    Paths.SimpleStrands\n    Paths.GeneralStrands\n    Paths.CompoundStyle\n    Paths.DecoratedStyle","category":"page"},{"location":"paths/#DeviceLayout.Paths.SimpleNoRender","page":"Paths","title":"DeviceLayout.Paths.SimpleNoRender","text":"struct SimpleNoRender{T} <: ContinuousStyle{false}\nSimpleNoRender(width::T; virtual=false)\n\nA style that inhibits path rendering, but pretends to have a finite width for Paths.attach!.\n\nMay be \"virtual\", in which case it is ignored when looking up the last style of a Path with laststyle or contstyle1, or when extending a Path with (for example) straight!.\n\n\n\n\n\n","category":"type"},{"location":"paths/#DeviceLayout.Paths.SimpleTrace","page":"Paths","title":"DeviceLayout.Paths.SimpleTrace","text":"struct SimpleTrace{T <: Coordinate} <: Trace{false}\n    width::T\nend\n\nA single trace with fixed width as a function of path length.\n\n\n\n\n\n","category":"type"},{"location":"paths/#DeviceLayout.Paths.GeneralTrace","page":"Paths","title":"DeviceLayout.Paths.GeneralTrace","text":"struct GeneralTrace{T} <: Trace{false}\n    width::T\nend\n\nA single trace with variable width as a function of path length. width is callable.\n\n\n\n\n\n","category":"type"},{"location":"paths/#DeviceLayout.Paths.SimpleCPW","page":"Paths","title":"DeviceLayout.Paths.SimpleCPW","text":"struct SimpleCPW{T <: Coordinate} <: CPW{false}\n    trace::T\n    gap::T\nend\n\nA CPW with fixed trace and gap as a function of path length.\n\n\n\n\n\n","category":"type"},{"location":"paths/#DeviceLayout.Paths.GeneralCPW","page":"Paths","title":"DeviceLayout.Paths.GeneralCPW","text":"struct GeneralCPW{S, T} <: CPW{false}\n    trace::S\n    gap::T\nend\n\nA CPW with variable trace and gap as a function of path length. trace and gap are callable.\n\n\n\n\n\n","category":"type"},{"location":"paths/#DeviceLayout.Paths.TaperTrace","page":"Paths","title":"DeviceLayout.Paths.TaperTrace","text":"struct TaperTrace{T<:Coordinate} <: Trace{true}\n    width_start::T\n    width_end::T\n    length::T\nend\n\nA single trace with a linearly tapered width as a function of path length.\n\n\n\n\n\n","category":"type"},{"location":"paths/#DeviceLayout.Paths.TaperCPW","page":"Paths","title":"DeviceLayout.Paths.TaperCPW","text":"struct TaperCPW{T<:Coordinate} <: CPW{true}\n    trace_start::T\n    gap_start::T\n    trace_end::T\n    gap_end::T\n    length::T\nend\n\nA CPW with a linearly tapered trace and gap as a function of path length.\n\n\n\n\n\n","category":"type"},{"location":"paths/#DeviceLayout.Paths.SimpleStrands","page":"Paths","title":"DeviceLayout.Paths.SimpleStrands","text":"struct SimpleStrands{T<:Coordinate} <: Strands{false}\n    offset::T\n    width::T\n    spacing::T\n    num::Int\nend\n\n              example for num = 2\n|||     |||                         |||     |||\n|||     |||                         |||     |||\n|||     |||                         |||     |||\n|||     |||                         |||     |||\n<-><---><-><-----------|-----------><-><---><->\n w   s   w    offset                 w   s   w\n\nStrands with fixed center offset, width, and spacing as a function of path length.\n\n\n\n\n\n","category":"type"},{"location":"paths/#DeviceLayout.Paths.GeneralStrands","page":"Paths","title":"DeviceLayout.Paths.GeneralStrands","text":"struct GeneralStrands{S,T,U} <: Strands{false}\n    offset::S\n    width::T\n    spacing::U\n    num::Int\nend\n\n              example for num = 2\n|||     |||                         |||     |||\n|||     |||                         |||     |||\n|||     |||                         |||     |||\n|||     |||                         |||     |||\n<-><---><-><-----------|-----------><-><---><->\n w   s   w    offset                 w   s   w\n\nStrands with variable center offset, width, and spacing as a function of path length. offset, width, and spacing are callable.\n\n\n\n\n\n","category":"type"},{"location":"paths/#DeviceLayout.Paths.CompoundStyle","page":"Paths","title":"DeviceLayout.Paths.CompoundStyle","text":"struct CompoundStyle{T<:FloatCoordinate} <: ContinuousStyle{false}\n    styles::Vector{Style}\n    grid::Vector{T}\nend\n\nCombines styles together, typically for use with a CompoundSegment.\n\nstyles: Array of styles making up the object. This is deep-copied by the outer constructor.\ngrid: An array of t values needed for rendering the parameteric path.\n\n\n\n\n\n","category":"type"},{"location":"paths/#DeviceLayout.Paths.DecoratedStyle","page":"Paths","title":"DeviceLayout.Paths.DecoratedStyle","text":"mutable struct DecoratedStyle{T<:FloatCoordinate} <: ContinuousStyle{false}\n    s::Style\n    ts::Vector{Float64}\n    dirs::Vector{Int}\n    refs::Vector{GeometryReference}\nend\n\nStyle with decorations, like structures periodically repeated along the path, etc.\n\n\n\n\n\n","category":"type"},{"location":"examples/qpu17/#Quantum-processor-with-17-transmons","page":"Quantum Processor","title":"Quantum processor with 17 transmons","text":"","category":"section"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"In this example, we demonstrate the layout of a 17-transmon quantum processor (QPU). We roughly follow well-documented layouts published by the Quantum Device Lab at ETH Zurich—for example, in their 2022 Nature paper \"Realizing repeated quantum error correction in a distance-three surface code\" (by Sebastian Krinner and coauthors) or the more recent \"Realizing Lattice Surgery on Two Distance-Three Repetition Codes with Superconducting Qubits\" (2025, by Ilya Besedin, Michael Kerschbaum, and coauthors).","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"The full code for this example can be found in examples/DemoQPU17 in the DeviceLayout.jl repository. Components and process technology are drawn from the ExamplePDK.","category":"page"},{"location":"examples/qpu17/#Overview","page":"Quantum Processor","title":"Overview","text":"","category":"section"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"To run the example, we include the file DemoQPU17.jl from the example's folder. This defines a module containing all the necessary parameters and methods to generate the device. Then we run the qpu17_demo() method to produce the device schematic and artwork.","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"using DeviceLayout, FileIO\ninclude(\"../../../examples/DemoQPU17/DemoQPU17.jl\")\n@time \"Total\" schematic, artwork = DemoQPU17.qpu17_demo(savegds=false)\n@time \"Saving\" save(\"qpu17.png\", flatten(artwork), width=12 * 72, height=12 * 72);\nnothing # hide","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"<img src=\"../qpu17.png\"/>","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"Note that the timings above are around 90% compilation. If we wanted to tweak some parameters and then run the script again in the same Julia session, then it would take around 10% as long:","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"@time \"Total\" schematic, artwork = DemoQPU17.qpu17_demo(savegds=false)\n@time \"Saving\" save(\"qpu17.png\", flatten(artwork), width=12 * 72, height=12 * 72);\nnothing # hide","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"The example includes a utility to turn the schematic into a \"false color\" drawing where each component's footprint is drawn in a layer corresponding to that component's role:","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"falsecolor = DemoQPU17.false_color_layout!(schematic) # modify and render to Cell\nsave(\"qpu17_falsecolor.png\", flatten(falsecolor), width=12 * 72, height=12 * 72);\nnothing # hide","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"<img src=\"../qpu17_falsecolor.png\"/>","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"We see the 17 transmons in red, the couplers between them in purple, and the readout resonators and filters in green. The XY control, Z control, and readout lines are blue, gold, and pink, respectively.","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"The schematic-driven workflow used to generate this layout consists of the following steps:","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"Define the component types that will appear in the device—resonators, transmons, and so on.\nChoose sets of parameters for the component instances that will appear in your device.\nConstruct a SchematicGraph by adding component instances (nodes) and specifying connections between them (edges), including special \"route\" components that define wires to be automatically routed after other components are placed.\nConstruct a Schematic from the SchematicGraph by running an automated floorplanning routine that positions and orients components in a 2D layout.\nCheck that the schematic follows high-level design rules—for example, that all Josephson junctions have the correct orientation for your fabrication process.\nMake any desired changes to the schematic, like creating crossovers between intersecting wires or filling the empty areas of the ground plane with holes for flux trapping.\nRender the schematic, generating 2D geometry for each component for output in a format like GDSII.","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"Schematic-driven layout allows the designer to work with a high-level description of the device independent of the detailed geometry. The component definitions specify what geometry to draw and, together with the automated floorplanning routine, ensure that they line up correctly with other components’ geometry. Designers can edit components without needing to manually track and correct far-reaching changes through the entire device, and they can easily reuse components in different schematics.","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"Let's take a closer look at each step with excerpts from the code. See the examples/DemoQPU17 folder in the DeviceLayout.jl repository for the full code that was run above.","category":"page"},{"location":"examples/qpu17/#Defining-component-types","page":"Quantum Processor","title":"Defining component types","text":"","category":"section"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"For this example, we use predefined component types from DeviceLayout.jl’s ExamplePDK module. These components are intended for tests and demonstrations, and are not necessarily optimized for device performance or experimentally validated.","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"Each component type has methods defining their parameterized geometry and \"hooks\"—special points where they connect to other components with a certain orientation. For this device, the most important components are transmons with fixed capacitive couplers (ExampleStarTransmon) and readout resonators with Purcell filters (ExampleFilteredHairpinReadout). These are both \"composite\" components, meaning that they're defined in terms of a SchematicGraph themselves, with subcomponents like the transmon island and individual resonators.","category":"page"},{"location":"examples/qpu17/#Defining-parameters","page":"Quantum Processor","title":"Defining parameters","text":"","category":"section"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"We set device parameters in DemoQPU17/params.jl as named tuples returned by qpu_params(). These include component parameters, general device constants, and routing parameters. For transmons and readout resonators, we create parameter arrays with the same 5x5 shape as our qubit lattice, often using broadcasting (the . operator) to derive one array from another.","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"warning: Warning\nThese parameters are placeholders used to demonstrate layout of a full device. They are not chosen to target particular device properties.","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"##### Define parameters and constants for QPU, components, and routing\n# ALL_CAPS: Fixed/derived/floorplanning parameter\n# lower_case: Tuning parameter\n\n### Transmons\n# Lattice\nACTIVE_SITES = Bool[ # Where are there transmons?\n    0 1 1 0 0 # not using the whole 5x5 grid\n    0 1 1 1 1\n    1 1 1 1 1\n    1 1 1 1 0\n    0 0 1 1 0\n]\nROW = repeat(1:5, outer=(1, 5))\nCOL = transpose(ROW)\n# Which transmons are facing different ways?\nMIRRORED_LR = similar(ACTIVE_SITES)\nMIRRORED_UD = similar(ACTIVE_SITES)\n@. MIRRORED_LR = (COL > 3) || (COL == 3 && ROW < 3)\n@. MIRRORED_UD = (ROW > 3) || (ROW == 3 && COL > 3)\n\n# Which couplers are active?\nGROUNDED_COUPLERS = map(eachindex(IndexCartesian(), ACTIVE_SITES)) do I\n    row, col = Tuple(I)\n    gc = Int[] # Will hold indices of grounded couplers (1-4)\n    # Ground north coupler if we're in the first row or the site above us is empty\n    gnd_north = (row == 1 || !ACTIVE_SITES[row - 1, col])\n    gnd_south = (row == 5 || !ACTIVE_SITES[row + 1, col])\n    gnd_west = (col == 1 || !ACTIVE_SITES[row, col - 1])\n    gnd_east = (col == 5 || !ACTIVE_SITES[row, col + 1])\n    # If the transmon is mirrored, switch east/west or north/south as appropriate\n    MIRRORED_LR[row, col] && ((gnd_west, gnd_east) = (gnd_east, gnd_west))\n    MIRRORED_UD[row, col] && ((gnd_north, gnd_south) = (gnd_south, gnd_north))\n    # Fill up the list of grounded couplers\n    gnd_north && push!(gc, 1)\n    gnd_east && push!(gc, 2)\n    gnd_south && push!(gc, 3)\n    gnd_west && push!(gc, 4)\n    return gc\nend\n\n# Transmon additional geometry parameters\nDATA_QUBIT = iseven.(ROW .+ COL) # Data vs ancilla role in surface code\ndata_inner_radius = [80μm, 80μm, 80μm, 80μm, 20μm] # Big readout coupler for data\nancilla_inner_radius = [80μm, 80μm, 80μm, 80μm, 80μm]\nisland_inner_radius = ifelse.(DATA_QUBIT, Ref(data_inner_radius), Ref(ancilla_inner_radius))\n\ncoupler_style = Paths.CPW(10μm, 10μm)\nresonator_style = Paths.CPW(10μm, 10μm)\ncontrol_style = Paths.CPW(3.3μm, 2μm)\n\ntransmons = (; # named tuple with variable names as keys\n    ACTIVE_SITES,\n    ROW,\n    COL,\n    MIRRORED_LR,\n    MIRRORED_UD,\n    GROUNDED_COUPLERS,\n    DATA_QUBIT,\n    data_inner_radius,\n    ancilla_inner_radius,\n    island_inner_radius,\n    coupler_style,\n    resonator_style,\n    control_style\n)\n\n### Readout resonators\nEFFECTIVE_INDEX = 2.5\nro_freq_GHz = [\n    0.0 7.0 7.3 0.0 0.0\n    0.0 7.4 7.1 7.5 6.9\n    7.2 7.6 6.8 7.6 7.4\n    6.9 7.3 7.5 7.2 0.0\n    0.0 0.0 7.1 7.0 0.0\n]\nRO_EFFECTIVE_LENGTH = (299792458 ./ (4 * EFFECTIVE_INDEX * ro_freq_GHz))nm\nreadout = (; # named tuple with variable names as keys\n    EFFECTIVE_INDEX,\n    ro_freq_GHz,\n    RO_EFFECTIVE_LENGTH\n)\n\n### Other device constants\nFEEDLINE_STYLE = Paths.CPW(10μm, 6μm) # Used for both readout and control lines\nFEEDLINE_BRIDGE = ExamplePDK.bridge_geometry(FEEDLINE_STYLE)\nCONTROL_BRIDGE = ExamplePDK.bridge_geometry(control_style)\nRESONATOR_BRIDGE = ExamplePDK.bridge_geometry(resonator_style)\nCOUPLER_BRIDGE = ExamplePDK.bridge_geometry(coupler_style)\nGROUND_HOLE_SPACING = 100μm\nGROUND_HOLE_RADIUS = 5μm\nRO_INPUT_CAPACITOR = ExampleSeriesClawCapacitor(input_length=700μm)\n# Crossover style (simple scaffolded bridge, not optimized for microwave properties)\nXSTY = Intersect.AirBridge(\n    crossing_gap=5μm,\n    foot_gap=3μm,\n    foot_length=10μm,\n    extent_gap=3μm,\n    scaffold_gap=3μm,\n    scaffold_meta=LayerVocabulary.BRIDGE_BASE,\n    air_bridge_meta=LayerVocabulary.BRIDGE\n)\ndevice = (; # named tuple with variable names as keys\n    FEEDLINE_STYLE,\n    FEEDLINE_BRIDGE,\n    CONTROL_BRIDGE,\n    RESONATOR_BRIDGE,\n    COUPLER_BRIDGE,\n    GROUND_HOLE_RADIUS,\n    GROUND_HOLE_SPACING,\n    RO_INPUT_CAPACITOR,\n    XSTY\n)","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"We also define routing parameters; we'll omit their definitions here because we'll discuss them in more detail below:","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"# params.jl\nrouting = (; # named tuple with variable names as keys\n    S45_LOOSE,\n    S90_TIGHT,\n    CONTROL_ROUTE_RULE,\n    READOUT_ROUTE_RULE,\n    LINE_SPECIFICATIONS,\n    READOUT_GROUPS,\n    RO_WAYPOINTS,\n    RO_MEANDER_PARAMS\n)","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"Finally, the qpu_params method returns a nested NamedTuple containing our parameters:","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"# params.jl\n# Return nested NamedTuple of parameters organized by type\nreturn (; transmons, readout, device, routing)","category":"page"},{"location":"examples/qpu17/#Assembling-the-schematic-graph","page":"Quantum Processor","title":"Assembling the schematic graph","text":"","category":"section"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"Next, we define an abstract representation of our device as a graph (SchematicGraph), with nodes representing instances of components and edges representing connections between them. This is done in the assemble_schematic_graph! method in the script.","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"p = qpu_params()\ng = SchematicGraph(\"qpu17_demo\")\n@time \"Assembling schematic graph\" nodes = assemble_schematic_graph!(g, p)","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"This method also returns the nodes we created, organized by component type. We could always retrieve them from the graph g, but this is a bit more convenient if we want to do something with them later.","category":"page"},{"location":"examples/qpu17/#Defining-components","page":"Quantum Processor","title":"Defining components","text":"","category":"section"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"Here's how we define our main components, in assemble_schematic_graph!. The @component macro conveniently lets us define arrays of components based on our parameter arrays from above:","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"##### Define components\n# Parameter naming convention (see params.jl):\n# ALL_CAPS: Fixed/derived/floorplanning parameter\n# lower_case: Tuning parameter\n(; # unpack named tuple of device parameters\n    FEEDLINE_STYLE,\n    FEEDLINE_BRIDGE,\n    CONTROL_BRIDGE,\n    RESONATOR_BRIDGE,\n    COUPLER_BRIDGE\n) = p.device\n\n### Transmons\n# Use `@component` macro to create a 5x5 array of components\n# where the `i`th qubit (in column-major order) is named \"q_$i\"\n@component q[1:5, 1:5] = ExampleStarTransmon begin\n    # Broadcast assignment (.=) so each qubit gets corresponding value from 5x5 parameter matrix\n    right_handed .= (MIRRORED_LR .⊻ MIRRORED_UD)\n    grounded_couplers .= GROUNDED_COUPLERS\n    island_inner_radius .= island_inner_radius\n    # Assignment not broadcasted so that all qubits get the same parameter\n    coupler_style = coupler_style\n    coupler_bridge = COUPLER_BRIDGE\n    resonator_style = resonator_style\n    xy_style = control_style\n    z_style = control_style\n    control_bridge = CONTROL_BRIDGE\nend\n### Readout\n@component readout[1:5, 1:5] = ExampleFilteredHairpinReadout begin\n    filter_total_effective_length .= p.readout.RO_EFFECTIVE_LENGTH\n    readout_total_effective_length .= p.readout.RO_EFFECTIVE_LENGTH\n    resonator_style = resonator_style\n    resonator_bridge = RESONATOR_BRIDGE\n    feedline_style = FEEDLINE_STYLE\n    feedline_tap_style = FEEDLINE_STYLE\n    feedline_bridge = FEEDLINE_BRIDGE\nend\n# Manually set a few exceptions for floorplanning convenience\nreadout[3, 1] = readout[3, 1](; extra_filter_l1=400μm)\nreadout[2, 5] = readout[2, 5](; extra_filter_l1=700μm)\nreadout[3, 3] = readout[3, 3](;\n    extra_filter_l1=550μm,\n    tap_position=0.45mm,\n    extra_filter_l2=710μm,\n    extra_filter_θ1=45°,\n    extra_filter_θ2=-45°,\n    straight_length=1.0mm\n)\nreadout[4, 1] = readout[4, 1](; extra_filter_l1=700μm)","category":"page"},{"location":"examples/qpu17/#Connecting-components","page":"Quantum Processor","title":"Connecting components","text":"","category":"section"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"Next, we add components to the graph and connect them using add_node! and fuse!:","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"# Continuing `assemble_schematic_graph!`\n##### Assemble schematic\n### Chip and launchers\nchip = add_node!(g, ExampleChip())\nlaunchers = example_launcher.(p.routing.LINE_SPECIFICATIONS)\nport_nodes = similar(p.routing.LINE_SPECIFICATIONS, ComponentNode) # Vector to hold launcher nodes\nfor (idx, launcher) in enumerate(launchers)\n    isnothing(launcher) && continue\n    port_nodes[idx] = # Fuse hook named port_$idx on chip to hook p0 on launcher\n        fuse!(g, chip => Symbol(\"port_$idx\"), launcher => :p0)\nend\n\n### Qubits\nq_nodes = similar(ACTIVE_SITES, Any) # Array to hold qubit nodes\nq_nodes[ACTIVE_SITES] .= add_node!.(g, q[ACTIVE_SITES])\nfor (I, site_active) in pairs(IndexCartesian(), ACTIVE_SITES[1:4, 1:4])\n    !site_active && continue\n    row, col = Tuple(I)\n    if ACTIVE_SITES[row + 1, col] # Neighbor in next row (below)\n        h1 = MIRRORED_UD[I] ? :coupler_N : :coupler_S\n        h2 = MIRRORED_UD[row + 1, col] ? :coupler_S : :coupler_N\n        fuse!(g, q_nodes[I] => h1, q_nodes[row + 1, col] => h2)\n    end\n    if ACTIVE_SITES[row, col + 1] # Neighbor in next column (to the right)\n        h1 = MIRRORED_LR[I] ? :coupler_W : :coupler_E\n        h2 = MIRRORED_LR[row, col + 1] ? :coupler_E : :coupler_W\n        fuse!(g, q_nodes[I] => h1, q_nodes[row, col + 1] => h2)\n    end\nend\nfuse!(g, chip => :origin, q_nodes[3, 3] => :origin) # Center the lattice at chip origin\n\n### Readout resonators\nreadout_nodes = similar(q_nodes) # Array to hold readout nodes\nfor (I, site_active) in pairs(IndexCartesian(), ACTIVE_SITES)\n    !site_active && continue\n    readout_nodes[I] = fuse!(g, q_nodes[I] => :readout, readout[I] => :qubit)\nend","category":"page"},{"location":"examples/qpu17/#Defining-routes","page":"Quantum Processor","title":"Defining routes","text":"","category":"section"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"We complete the schematic graph by defining routes:","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"# ... continuing `assemble_schematic_graph!`\n### Routing\nroute_nodes = add_routes!(g, port_nodes, q_nodes, readout_nodes, p)\n### Return nodes organized as a NamedTuple for later convenience\nreturn (; chip, port_nodes, q_nodes, readout_nodes, route_nodes)","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"Routes in DeviceLayout.jl are flexible elements used to create paths without having to know ahead of time exactly what the path looks like. We use the following rules for routing:","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"# params.jl\n## Route rules\nS45_LOOSE = Paths.StraightAnd45(min_bend_radius=50μm)  # No max radius, use all available space\nS90_TIGHT = Paths.StraightAnd90(min_bend_radius=50μm, max_bend_radius=50μm)\nCONTROL_ROUTE_RULE = S45_LOOSE\nREADOUT_ROUTE_RULE = S90_TIGHT","category":"page"},{"location":"examples/qpu17/#Control-lines","page":"Quantum Processor","title":"Control lines","text":"","category":"section"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"We define the ports as well as waypoints for control routing in the LINE_SPECIFICATIONS parameter:","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"# params.jl\n## Control and readout line specs in order of port number\nLINE_SPECIFICATIONS = [# Manual port assignment, we'll just list them out\n    # (\"type of line\", (row, col), [routing waypoints]),\n    # Clockwise from the top edge, NW corner\n    (\"Z\", (2, 2), [Point(-3600, 3800)]μm),\n    (\"XY\", (1, 2), [Point(-4100, 4900)]μm),\n    (\"RO_OUT\", 1, []), # RO routing waypoints are handled separately\n    (\"Z\", (1, 2), []),\n    (\"Z\", (3, 3), [Point(-1200, 5000), Point(-900, 2500), Point(-800, 1200)]μm),\n    nothing, # Unused port\n    (\"Z\", (1, 3), []),\n    (\"RO_OUT\", 2, []),\n    (\"XY\", (1, 3), [Point(2400, 4900)]μm),\n    (\"Z\", (2, 3), [Point(2250, 4400)]μm),\n    (\"XY\", (2, 3), [Point(2900, 3700)]μm),\n    (\"Z\", (2, 4), []),\n    # NE corner\n    (\"XY\", (2, 4), []),\n    (\"Z\", (2, 5), []),\n    (\"RO_IN\", 2, []),\n    (\"XY\", (2, 5), []),\n    nothing,\n    nothing,\n    (\"XY\", (3, 5), []),\n    (\"RO_IN\", 3, []),\n    (\"Z\", (3, 5), [Point(5000, -1800)]μm),\n    (\"XY\", (3, 4), [Point(4600, -2300)]μm),\n    (\"Z\", (3, 4), [Point(4600, -3000)]μm),\n    (\"XY\", (4, 4), [Point(4200, -3000)]μm),\n    # SE corner\n    (\"Z\", (4, 4), [Point(4100, -4200)]μm),\n    (\"XY\", (5, 4), [Point(4100, -4600)]μm),\n    (\"RO_OUT\", 3, []),\n    (\"Z\", (5, 4), []),\n    nothing,\n    nothing,\n    (\"Z\", (5, 3), []),\n    (\"RO_OUT\", 4, []),\n    (\"XY\", (5, 3), [Point(-2400, -4600)]μm),\n    (\"Z\", (4, 3), []),\n    (\"XY\", (4, 3), [Point(-3300, -4100)]μm),\n    (\"Z\", (4, 2), []),\n    # SW corner\n    (\"XY\", (4, 2), []),\n    (\"Z\", (4, 1), []),\n    (\"RO_IN\", 4, []),\n    (\"XY\", (4, 1), []),\n    nothing,\n    (\"XY\", (3, 3), [Point(-1000, -200)]μm),\n    (\"XY\", (3, 1), []),\n    (\"RO_IN\", 1, []),\n    (\"Z\", (3, 1), [Point(-5300, 2100)]μm),\n    (\"XY\", (3, 2), [Point(-5150, 2250), Point(-4175, 1375)]μm),\n    (\"Z\", (3, 2), [Point(-3375, 1800)]μm),\n    (\"XY\", (2, 2), [Point(-2560, 1900)]μm)\n]","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"The control lines use StraightAnd45 routing with no maximum bend radius. Each route will be allowed to make a single 45-degree turn before each waypoint and up to two turns before its endpoint.","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"Creating the routes then looks like this, in routing.jl, where we route! from each control port to the appropriate hook on the qubit at its target site, passing through any waypoints provided:","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"# routing.jl\nfunction add_control!(g, port_nodes, q_nodes, p)\n    (; S90_TIGHT, CONTROL_ROUTE_RULE, LINE_SPECIFICATIONS) = p.routing\n    # Make containers to hold the route nodes for each group, for later convenience\n    xy_nodes = ComponentNode[]\n    z_nodes = ComponentNode[]\n    for (idx, linespec) in enumerate(LINE_SPECIFICATIONS)\n        # Check for `nothing` first so we can unpack safely\n        (isnothing(linespec) || contains(linespec[1], \"RO\")) && continue\n        role, target, wp = linespec # Unpack tuple\n        if role == \"XY\"\n            rule = target == (3, 3) ? S90_TIGHT : CONTROL_ROUTE_RULE\n            node = route!(\n                g,\n                rule,\n                port_nodes[idx] => :p1,\n                q_nodes[target...] => :xy,\n                p.device.FEEDLINE_STYLE,\n                METAL_NEGATIVE;\n                name=uniquename(\"r_xy_$idx\"),\n                waypoints=wp,\n                global_waypoints=true\n            )\n            push!(xy_nodes, node)\n        elseif role == \"Z\"\n            node = route!(\n                g,\n                CONTROL_ROUTE_RULE,\n                port_nodes[idx] => :p1,\n                q_nodes[target...] => :z,\n                p.device.FEEDLINE_STYLE,\n                METAL_NEGATIVE;\n                name=uniquename(\"r_z_$idx\"),\n                waypoints=wp,\n                global_waypoints=true\n            )\n            push!(z_nodes, node)\n        end\n    end\n    return xy_nodes, z_nodes\nend","category":"page"},{"location":"examples/qpu17/#Readout-lines","page":"Quantum Processor","title":"Readout lines","text":"","category":"section"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"Next, we define the readout routes. There are four readout lines, and we specify the sites on each line in the parameter READOUT_GROUPS:","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"# params.jl\nREADOUT_GROUPS = [ # Which sites are on which line?\n    [(3, 1), (3, 2), (3, 3), (2, 2), (1, 2)], # readout line 1\n    [(2, 5), (2, 4), (2, 3), (1, 3)], # readout line 2\n    [(3, 5), (3, 4), (4, 4), (5, 4)], # readout line 3\n    [(4, 1), (4, 2), (4, 3), (5, 3)] # readout line 4\n]","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"We use global routing waypoints in RO_WAYPOINTS to control the overall path of each leg:","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"# params.jl\nRO_WAYPOINTS = [\n    [ # Group 1\n        [], # RO_IN_1 to (3, 1)\n        [Point(-4900, 2300)]μm, # (3, 1) to (3, 2)\n        [Point(-3100, 1700)]μm, # (3, 2) to (3, 3)\n        [Point(-3220, 2400)]μm, # (3, 3) to (2, 2)\n        [], # (2, 2) to (1, 2)\n        [] # (1, 2) to RO_OUT_1\n    ],\n    # Group 2\n    [[], [Point(5000, 4300)]μm, [Point(3050, 4050)]μm, [Point(1900, 3800)]μm, []],\n    # Group 3\n    [[], [Point(4800, -2300)]μm, [Point(3600, -2700)]μm, [Point(3600, -4400)]μm, []],\n    # Group 4\n    [[], [Point(-5000, -4300)]μm, [Point(-3050, -4050)]μm, [Point(-1900, -4500)]μm, []]\n]","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"We also use a utility function defined for this script (meander_waypoints) to add meanders to different sections of the readout line, based on a specification that defines the additional length required and the space available for meandering, stored in RO_MEANDER_PARAMS:","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"# params.jl\nRO_MEANDER_PARAMS = [\n    [ # Group 1\n        (;),\n        (; addlength=4.57mm, dir=-45°, dx=1000μm, dy=520μm), # (3, 1) to (3, 2)\n        (;), # (3, 2) to (3, 3)\n        (; addlength=3.8mm, dir=135°, dx=1000μm, dy=400μm), # (3, 3) to (2, 2)\n        (;) # (2, 2) to (1, 2)\n    ],\n    # Group 2\n    [\n        (;),\n        (; addlength=4.0mm, dir=-135°, dx=1300μm, dy=-500μm),\n        (;),\n        (; addlength=4.0mm, dir=45°, dx=1000μm, dy=-400μm)\n    ],\n    # Group 3\n    [(;), (; addlength=3.0mm, dir=135°, dx=1000μm, dy=-400μm), (;), (;)],\n    # Group 4\n    [\n        (;),\n        (; addlength=5.15mm, dir=45°, dx=1400μm, dy=-500μm),\n        (; addlength=4.8mm, dir=45°, dx=1000μm, dy=-500μm),\n        (;)\n    ]\n]","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"The code that creates the routes then looks like this:","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"# routing.jl\nfunction add_readout!(g, port_nodes, readout_nodes, p)\n    (;\n        S45_LOOSE,\n        READOUT_ROUTE_RULE,\n        LINE_SPECIFICATIONS,\n        READOUT_GROUPS,\n        RO_WAYPOINTS,\n        RO_MEANDER_PARAMS\n    ) = p.routing\n    # Make a container to hold the readout route nodes for each group, for later convenience\n    readout_route_nodes = [ComponentNode[] for _ = 1:length(READOUT_GROUPS)]\n    for (idx, linespec) in enumerate(LINE_SPECIFICATIONS)\n        # Continue until we find RO_IN\n        isnothing(linespec) && continue # Check for `nothing` first so we can unpack safely\n        role, group, _ = linespec # Unpack tuple\n        role != \"RO_IN\" && continue\n        readout_sites = READOUT_GROUPS[group] # List of (row, col) sites on this readout line\n        prev = fuse!(g, port_nodes[idx] => :p1, p.device.RO_INPUT_CAPACITOR => :p0) # Input capacitor\n        rule = S45_LOOSE # First leg is always StraightAnd45 with arbitrary bend radius\n        for (idx_in_group, site) in enumerate(readout_sites)\n            next = readout_nodes[site...]\n            node = route!(\n                g,\n                rule,\n                prev => :p1,\n                next => :p0,\n                p.device.FEEDLINE_STYLE,\n                METAL_NEGATIVE;\n                name=uniquename(\"r_ro_$group\"),\n                waypoints=meander_waypoints(\n                    RO_WAYPOINTS[group][idx_in_group],\n                    RO_MEANDER_PARAMS[group][idx_in_group]\n                ),\n                global_waypoints=true\n            )\n            push!(readout_route_nodes[group], node)\n            prev = next\n            rule = READOUT_ROUTE_RULE\n        end\n\n        out = findfirst(rg -> rg == (\"RO_OUT\", group, []), LINE_SPECIFICATIONS)\n        node = route!(\n            g,\n            S45_LOOSE,\n            prev => :p1,\n            port_nodes[out] => :p1,\n            p.device.FEEDLINE_STYLE,\n            METAL_NEGATIVE;\n            name=uniquename(\"r_ro_$group\"),\n            waypoints=RO_WAYPOINTS[group][end],\n            global_waypoints=true\n        )\n        push!(readout_route_nodes[group], node)\n    end\n    return readout_route_nodes\nend","category":"page"},{"location":"examples/qpu17/#Floorplanning","page":"Quantum Processor","title":"Floorplanning","text":"","category":"section"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"So far, we just have an abstract representation of the device as a graph, with nodes representing instances of components and edges representing connections between them. There's no spatial information about the position and orientation of components, and the routes we defined have yet to be resolved into concrete paths.","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"Placement is taken care of with plan, which produces a Schematic containing both the schematic graph and spatial information:","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"#### Floorplanning (place and route)\n@time \"Floorplanning\" schematic = plan(g) # Place components and define routes","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"The first node we added to the graph (chip) will be placed at the origin of schematic's coordinate system. plan then traverses the graph, placing each node relative to already-placed nodes they are connected to. It's worth noting that our schematic graph has cycles, because we used fuse! earlier between every pair of coupled qubits, adding each corresponding edge in the schematic graph. This is fine because the cycles are consistent (it doesn't matter what order plan traverses the edges in a cycle); otherwise, plan would throw an error.","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"This also gives our routes starting and ending points and directions, allowing us to resolve them into concrete paths according to the rules and waypoints provided above. For example, we can now calculate the lengths of the readout lines. In this case, we've added meanders to make sure each filter resonator is coupled to a point within a couple millimeters of a voltage antinode for a standing wave at that site's frequency:","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"calculate_readout_lengths(nodes.readout_nodes, nodes.route_nodes.readout, p)","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"Group 1:\nLength at (3, 1): 0.6297279533454594 mm\nLength to next halfwave: 7.697840324432319 mm (-0.6297279533454594 mm)\nLength at (3, 2): 7.590259963940551 mm\nLength to next halfwave: 0.29901524658576395 mm (-7.590259963940551 mm)\nLength at (3, 3): 9.16670034525075 mm\nLength to next halfwave: 8.468150125337488 mm (-0.3492751099566314 mm)\nLength at (2, 2): 15.60581099960854 mm\nLength to next halfwave: 0.5991867301211897 mm (-7.503312134743675 mm)\nLength at (1, 2): 17.896343010203637 mm\nLength to next halfwave: 7.800153389796365 mm (-0.7653454102036357 mm)\nGroup 2:\nLength at (2, 5): 0.3682037711044196 mm\nLength to next halfwave: 8.321432692663695 mm (-0.3682037711044196 mm)\nLength at (2, 4): 7.058735781699508 mm\nLength to next halfwave: 0.9357297649671584 mm (-7.058735781699508 mm)\nLength at (2, 3): 9.349267792294606 mm\nLength to next halfwave: 7.540448151367366 mm (-0.9044098204636201 mm)\nLength at (1, 3): 15.639799802889703 mm\nLength to next halfwave: 0.7871841971102953 mm (-7.4263078028897045 mm)\nGroup 3:\nLength at (3, 5): 0.6615492126596462 mm\nLength to next halfwave: 7.440949652205219 mm (-0.6615492126596462 mm)\nLength at (3, 4): 5.9520812232547335 mm\nLength to next halfwave: 1.9371939872715818 mm (-5.9520812232547335 mm)\nLength at (4, 4): 8.242613233849829 mm\nLength to next halfwave: 0.08495504392794799 mm (-8.242613233849829 mm)\nLength at (5, 4): 10.533145244444926 mm\nLength to next halfwave: 6.597852355555074 mm (-1.9676464444449264 mm)\nGroup 4:\nLength at (4, 1): 0.36820377110442065 mm\nLength to next halfwave: 8.321432692663695 mm (-0.36820377110442065 mm)\nLength at (4, 2): 8.208735781699511 mm\nLength to next halfwave: 0.0047562183004887775 mm (-8.208735781699511 mm)\nLength at (4, 3): 15.299267792294614 mm\nLength to next halfwave: 0.6896633010387179 mm (-7.304802245627949 mm)\nLength at (5, 3): 17.58979980288971 mm\nLength to next halfwave: 7.744774112603247 mm (-0.7000838592277392 mm)","category":"page"},{"location":"examples/qpu17/#Schematic-design-rule-checking","page":"Quantum Processor","title":"Schematic design rule checking","text":"","category":"section"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"Before going further, we run check! to make sure the schematic follows any desired rules. Here, we only use the default rotations_valid rule, which checks that any components that must be oriented in certain ways are oriented correctly. You can define other rules as part of your PDK and use the rules keyword argument in check! to run those checks.","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"@time \"Schematic design rule checking\" check!(schematic) # Make sure schematic follows any relevant rules","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"In this case, the only components to check are the ExampleSimpleSQUID subcomponents of our transmons, which must be oriented so that junction leads run north to south. This is enabled by defining check_rotation and allowed_rotation_angles methods for that component.","category":"page"},{"location":"examples/qpu17/#Finishing-touches","page":"Quantum Processor","title":"Finishing touches","text":"","category":"section"},{"location":"examples/qpu17/#Crossovers","page":"Quantum Processor","title":"Crossovers","text":"","category":"section"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"Our routing has control lines that intersect with readout lines. One way to handle a route crossing would be to define a crossover component, place it at fixed location on the chip, then route your lines to the crossover. We also have control lines that intersect transmon couplers, as well as a readout resonator that crosses a coupler. This is a little trickier but could be handled in a similar way.","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"Instead, we'll use DeviceLayout.jl's automatic crossover generation to make these paths hop over one another without having to know in advance exactly where the crossings occur. Any Path or RouteComponent that intersects another—including those nested within composite components, like transmon coupler paths or resonator sections—can be used with this functionality.","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"We use the simple built-in AirBridge crossover style, with parameters set in params.jl:","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"# params.jl\n# Crossover style (simple scaffolded bridge, not optimized for microwave properties)\nXSTY = Intersect.AirBridge(\n    crossing_gap=5μm,\n    foot_gap=3μm,\n    foot_length=10μm,\n    extent_gap=3μm,\n    scaffold_gap=3μm,\n    scaffold_meta=LayerVocabulary.BRIDGE_BASE,\n    air_bridge_meta=LayerVocabulary.BRIDGE\n)","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"We then call crossovers!:","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"@time \"Generating crossovers\" SchematicDrivenLayout.crossovers!(schematic, XSTY)","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"This call checks all segment pairs for intersections, which can be slow in large devices. If you know which component nodes cross, you can feed only those to crossovers! to save time. (That can also  give you finer-grained control over which lines hop over which—by default, routes hop over explicit paths, and components added to the schematic graph later will cross over those added earlier.)","category":"page"},{"location":"examples/qpu17/#Air-bridges","page":"Quantum Processor","title":"Air bridges","text":"","category":"section"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"We often want to place bridges over coplanar waveguides to connect the ground planes on either side of the signal trace. In this case, we use a simple utility function defined in ExamplePDK to place a bridge in the center of every Path segment.","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"SchematicDrivenLayout.ExamplePDK.add_bridges!","category":"page"},{"location":"examples/qpu17/#DeviceLayout.SchematicDrivenLayout.ExamplePDK.add_bridges!","page":"Quantum Processor","title":"DeviceLayout.SchematicDrivenLayout.ExamplePDK.add_bridges!","text":"add_bridges!(schematic, bridge=FEEDLINE_BRIDGE; spacing=200μm, margin=50μm)\n\nExample utility for adding bridges. Not optimized for microwave properties.\n\nFinds all top-level Paths and RouteComponents in schematic. For Paths, places a bridge in the middle of any path segment with length of at least margin. For RouteComponents, places a bridge at every spacing, with no bridges within a margin of margin from the start and end.\n\n\n\n\n\nadd_bridges!(path::Path, bridge; margin=50μm)\n\nExample utility for adding bridges. Not optimized for microwave properties.\n\nPlaces a bridge in the middle of any path segment with length of at least margin.\n\n\n\n\n\n","category":"function"},{"location":"examples/qpu17/#Ground-plane-hole-autofill","page":"Quantum Processor","title":"Ground-plane hole autofill","text":"","category":"section"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"Many quantum devices fill the ground plane with small holes to reduce loss associated with magnetic vortices. We make a coordinate system holding a single hole, generate an exclusion zone around components using halo, and use autofill! to place holes on grid points outside the exclusion zone.","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"#### Autofill with ground plane holes\nhole_cs = CoordinateSystem(\"gnd_hole\") # Coordinate system for a single hole\nplace!(hole_cs, Circle(GROUND_HOLE_RADIUS), METAL_NEGATIVE)\nbnds = bounds(schematic, find_components(ExampleChip, schematic)...) # bounds of the chip node\nexclusion = make_halo(50μm; ignore_layers=[CHIP_AREA]) # function to create exclusion area\nx_grid = (lowerleft(bnds).x + 600μm):GROUND_HOLE_SPACING:(upperright(bnds).x - 600μm) # raster x-coordinates\ny_grid = (lowerleft(bnds).y + 600μm):GROUND_HOLE_SPACING:(upperright(bnds).y - 600μm) # raster y-coordinates\n@time \"Ground-plane hole fill\" autofill!(schematic, hole_cs, x_grid, y_grid, exclusion)","category":"page"},{"location":"examples/qpu17/#Rendering","page":"Quantum Processor","title":"Rendering","text":"","category":"section"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"We now have the final device in a \"DeviceLayout.jl-native\" representation, but we need to output a GDSII file. To do this, we render! the schematic to a Cell, which draws all shapes as Polygons and maps our named layers (SemanticMeta) to GDS layer and datatype (GDSMeta). The rendering settings (including the layer mapping) are provided by DemoQPU17.L1_TARGET.","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"#### Render results to Cell for GDS export\n# Equivalent one-liner to the below: artwork = Cell(schematic, L1_TARGET)\nartwork = Cell(\"qpu17_demo\") # \"artwork\" = \"pattern used for fabrication\"\n@time \"Rendering to polygons\" render!(artwork, schematic, L1_TARGET)","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"Because our design includes some components rotated at 45 degree angles, we have to flatten the Cell before saving to avoid 1nm gaps in the result. To keep the file from getting too big, we specify max_copy=100. That is, any Cell that gets referenced more than 100 times (including the Cell containing the ground-plane hole and those containing bridges) will not have its contents copied to the top level that many times, but instead remains stored as a Cell with repeated references.","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"# Flatten to avoid 1nm gaps from rounded Cell origins + non-Manhattan rotations\n# But don't flatten references with more than 100 copies, we'd end up with 10k hole polygons\n@time \"Flattening cells\" flatten!(artwork, max_copy=100)\nsavegds && @time \"Saving\" save(\"qpu17_demo.gds\", artwork)","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"And now we're done!","category":"page"},{"location":"examples/qpu17/#Aside:-Rendering-flipchip-devices","page":"Quantum Processor","title":"Aside: Rendering flipchip devices","text":"","category":"section"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"The \"L1\" in our L1_TARGET holding the rendering settings stands for \"Level 1\", referring to the usual chip surface in a single-chip device. If this were a flipchip device, we could render each level separately:","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"l1_artwork = Cell(\"demo_L1_artwork\")\nl2_overlay = Cell(\"demo_L2_overlay\")\nl2_artwork = Cell(\"demo_L2_artwork\")\n\nrender!(l1_artwork, schematic, L1_TARGET)\nrender!(l2_overlay, schematic, L2_TARGET)\n# L2 needs to be mirrored to get the artwork for fabrication\naddref!(l2_artwork, l2_overlay, xrefl=true)","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"We can also render the assembly for visualization. We could just write assembly = Cell(\"assembly\"); addref!(assembly, l1_artwork); addref!(assembly, l2_overlay), but we'd end up with duplicate Cell names—for each Cell in the hierarchy, there's now a version with L1 polygons and one with L2 polygons—which the GDSII format doesn't like. Also, if the L1 and L2 chips share a technology, then the GDS won't distinguish levels—the same semantic layers on either chip will be mapped to the same GDS layers. Instead, we'll want to render everything again with the assembly target from the example PDK, which automatically adds 300 to the layer number of L2 polygons:","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"assembly = Cell(schematic, ASSEMBLY_TARGET)","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"This duplicates some work if we already rendered L1 and L2 separately, but it's fast enough that we don't really care.","category":"page"},{"location":"examples/qpu17/#Another-aside:-Debugging","page":"Quantum Processor","title":"Another aside: Debugging","text":"","category":"section"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"Sometimes a schematic's connectivity makes plan infeasible, a component's geometry contains an error, or a route turns out to be infeasible given the waypoints and routing rule you provided. Error messages and stack traces will tell you exactly what failed, but are often too granular to easily make sense of without a visual aid.","category":"page"},{"location":"examples/qpu17/","page":"Quantum Processor","title":"Quantum Processor","text":"To help with debugging, you can run plan and render! with the keyword strict=:no. This logs the error, skips the problematic component, and continues on planning or rendering, so that you can inspect the partial result to see what failed.","category":"page"},{"location":"solidmodels/#Solid-Models","page":"Solid Models (3D Geometry)","title":"Solid Models","text":"","category":"section"},{"location":"solidmodels/","page":"Solid Models (3D Geometry)","title":"Solid Models (3D Geometry)","text":"    SolidModel\n    SolidModels.SolidModelKernel","category":"page"},{"location":"solidmodels/#DeviceLayout.SolidModels.SolidModel","page":"Solid Models (3D Geometry)","title":"DeviceLayout.SolidModels.SolidModel","text":"struct SolidModel{T} where {T <: SolidModelKernel}\n    name::String\n    groups::NTuple{4,Dict{String,AbstractPhysicalGroup}}\nend\nSolidModel(name::String, kernel=OpenCascade; overwrite=false)\n\nA 3D geometry model.\n\nGeometry rendering, boolean operations, and export are provided by the specified kernel.\n\nPhysical groups can be accessed by name using indexing with a String or Symbol and a dimension: mymodel[\"mygroup\", 3] will return the PhysicalGroup with dimension 3 called mygroup.\n\nPhysical groups can also be assigned as mymodel[\"mygroup\"] = dimtags, where dimtags is a list of NTuple{2, Int32} of entities identified by (dim, tag) in mymodel. If dimtags includes entities of multiple dimensions, then a group is created for each dimension.\n\nIf the constructor is called with overwrite=false (the default), then an error will be thrown if a model with the same name already exists. If overwrite=true, then any existing model with the same name will be deleted and a new model will be created.\n\nA SolidModel can be saved to a file with FileIO.save(filename, sm). Supported filetypes for OpenCASCADE geometries are .brep and .stp. Meshes can be exported as .msh2 (compatible with Palace) or .msh (most recent Gmsh format) files.\n\n\n\n\n\n","category":"type"},{"location":"solidmodels/#DeviceLayout.SolidModels.SolidModelKernel","page":"Solid Models (3D Geometry)","title":"DeviceLayout.SolidModels.SolidModelKernel","text":"abstract type SolidModelKernel\n\nSupertype for solid geometry kernels. Subtypes are OpenCascade and GmshNative.\n\nNote that GmshNative does not support Boolean geometry operations.\n\n\n\n\n\n","category":"type"},{"location":"solidmodels/#Physical-groups","page":"Solid Models (3D Geometry)","title":"Physical groups","text":"","category":"section"},{"location":"solidmodels/","page":"Solid Models (3D Geometry)","title":"Solid Models (3D Geometry)","text":"    SolidModels.PhysicalGroup\n    SolidModels.dimtags\n    SolidModels.entitytags","category":"page"},{"location":"solidmodels/#DeviceLayout.SolidModels.PhysicalGroup","page":"Solid Models (3D Geometry)","title":"DeviceLayout.SolidModels.PhysicalGroup","text":"struct PhysicalGroup\n    name::String\n    model::SolidModel\n    dim::Int32\n    grouptag::Int32\nend\n\nA named group of entities of dimension dim in a SolidModel.\n\n\n\n\n\n","category":"type"},{"location":"solidmodels/#DeviceLayout.SolidModels.dimtags","page":"Solid Models (3D Geometry)","title":"DeviceLayout.SolidModels.dimtags","text":"dimtags(pg::AbstractPhysicalGroup)\n\nReturn the (dimension, integer tag) tuples for SolidModel entities in pg.\n\n\n\n\n\n","category":"function"},{"location":"solidmodels/#DeviceLayout.SolidModels.entitytags","page":"Solid Models (3D Geometry)","title":"DeviceLayout.SolidModels.entitytags","text":"entitytags(pg::AbstractPhysicalGroup)\n\nReturn the integer tags for SolidModel entities in pg.\n\n\n\n\n\n","category":"function"},{"location":"solidmodels/#Rendering-to-a-SolidModel","page":"Solid Models (3D Geometry)","title":"Rendering to a SolidModel","text":"","category":"section"},{"location":"solidmodels/","page":"Solid Models (3D Geometry)","title":"Solid Models (3D Geometry)","text":"    render!(::SolidModel, ::CoordinateSystem; kwargs...)\n    SolidModels.to_primitives","category":"page"},{"location":"solidmodels/#DeviceLayout.render!-Tuple{SolidModel, CoordinateSystem}","page":"Solid Models (3D Geometry)","title":"DeviceLayout.render!","text":"render!(sm::SolidModel, cs::AbstractCoordinateSystem{T}; map_meta=layer, postrender_ops=[], zmap=(_) -> zero(T), kwargs...) where {T}\n\nRender cs to sm.\n\nKeywords\n\nmap_meta: Function (m::SemanticMeta) -> name of PhysicalGroup (as String or Symbol; may also return nothing to skip rendering m)\npostrender_ops: Vector of Tuples (destination, op, args, op_kwargs...) specifying \"postrendering\" of PhysicalGroups executed after entities have been rendered to to sm. Each operation op creates a new PhysicalGroup defined as sm[destination] = op(sm, args...; op_kwargs...). That is, args are the arguments to op (following the first argument, which is always the model sm being rendered to). For most operations, these arguments include the names and dimensions of groups being operated on, and op_kwargs are the keyword arguments passed to op. For example, (\"base\", difference_geom!, (\"writeable_area\", \"base_negative\"), :remove_object => true, :remove_tool => true) defines a postrendering step that subtracts the PhysicalGroup named \"base_negative\" from \"writeable_area\" (by default using dimension 2 for each group) to define a new group called \"base\". The keyword pairs :remove_object=>true and :remove_tool=>true mean that the \"object\" (first argument) group \"writeable_area\" and the \"tool\" (second argument) group \"base_negative\" are both removed when \"base\" is created.\nzmap: Function (m::SemanticMeta) -> z coordinate of corresponding elements. Default: Map all metadata to zero.\nmeshing_parameters: MeshingParameters allows customization of the top level meshing parameters when calling Gmsh.\n\nAvailable postrendering operations are translate!, extrude_z!, revolve!, union_geom!, intersect_geom!, difference_geom!, fragment_geom!, and box_selection. (The geometric Boolean operations are only available for models using the OpenCASCADE kernel.)\n\nAdditional keyword arguments are passed to SolidModels.to_primitives (which falls back to to_polygons) and may be used for certain entity types to control how entities of cs are converted to primitives and added to sm.\n\n\n\n\n\n","category":"method"},{"location":"solidmodels/#DeviceLayout.SolidModels.to_primitives","page":"Solid Models (3D Geometry)","title":"DeviceLayout.SolidModels.to_primitives","text":"to_primitives(::SolidModel, ent::GeometryEntity; kwargs...)\n\nReturn a GeometryEntity or a vector of entities equivalent to ent.\n\nCalled inside render! before adding entities to the SolidModel. Each resulting entity corresponds to a single entity in that SolidModel's geometry kernel.\n\nIf there is no special handling for ent in the kernel, then the result will be to_polygons(ent; kwargs...).\n\n\n\n\n\n","category":"function"},{"location":"solidmodels/#Postrendering-operations","page":"Solid Models (3D Geometry)","title":"Postrendering operations","text":"","category":"section"},{"location":"solidmodels/","page":"Solid Models (3D Geometry)","title":"Solid Models (3D Geometry)","text":"After adding the elements of a CoordinateSystem to a SolidModel (\"rendering\"), we can perform additional \"postrendering\" operations including boolean operations, extrusions, and selections, to create new PhysicalGroups.","category":"page"},{"location":"solidmodels/","page":"Solid Models (3D Geometry)","title":"Solid Models (3D Geometry)","text":"The recommended pattern is to provide all postrendering operations to the postrender_ops keyword argument in render!, because render! performs important cleanup at the very end. Specifically, it removes duplicate elements using the fragment operation; because this can also change the labeling of elements, it then reassigns the resulting elements to their corresponding groups.","category":"page"},{"location":"solidmodels/","page":"Solid Models (3D Geometry)","title":"Solid Models (3D Geometry)","text":"Boolean operations and infix equivalents:","category":"page"},{"location":"solidmodels/","page":"Solid Models (3D Geometry)","title":"Solid Models (3D Geometry)","text":"    SolidModels.difference_geom!\n    SolidModels.fragment_geom!\n    SolidModels.intersect_geom!\n    SolidModels.union_geom!\n    SolidModels.:+(::SolidModels.AbstractPhysicalGroup, ::SolidModels.AbstractPhysicalGroup)\n    SolidModels.:∪(::SolidModels.AbstractPhysicalGroup, ::SolidModels.AbstractPhysicalGroup)\n    SolidModels.:-(::SolidModels.AbstractPhysicalGroup, ::SolidModels.AbstractPhysicalGroup)\n    SolidModels.:*(::SolidModels.AbstractPhysicalGroup, ::SolidModels.AbstractPhysicalGroup)\n    SolidModels.:∩(::SolidModels.AbstractPhysicalGroup, ::SolidModels.AbstractPhysicalGroup)","category":"page"},{"location":"solidmodels/#DeviceLayout.SolidModels.difference_geom!","page":"Solid Models (3D Geometry)","title":"DeviceLayout.SolidModels.difference_geom!","text":"difference_geom!(\n    object::Union{PhysicalGroup, AbstractArray{PhysicalGroup}},\n    tool::Union{PhysicalGroup, AbstractArray{PhysicalGroup}};\n    tag=-1,\n    remove_object=false,\n    remove_tool=false\n)\n\nCreate the geometric difference of the groups object and tool.\n\nReturn the resulting entities as a vector of (dimension, entity_tag) Tuples.\n\nIf tag is positive, try to set the tag explicitly (only valid if the boolean operation results in a single entity). Remove the object if remove_object is set. Remove the tool if remove_tool is set.\n\nThe operator - can be used as a synonymous infix operator.\n\n\n\n\n\ndifference_geom!(sm::SolidModel, object::Union{String, Symbol}, tool::Union{String, Symbol}, d1=2, d2=2;\n    tag=-1,\n    remove_object=false,\n    remove_tool=false)\n\nCreate the geometric difference of groups with Symbol or String names object, tool in sm.\n\nReturn the resulting entities as a vector of (dimension, entity_tag) Tuples.\n\nThe dimensions of the object and tool groups can be specified as d1 and d2, respectively. The dimension defaults to 2 (surfaces).\n\nIf the tag is positive, try to set the tag explicitly (only valid if the boolean operation results in a single entity). Remove the object if remove_object is set. Remove the tool if remove_tool is set.\n\nIf object is not a physical group in sm, will error and return an empty dimtag array. If tool is not a physical group in sm, will return dimtags of object.\n\n\n\n\n\ndifference_geom!(sm::SolidModel, object, tool, d1=2, d2=2; remove_tool=false,\nremove_object=false, kwargs...)\n\nCreate the geometric difference of groups object and tool which can be collections of Union{String, Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"solidmodels/#DeviceLayout.SolidModels.fragment_geom!","page":"Solid Models (3D Geometry)","title":"DeviceLayout.SolidModels.fragment_geom!","text":"fragment_geom!(\n    object::Union{PhysicalGroup, AbstractArray{PhysicalGroup}},\n    tool::Union{PhysicalGroup, AbstractArray{PhysicalGroup}};\n    tag=-1,\n    remove_object=false,\n    remove_tool=false\n)\n\nCreate the Boolean fragments (general fuse) of the groups object and tool, making all interfaces conformal.\n\nWhen applied to entities of different dimensions, the lower dimensional entities will be automatically embedded in the higher dimensional entities if they are not on their boundary.\n\nReturn the resulting entities as a vector of (dimension, entity_tag) Tuples.\n\nIf tag is positive, try to set the tag explicitly (only valid if the boolean operation results in a single entity). Remove the object if remove_object is set. Remove the tool if remove_tool is set.\n\n\n\n\n\nfragment_geom!(sm::SolidModel, object::Union{String, Symbol}, tool::Union{String, Symbol}, d1=2, d2=2;\n    tag=-1,\n    remove_object=false,\n    remove_tool=false)\n\nCreate the Boolean fragments (general fuse) of groups with Symbol or String names object, tool in sm, making all interfaces conformal.\n\nWhen applied to entities of different dimensions, the lower dimensional entities will be automatically embedded in the higher dimensional entities if they are not on their boundary.\n\nReturn the resulting entities as a vector of (dimension, entity_tag) Tuples.\n\nThe dimensions of the object and tool groups can be specified as d1 and d2, respectively. The dimension defaults to 2 (surfaces).\n\nIf the tag is positive, try to set the tag explicitly (only valid if the boolean operation results in a single entity). Remove the object if remove_object is set. Remove the tool if remove_tool is set.\n\nIf only one of object or tool is a physical group in sm, will perform union of physical group with itself, if neither are present will return an empty array.\n\n\n\n\n\n","category":"function"},{"location":"solidmodels/#DeviceLayout.SolidModels.intersect_geom!","page":"Solid Models (3D Geometry)","title":"DeviceLayout.SolidModels.intersect_geom!","text":"intersect_geom!(\n    object::Union{PhysicalGroup, AbstractArray{PhysicalGroup}},\n    tool::Union{PhysicalGroup, AbstractArray{PhysicalGroup}};\n    tag=-1,\n    remove_object=false,\n    remove_tool=false\n)\n\nCreate the geometric intersection (the common parts) of the groups object and tool.\n\nReturn the resulting entities as a vector of (dimension, entity_tag) Tuples.\n\nIf tag is positive, try to set the tag explicitly (only valid if the boolean operation results in a single entity). Remove the object if remove_object is set. Remove the tool if remove_tool is set.\n\nThe operators * and ∩ can be used as synonymous infix operators.\n\n\n\n\n\nintersect_geom!(sm::SolidModel, object::Union{String, Symbol}, tool::Union{String, Symbol}, d1=2, d2=2;\n    tag=-1,\n    remove_object=false,\n    remove_tool=false)\n\nCreate the geometric intersection (the common parts) of groups with Symbol or String names object, tool in sm.\n\nReturn the resulting entities as a vector of (dimension, entity_tag) Tuples.\n\nThe dimensions of the object and tool groups can be specified as d1 and d2, respectively. The dimension defaults to 2 (surfaces).\n\nIf the tag is positive, try to set the tag explicitly (only valid if the boolean operation results in a single entity). Remove the object if remove_object is set. Remove the tool if remove_tool is set.\n\nIf tool or object are not physical groups in sm, will error and return an empty dimtag array.\n\n\n\n\n\n","category":"function"},{"location":"solidmodels/#DeviceLayout.SolidModels.union_geom!","page":"Solid Models (3D Geometry)","title":"DeviceLayout.SolidModels.union_geom!","text":"union_geom!(\n    object::Union{PhysicalGroup, AbstractArray{PhysicalGroup}},\n    tool::Union{PhysicalGroup, AbstractArray{PhysicalGroup}};\n    tag=-1,\n    remove_object=false,\n    remove_tool=false\n)\n\nCreate the geometric union (the fusion) of the groups object and tool.\n\nReturn the resulting entities as a vector of (dimension, entity_tag) Tuples.\n\nIf tag is positive, try to set the tag explicitly (only valid if the boolean operation results in a single entity). Remove the object if remove_object is set. Remove the tool if remove_tool is set.\n\nThe operators + and ∪ can be used as synonymous infix operators.\n\n\n\n\n\nunion_geom!(sm::SolidModel, object::Union{String, Symbol}, tool::Union{String, Symbol}, d1=2, d2=2;\n    tag=-1,\n    remove_object=false,\n    remove_tool=false)\n\nCreate the geometric union of groups with Symbol or String names object, tool in sm.\n\nReturn the resulting entities as a vector of (dimension, entity_tag) Tuples.\n\nThe dimensions of the object and tool groups can be specified as d1 and d2, respectively. The dimension defaults to 2 (surfaces).\n\nIf tag is positive, try to set the tag explicitly (only valid if the boolean operation results in a single entity). Remove the object if remove_object is set. Remove the tool if remove_tool is set.\n\nIf only one of object or tool is a physical group in sm, will perform union of physical group with itself, if neither are present will return an empty array.\n\n\n\n\n\n","category":"function"},{"location":"solidmodels/#Base.:+-Tuple{DeviceLayout.SolidModels.AbstractPhysicalGroup, DeviceLayout.SolidModels.AbstractPhysicalGroup}","page":"Solid Models (3D Geometry)","title":"Base.:+","text":"+(object::AbstractPhysicalGroup, tool::AbstractPhysicalGroup)\n\nEquivalent to union_geom!(object, tool). Can be used as an infix (object + tool).\n\n\n\n\n\n","category":"method"},{"location":"solidmodels/#Base.:∪-Tuple{DeviceLayout.SolidModels.AbstractPhysicalGroup, DeviceLayout.SolidModels.AbstractPhysicalGroup}","page":"Solid Models (3D Geometry)","title":"Base.:∪","text":"∪(object::AbstractPhysicalGroup, tool::AbstractPhysicalGroup)\n\nEquivalent to union_geom!(object, tool). Can be used as an infix (object ∪ tool).\n\n\n\n\n\n","category":"method"},{"location":"solidmodels/#Base.:--Tuple{DeviceLayout.SolidModels.AbstractPhysicalGroup, DeviceLayout.SolidModels.AbstractPhysicalGroup}","page":"Solid Models (3D Geometry)","title":"Base.:-","text":"-(object::AbstractPhysicalGroup, tool::AbstractPhysicalGroup)\n\nEquivalent to difference_geom!(object, tool). Can be used as an infix (object - tool).\n\n\n\n\n\n","category":"method"},{"location":"solidmodels/#Base.:*-Tuple{DeviceLayout.SolidModels.AbstractPhysicalGroup, DeviceLayout.SolidModels.AbstractPhysicalGroup}","page":"Solid Models (3D Geometry)","title":"Base.:*","text":"*(object::AbstractPhysicalGroup, tool::AbstractPhysicalGroup)\n\nEquivalent to intersect_geom!(object, tool). Can be used as an infix (object * tool).\n\n\n\n\n\n","category":"method"},{"location":"solidmodels/#Base.:∩-Tuple{DeviceLayout.SolidModels.AbstractPhysicalGroup, DeviceLayout.SolidModels.AbstractPhysicalGroup}","page":"Solid Models (3D Geometry)","title":"Base.:∩","text":"∩(object::AbstractPhysicalGroup, tool::AbstractPhysicalGroup)\n\nEquivalent to intersect_geom!(object, tool). Can be used as an infix (object ∩ tool).\n\n\n\n\n\n","category":"method"},{"location":"solidmodels/","page":"Solid Models (3D Geometry)","title":"Solid Models (3D Geometry)","text":"Selections:","category":"page"},{"location":"solidmodels/","page":"Solid Models (3D Geometry)","title":"Solid Models (3D Geometry)","text":"    SolidModels.box_selection\n    SolidModels.get_boundary","category":"page"},{"location":"solidmodels/#DeviceLayout.SolidModels.box_selection","page":"Solid Models (3D Geometry)","title":"DeviceLayout.SolidModels.box_selection","text":"box_selection(x1, y1, z1, x2, y2, z2; dim=-1, delta=zero(x1))\nbox_selection(::SolidModel, x1, y1, z1, x2, y2, z2; dim=-1, delta=zero(x1))\n\nGet the model entities in the bounding box defined by the two points (xmin, ymin, zmin) and (xmax, ymax, zmax). If dim is >= 0, return only the entities of the specified dimension (e.g. points if dim == 0).\n\nReturn the selected entities as a vector of (dimension, entity_tag) Tuples.\n\n\n\n\n\n","category":"function"},{"location":"solidmodels/#DeviceLayout.SolidModels.get_boundary","page":"Solid Models (3D Geometry)","title":"DeviceLayout.SolidModels.get_boundary","text":"get_boundary(group::AbstractPhysicalGroup; combined=true, oriented=true, recursive=false)\nget_boundary(sm::SolidModel, groupname, dim=2; combined=true, oriented=true, recursive=false)\n\nGet the boundary of the model entities in group, given as a vector of (dim, tag) tuples.\n\nReturn the boundary of the individual entities (if combined is false) or the boundary of the combined geometrical shape formed by all input entities (if combined is true).\n\nReturn tags multiplied by the sign of the boundary entity if oriented is true.\n\nApply the boundary operator recursively down to dimension 0 (i.e. to points) if recursive is true.\n\n\n\n\n\n","category":"function"},{"location":"solidmodels/","page":"Solid Models (3D Geometry)","title":"Solid Models (3D Geometry)","text":"Other operations:","category":"page"},{"location":"solidmodels/","page":"Solid Models (3D Geometry)","title":"Solid Models (3D Geometry)","text":"    SolidModels.extrude_z!\n    SolidModels.remove_group!\n    SolidModels.restrict_to_volume!\n    SolidModels.revolve!\n    SolidModels.translate!","category":"page"},{"location":"solidmodels/#DeviceLayout.SolidModels.extrude_z!","page":"Solid Models (3D Geometry)","title":"DeviceLayout.SolidModels.extrude_z!","text":"extrude_z!(g::PhysicalGroup, dz; num_elements=[], heights=[], recombine=false)\nextrude_z!(sm::SolidModel, groupname, dz, groupdim=2; num_elements=[], heights=[], recombine=false)\n\nExtrude the entities in g in the z direction by dz.\n\nIf the numElements vector is not empty, also extrude the mesh: the entries in numElements give the number of elements in each layer. If the height vector is not empty, it provides the (cumulative) height of the different layers, normalized to 1. If recombine is set, recombine the mesh in the layers.\n\nReturn the resulting entities as a vector of (dimension, entity_tag) Tuples.\n\n\n\n\n\n","category":"function"},{"location":"solidmodels/#DeviceLayout.SolidModels.remove_group!","page":"Solid Models (3D Geometry)","title":"DeviceLayout.SolidModels.remove_group!","text":"remove_group!(sm::SolidModel, group::Union{String, Symbol}, dim; recursive=true, remove_entities=false)\nremove_group!(group::AbstractPhysicalGroup; recursive=true, remove_entities=false)\n\nRemove entities in group from the model, unless they are boundaries of higher-dimensional entities.\n\nIf recursive is true, remove all entities on their boundaries, down to dimension zero (points).\n\nAlso removes the (now-empty) physical group.\n\n\n\n\n\n","category":"function"},{"location":"solidmodels/#DeviceLayout.SolidModels.restrict_to_volume!","page":"Solid Models (3D Geometry)","title":"DeviceLayout.SolidModels.restrict_to_volume!","text":"restrict_to_volume(sm::SolidModel, volume)\n\nReplace all entities and groups with their intersection with sm[volume, 3].\n\nEmbeds entities if they are on the boundary of higher-dimensional entities and removes duplicate entities.\n\nPreserves the meaning of existing groups by assigning to them the (possibly new) entities corresponding to that group's intersection with the volume.\n\n\n\n\n\n","category":"function"},{"location":"solidmodels/#DeviceLayout.SolidModels.revolve!","page":"Solid Models (3D Geometry)","title":"DeviceLayout.SolidModels.revolve!","text":"revolve!(g::PhysicalGroup, x, y, z, ax, ay, az, θ; num_elements=[], heights=[], recombine=false)\nrevolve!(sm::SolidModel, groupname, groupdim, x, y, z, ax, ay, az, θ; num_elements=[], heights=[], recombine=false)\n\nExtrude the entities in g using a rotation of θ radians around the axis of revolution through (x, y, z) in the direction (ax, ay, az).\n\nIf the numElements vector is not empty, also extrude the mesh: the entries in numElements give the number of elements in each layer. If the height vector is not empty, it provides the (cumulative) height of the different layers, normalized to 1. If recombine is set, recombine the mesh in the layers. When the mesh is extruded the angle should be strictly smaller than 2π.\n\nReturn the resulting entities as a vector of (dimension, entity_tag) Tuples.\n\n\n\n\n\n","category":"function"},{"location":"solidmodels/#DeviceLayout.SolidModels.translate!","page":"Solid Models (3D Geometry)","title":"DeviceLayout.SolidModels.translate!","text":"translate!(group, dx, dy, dz; copy=true)\ntranslate!(sm::SolidModel, groupname, dx, dy, dz, groupdim=2; copy=true)\n\nTranslate the entities in physical group group by (dx, dy, dz).\n\nIf copy=true, then a copy of the entities in group are translated instead.\n\nReturn the resulting entities as a vector of (dimension, entity_tag) Tuples.\n\n\n\n\n\n","category":"function"},{"location":"solidmodels/#Meshing","page":"Solid Models (3D Geometry)","title":"Meshing","text":"","category":"section"},{"location":"solidmodels/","page":"Solid Models (3D Geometry)","title":"Solid Models (3D Geometry)","text":"Entities can carry mesh sizing information with them when rendered to a SolidModel. Many entities will default to a maximal size to reasonably resolve the geometry. This is particularly useful together with adaptive mesh refinement to efficiently refine your mesh to minimize estimated error with as few elements as possible. You can also style entities with MeshSized to manually control mesh sizing, and provide MeshingParameters to render! using the meshing_parameters keyword argument.","category":"page"},{"location":"solidmodels/","page":"Solid Models (3D Geometry)","title":"Solid Models (3D Geometry)","text":"    SolidModels.MeshingParameters","category":"page"},{"location":"solidmodels/#DeviceLayout.SolidModels.MeshingParameters","page":"Solid Models (3D Geometry)","title":"DeviceLayout.SolidModels.MeshingParameters","text":"Base.@kwdef struct MeshingParameters\n    mesh_scale::Float64 = 1.0\n    mesh_order::Int = 1\n    α_default::Float64 = 1.0\n    apply_size_to_surfaces::Bool = false\n    high_order_optimize::Int = 1\n    surface_mesh_algorithm::Int = 6\n    volume_mesh_algorithm::Int = 1\n    options::Dict{String, Float64} = Dict{String, Float64}()\nend\n\nMeshingParameters contains high level parameters to specify mesh sizing fields throughout the domain.\n\nmesh_scale applies multiplicatively to the smallest size specified by any size field function, comparing to the formula in the MeshSized style, this results in all mesh size fields being rescaled where h ← mesh_scale * h.\nmesh_order specifies the order of polynomials to use in representing the geometry, this is important if curved geometric features are present, mesh_order == 1 will represent the geometry with linear polynomials, whilst mesh_order == 2 will represent it with quadratic polynomials, and mesh_order == 3 with cubic polynomials. Increasing the value of mesh_order results in greater geometric fidelity, whilst making meshing more difficult (and prone to errors).\nα_default specifies the default value of α to use for MeshSized entities where α is set to less than 0, α_default ∈ (0, 1] is particularly used for the default grading of Path entities.\napply_size_to_surfaces=true will cause the mesh sizing field to specify the size within any sized entities, as opposed to only along the perimeter of the entity if apply_size_to_surfaces=false. Setting apply_size_to_surfaces=true will result in a larger number of elements.\nhigh_order_optimize=0 flag to pass to gmsh if optimization of a higher order mesh is to be performed. (0: none, 1: optimization, 2: elastic+optimization, 3: elastic, 4: fast curving). Refer to the gmsh documentation for more details.\nsurface_mesh_algorithm specifies the algorithm gmsh should use when performing the surface mesh generation. Refer to the gmsh documentation for more details.\nvolume_mesh_algorithm specifies the algorithm gmsh should use when performing the volume mesh generation. Refer to the gmsh documentation for more details.\noptions used to specify any additional options provided to gmsh, which will be set with gmsh.options.set_number(key, value) for each key => value pair. Refer to the gmsh documentation for a list of available options. Will override any other options as is called last.\n\n\n\n\n\n","category":"type"},{"location":"solidmodels/#Example","page":"Solid Models (3D Geometry)","title":"Example","text":"","category":"section"},{"location":"solidmodels/","page":"Solid Models (3D Geometry)","title":"Solid Models (3D Geometry)","text":"Below, we create a 3D model of a meandered CPW on a chip, restricting the model to a small volume (for example, for the purposes of simulation).","category":"page"},{"location":"solidmodels/","page":"Solid Models (3D Geometry)","title":"Solid Models (3D Geometry)","text":"using DeviceLayout\nusing FileIO\n\ncs = CoordinateSystem(\"test\", nm)\n\n# Create a CPW meander\npa = Path(-0.5mm, 0nm)\nstraight!(pa, 900μm, Paths.SimpleCPW(10μm, 6μm))\nturn!(pa, 180°, 50μm)\nstraight!(pa, 900μm)\nturn!(pa, -180°, 50μm)\nstraight!(pa, 900μm)\nturn!(pa, 180°, 50μm)\nstraight!(pa, 900μm)\nterminate!(pa)\nrender!(cs, pa, SemanticMeta(:base_negative))\n\nrender!(cs, centered(Rectangle(10mm, 10mm)), SemanticMeta(:chip_outline))\nrender!(cs, centered(Rectangle(9mm, 9mm)), SemanticMeta(:writeable_area))\nrender!(cs, centered(Rectangle(2mm, 2mm)), SemanticMeta(:simulated_area))\n\n# Define z heights and thickness (where nonzero)\nlayer_z = Dict(:chip_outline => -525μm, :simulated_area => -1mm)\nlayer_thickness = Dict(:chip_outline => 525μm, :simulated_area => 2mm)\n\n# Define postrendering operations:\n# Extrusions, geometric Boolean operations, and other transformations\npostrender_ops = vcat(\n    [   # Extrude layers with nonzero thickness\n        (string(layer) * \"_extrusion\", SolidModels.extrude_z!, (layer, thickness)) for\n        (layer, thickness) in pairs(layer_thickness)\n    ],\n    [   # sm[\"chip_sim\"] = intersect_geom!(sm, \"simulated_area_extrusion\", ...)\n        (   # Intersect chip volume with simulation volume\n            \"chip_sim\", # New physical group name\n            SolidModels.intersect_geom!, # Operation\n            # Arguments: Object, tool, object dimension, tool dimension\n            (\"simulated_area_extrusion\", \"chip_outline_extrusion\", 3, 3), # Vol ∩ Vol\n            # Keyword arguments\n            :remove_tool => true # Remove the \"chip_outline_extrusion\" group\n        ),\n        (   # Intersect writeable area with simulation volume\n            \"writeable_sim\",\n            SolidModels.intersect_geom!,\n            (\"simulated_area_extrusion\", \"writeable_area\", 3, 2), # Volume ∩ Area\n            :remove_tool => true # Remove \"writeable_area\" group\n        ),\n        (   # Create group for non-chip volumes (vacuum)\n            \"vac_sim\",\n            SolidModels.difference_geom!, # Subtract \"tool\" from \"object\"\n            (\"simulated_area_extrusion\", \"chip_sim\", 3, 3),\n            :remove_object => true # Remove \"simulated_area_extrusion\" group\n        ),\n        (   # Subtract negative from writeable area to get metal area\n            \"base_metal\",\n            SolidModels.difference_geom!,\n            (\"writeable_sim\", \"base_negative\"), # Uses default dimension 2\n            :remove_object => true # Remove \"writeable_sim\" group\n        )\n    ]\n)\n\nsm = SolidModel(\"model\"; overwrite=true)\nSolidModels.render!(\n    sm,\n    cs,\n    zmap=(m) -> get(layer_z, layer(m), 0μm),\n    postrender_ops=postrender_ops\n)\nSolidModels.gmsh.model.mesh.generate() # Generate default mesh (low quality)\nsave(\"model.msh2\", sm) # Use older MSH v2 format (Gmsh format compatible with Palace)\n# save(\"model.stp\", sm) # Use standard STEP format\nSolidModels.gmsh.finalize() # Finalize the Gmsh API when done using Gmsh","category":"page"},{"location":"schematicdriven/faq/#Troubleshooting-and-FAQ","page":"Troubleshooting/FAQ","title":"Troubleshooting & FAQ","text":"","category":"section"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"Is there a way to not render a node in the SchematicGraph?","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"Rendering with a LayoutTarget will skip all entities with the special metadata DeviceLayout.NORENDER_META = SemanticMeta(:norender), so there's a workaround: Try running map_metadata!(component(mynode), (_) -> DeviceLayout.NORENDER_META) before calling build! or render!.","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"How do I attach components like readout resonators along a route in the schematic?","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"If you have an existing node created by route!, you can attach CoordinateSystemReferences with the function attach!(r::RouteComponent, c::CoordSysRef, t::Coordinate; location::Int=0) and it works like attaching things to a Path. Right now there's no way to attach a Component to a RouteComponent so that it becomes part of the schematic. For that, use a Path with attach!(::SchematicGraph, ...).","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"How do I attach components like readout resonators along a path in the schematic?","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"I recommend creating a straight Path, then attaching your component to that. For example:","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"pa = Path(\n    Point(0μm, 0μm),\n    α0=0°,\n    metadata=SemanticMeta(:metal_negative),\n    name=uniquename(\"coupseg\")\n)\nstraight!(pa, 250μm, cpw_style)\n\ncoupling_seg_node = add_node!(g, pa)\nrres_node = add_node!(g, readout_resonator)\nattach!.(\n    g,\n    segnode,\n    rres_node => :readout_line,\n    pathlength(SchematicDrivenLayout.component(segnode).path) / 2,\n    i=1,\n    location=1\n)\n# ... then fuse/route these to other nodes as usual","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"What's with all the semicolons?","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"Semicolons are used in Julia in a few places related to key-value pairs:","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"In function definitions, separating positional arguments from keyword arguments.\nIf there are no positional arguments, it's still necessary to start with a semicolon: function f(; a=1, b=2)...\nIn function calls, separating positional arguments from keyword arguments.\nThis is optional, but may be used for clarity, especially when splatting keyword arguments when there are no positional arguments\nTo construct literal NamedTuples: (; a=1, b=2).\nThe semicolon is optional, but if there is only one key/value pair, either a leading semicolon (; a=1) or trailing comma (a=1,) must be used to distinguish it from the expression a=1 wrapped in parentheses. (The leading semicolon is preferred for a couple reasons. A single-element Tuple also uses a trailing comma; also, it's easy to accidentally remove the required trailing comma when removing all but one elements from the expression.)\nAn empty NamedTuple can also be constructed with (;).\nYou can also construct NamedTuples programmatically by splatting an iterator yielding key-value pairs after the semicolon: (; a=1, my_namedtuple..., b=2).\nOn the left-hand side of an assignment, to unpack/\"destructure\" a NamedTuple or struct (starting in Julia 1.7).\n(; a, b) = x is equivalent to the assignments a = x.a and b = x.b\nFor completeness, there are a couple unrelated uses of semicolons:\nTo separate statements without a line break, as in a = x.a; b = x.b\nTo separate array literals for vertical concatenation, as in A_2x3 = [1 2 3; 4 5 6]\nN semicolons concatenate along the Nth dimension, as in A_3x2 = [1:3 ;; 4:6]","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"In SchematicDrivenLayout specifically, we often work with the parameters of a Component as a NamedTuple.","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"How do I add a schematic node so that it's at a fixed position on the chip?","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"One way to do that is to make a top-level parent component with a hook at the position you want. For example, you can use the built-in SchematicDrivenLayout.Spacer component:","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"g = SchematicGraph(\"fixed_demo\")\nspacernode = add_node!(g, Spacer(p1=Point(6mm, 1mm)))\nfuse!(g, spacernode => :p1_north, mycomp => :myhook)","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"Any \"root\" node (one that's not attached to any previously added node by any chain of connections; this always includes the first node added to a graph) will have its origin at the global origin.","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"How do I attach one component to another if there's no hook where I need it?","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"If you need some offset relative to existing hooks, you can use the Spacer (see above) with a p0 compass hook fused to one component and a p1 compass hook fused to the other.","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"For truly ad-hoc positioning, you can use fuse! with an actual Hook object rather than a Symbol identifying the Hook for one or both components. For example, this might be appropriate for labeling and annotation:","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"fuse!(\n    g,\n    mynode => PointHook(0.5mm, 0.5mm, 90°),\n    ArrowAnnotation(text=\"(0.5mm, 0.5mm) in mynode's coordinate system\") => :tip\n)","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"However, if you find yourself needing a consistent hook that doesn't already exist for MyComponent, then it's generally better to update the component definition so that the hook is available by name through hooks(::MyComponent).","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"How do I make sure there aren't any bridges along feedline segments with coupled devices?","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"You can define a short, straight Path and couple each device to one of those, then route the feedline between the endpoints of coupling segments.","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"I edited a component's _geometry! method but I'm still getting the old geometry. Can I get the new geometry without restarting Julia?","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"First, make sure the new code is being loaded. You can use Revise to automatically use updated code within any package you load with import or using as well as any scripts loaded with includet.","category":"page"},{"location":"schematicdriven/faq/","page":"Troubleshooting/FAQ","title":"Troubleshooting/FAQ","text":"Most component types, including those defined using @compdef, contain a _geometry field that allows them to store their geometry so that it is only generated once. It is not marked as dirty or automatically regenerated when geometry methods change. Currently, to regenerate the geometry, you have to instantiate a new component.","category":"page"},{"location":"#DeviceLayout.jl","page":"Home","title":"DeviceLayout.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DeviceLayout.jl is a Julia package for computer-aided design (CAD) of quantum integrated circuits developed at the AWS Center for Quantum Computing. The package supports the generation of 2D layouts and 3D models of complex devices using a low-level geometry interface together with a high-level schematic-driven workflow.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia can be downloaded here. We support Julia v1.9 or later.","category":"page"},{"location":"","page":"Home","title":"Home","text":"From Julia, install DeviceLayout.jl using the built-in package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.activate(\".\") # Activates an environment in the current directory\nPkg.add(\"DeviceLayout\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"We recommend using an environment for each project rather than installing packages in the default environment.","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let's mock up a transmission line with two launchers and some bridges across the transmission line. We begin by making a cell with a rectangle in it:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DeviceLayout, DeviceLayout.PreferredUnits, FileIO\n\ncr = Cell(\"rect\", nm)\nr = centered(Rectangle(20μm, 40μm))\nrender!(cr, r, GDSMeta(1, 0))\nsave(\"units_rectonly.svg\", cr; layercolors=Dict(0 => (0, 0, 0, 1), 1 => (1, 0, 0, 1)));\nnothing; # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"units_rectonly.svg\" style=\"width:1in;\"/>","category":"page"},{"location":"","page":"Home","title":"Home","text":"A rectangle made with a width and height parameter will default to having its lower-left corner at the origin. centered will return a rectangle that is centered about the origin instead.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The rectangle is then rendered into the cell. GDSMeta(1) indicates the target GDSII layer. You can also specify the GDSII datatype as a second argument, e.g. GDSMeta(1,0).","category":"page"},{"location":"","page":"Home","title":"Home","text":"In another cell, we make the transmission line with some launchers on both ends:","category":"page"},{"location":"","page":"Home","title":"Home","text":"p = Path(μm)\nsty = launch!(p)\nstraight!(p, 500μm, sty)\nturn!(p, π / 2, 150μm)\nstraight!(p, 500μm)\nlaunch!(p)\ncp = Cell(\"pathonly\", nm)\nrender!(cp, p, GDSMeta(0))\nsave(\"units_pathonly.svg\", cp; layercolors=Dict(0 => (0, 0, 0, 1), 1 => (1, 0, 0, 1)));\nnothing; # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"units_pathonly.svg\" style=\"width: 3in;\"/>","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, let's put bridges across the feedline:","category":"page"},{"location":"","page":"Home","title":"Home","text":"turnidx = Int((length(p) + 1) / 2) - 1 # the first straight segment of the path\nsimplify!(p, turnidx .+ (0:2))\nattach!(\n    p,\n    CellReference(cr, Point(0.0μm, 0.0μm)),\n    (40μm):(40μm):((pathlength(p[turnidx])) - 40μm),\n    i=turnidx\n)\nc = Cell(\"decoratedpath\", nm)\nrender!(c, p, GDSMeta(0))\nsave(\"units.svg\", flatten(c); layercolors=Dict(0 => (0, 0, 0, 1), 1 => (1, 0, 0, 1)));\nnothing; # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"units.svg\" style=\"width: 3in;\"/>","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can save a Cell to a GDS file for lithography or an SVG for vector graphics by using save with an appropriate extension:","category":"page"},{"location":"","page":"Home","title":"Home","text":"save(\"/path/to/myoutput.gds\", c)\nsave(\"/path/to/myoutput.svg\", c)","category":"page"},{"location":"","page":"Home","title":"Home","text":"SVG support is experimental, but it is used in generating the graphics you see in this documentation. If you use the Julia REPL (read-eval-print loop) provided by the extension Julia for Visual Studio Code, rendered cells are previewed in a separate tab. If you use Jupyter/IJulia, rendered cells are automatically returned as a result.","category":"page"},{"location":"#Performance-and-workflow-tips","page":"Home","title":"Performance and workflow tips","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"KLayout is a free (GPL v2+) GDS viewer/editor. It watches its open files for changes, making it easy to use as a fast previewer alongside DeviceLayout.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The recommended IDE for Julia is Visual Studio Code with the Julia for Visual Studio Code extension.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since Julia has a just-in-time compiler, the first time code is executed may take much longer than any other times. This means that a lot of time will be wasted repeating compilations if you run DeviceLayout.jl in a script like you would in other languages. For readability, it is best to split up your CAD code into functions that have clearly named inputs and perform a well-defined task.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is also best to avoid writing statements in global scope. In other words, put most of your code in a function. Your CAD script should ideally look like the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DeviceLayout, DeviceLayout.PreferredUnits, FileIO\n\nfunction subroutine1()\n    # render some thing\nend\n\nfunction subroutine2()\n    # render some other thing\nend\n\nfunction main()\n    # my cad code goes here: do all of the things\n    subroutine1()\n    subroutine2()\n    return save(\"/path/to/out.gds\", ...)\nend\n\nmain() # execute main() at end of script.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In a typical workflow, you'll have a text editor open alongside a Julia REPL. You'll save the above code in a file (e.g., mycad.jl) and then run include(\"mycad.jl\") from the Julia REPL to generate your pattern. You'll iteratively revise mycad.jl and save your changes. Subsequent runs should be several times faster than the first, if you include the file again from the same Julia session.","category":"page"},{"location":"schematicdriven/hooks/#Hooks","page":"Hooks","title":"Hooks","text":"","category":"section"},{"location":"schematicdriven/hooks/","page":"Hooks","title":"Hooks","text":"SchematicDrivenLayout.Hook\nSchematicDrivenLayout.PointHook\nSchematicDrivenLayout.HandedPointHook\nSchematicDrivenLayout.p0_hook\nSchematicDrivenLayout.p1_hook\nSchematicDrivenLayout.in_direction\nSchematicDrivenLayout.out_direction\nSchematicDrivenLayout.path_in\nSchematicDrivenLayout.path_out\nSchematicDrivenLayout.transformation(::DeviceLayout.PointHook, ::DeviceLayout.PointHook)\nSchematicDrivenLayout.compass","category":"page"},{"location":"schematicdriven/hooks/#DeviceLayout.Hook","page":"Hooks","title":"DeviceLayout.Hook","text":"abstract type Hook{T} <: AbstractGeometry{T}\n\nContains information describing how one component can attach to others.\n\n\n\n\n\n","category":"type"},{"location":"schematicdriven/hooks/#DeviceLayout.PointHook","page":"Hooks","title":"DeviceLayout.PointHook","text":"PointHook(p::Point, in_direction)\nPointHook(x, y, in_direction)\n\nHook defined by a point and a direction (an angle CCW from the positive x axis).\n\nAttaching two PointHooks will match the points, oriented so the angles are opposite. By convention, hooks point inward.\n\n\n\n\n\n","category":"type"},{"location":"schematicdriven/hooks/#DeviceLayout.HandedPointHook","page":"Hooks","title":"DeviceLayout.HandedPointHook","text":"HandedPointHook{T} <: Hook{T}\n    h::PointHook{T}\n    right_handed::Bool\n\nA PointHook augmented with handedness.\n\nIn addition to translation and rotation, which are used to fuse one PointHook to another, a HandedPointHook being fused to another HandedPointHook will apply a reflection if necessary to match its handedness.\n\n\n\n\n\n","category":"type"},{"location":"schematicdriven/hooks/#DeviceLayout.Paths.p0_hook","page":"Hooks","title":"DeviceLayout.Paths.p0_hook","text":"p0_hook(pa::Path) = PointHook(p0(pa), α0(pa))\n\nA PointHook looking into the start of path pa.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/hooks/#DeviceLayout.Paths.p1_hook","page":"Hooks","title":"DeviceLayout.Paths.p1_hook","text":"p1_hook(pa::Path) = PointHook(p1(pa), α1(pa) + π)\n\nA PointHook looking into the end of path pa.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/hooks/#DeviceLayout.in_direction","page":"Hooks","title":"DeviceLayout.in_direction","text":"in_direction(h::Hook)\n\nThe inward-pointing direction stored by the PointHook (angle CCW from the positive x axis)\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/hooks/#DeviceLayout.out_direction","page":"Hooks","title":"DeviceLayout.out_direction","text":"out_direction(h::PointHook)\n\nThe outward-pointing angle opposite to the direction stored by the PointHook\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/hooks/#DeviceLayout.Paths.path_in","page":"Hooks","title":"DeviceLayout.Paths.path_in","text":"path_in(h::PointHook)\n\nA Path starting at h, pointing along its inward direction.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/hooks/#DeviceLayout.Paths.path_out","page":"Hooks","title":"DeviceLayout.Paths.path_out","text":"path_out(h::PointHook)\n\nA Path starting at h, pointing along its outward direction.\n\n\n\n\n\n","category":"function"},{"location":"schematicdriven/hooks/#DeviceLayout.transformation-Tuple{PointHook, PointHook}","page":"Hooks","title":"DeviceLayout.transformation","text":"transformation(h1::Hook, h2::Hook)\n\nReturn a CoordinateTransformation to align h2 to h1.\n\nGiven hooks h1, h2 relative to  CoordinateSystems h1cs, h2cs respectively, if you reference h2cs inside h1cs with push!(h1cs.refs, sref(h2cs, origin, rot=rotation, xrefl=xrefl)), then relative to h1cs, h2 will lie on top of h1 with its in_direction pointing opposite to that of h1 (and matching handedness, if applicable).\n\n\n\n\n\n","category":"method"},{"location":"schematicdriven/hooks/#DeviceLayout.compass","page":"Hooks","title":"DeviceLayout.compass","text":"compass(;p0=Point(0μm, 0μm))\n\nAn 8-point compass of PointHooks at p0.\n\nThe NamedTuple (:east = PointHook(p0, 0°), :northeast = PointHook(p0, 45°), ... for all cardinal and primary intercardinal directions (every 45°). (The in_direction of each hook points in its compass direction.)\n\n\n\n\n\n","category":"function"}]
}
