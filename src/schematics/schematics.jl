import Graphs
import Graphs: edges, neighbors, src, dst, vertices
import MetaGraphs
import MetaGraphs:
    AbstractMetaGraph,
    MetaGraph,
    get_prop,
    has_prop,
    props,
    set_prop!,
    add_vertex!,
    add_edge!,
    rem_vertex!,
    set_prop!

# If an edge has the property :plan_skips_edge => true, skip it in the plan! function
PLAN_SKIPS_EDGE = :plan_skips_edge

"""
    mutable struct ComponentNode
        id::String
        component::AbstractComponent
    end

Represents an instance of a component in the context of a schematic graph.
"""
mutable struct ComponentNode
    id::String
    component::AbstractComponent
end
component(c::ComponentNode) = c.component
component(c::AbstractComponent) = c

function Base.getproperty(n::ComponentNode, s::Symbol)
    if s in (:id, :component)
        return getfield(n, s)
    else
        return getproperty(getfield(n, :component), s)
    end
end

Base.getindex(n::ComponentNode, idx) = component(n)[idx]

"""
    SchematicGraph <: AbstractMetaGraph{Int}

Graph describing the components and connectivity of a device schematic.
"""
struct SchematicGraph <: AbstractMetaGraph{Int}
    name::String
    graph::MetaGraph{Int}
    namecounter::Dict{String, Int}
    node_dict::Dict{Symbol, ComponentNode}
    nodes::Vector{ComponentNode}
end
SchematicGraph(name::String) = SchematicGraph(
    name,
    MetaGraph(),
    Dict{String, Int}(),
    Dict{Symbol, ComponentNode}(),
    ComponentNode[]
)

function Base.getproperty(g::SchematicGraph, s::Symbol)
    if s in (:name, :graph, :namecounter, :node_dict, :nodes)
        return getfield(g, s)
    elseif s in keys(getfield(g, :node_dict))
        return getfield(g, :node_dict)[s]
    else
        return getfield(g.graph, s)
    end
end

MetaGraphs.is_directed(g::SchematicGraph) = false
MetaGraphs.weighttype(g::SchematicGraph) = MetaGraphs.weighttype(g.graph)

nodes(g::SchematicGraph) = g.nodes
components(g::SchematicGraph) = component.(nodes(g))
name(g::SchematicGraph) = g.name

"""
    indexof(n::ComponentNode, g::SchematicGraph)

Finds the index of the node `n` in `g`.
"""
indexof(n::ComponentNode, g::SchematicGraph) = findfirst((x) -> x == n, nodes(g))

Graphs.neighbors(g::SchematicGraph, n::ComponentNode) = neighbors(g, indexof(n, g))

MetaGraphs.has_prop(g::SchematicGraph, n::ComponentNode, prop::Symbol) =
    has_prop(g.graph, indexof(n, g), prop)
MetaGraphs.get_prop(g::SchematicGraph, n::ComponentNode, prop::Symbol) =
    get_prop(g.graph, indexof(n, g), prop)
MetaGraphs.set_prop!(g::SchematicGraph, n::ComponentNode, prop::Symbol, val) =
    MetaGraphs.set_prop!(g.graph, indexof(n, g), prop, val)

MetaGraphs.has_prop(g::SchematicGraph, n1::ComponentNode, n2::ComponentNode, prop::Symbol) =
    has_prop(g.graph, indexof(n1, g), indexof(n2, g), prop)

MetaGraphs.get_prop(g::SchematicGraph, n1::ComponentNode, n2::ComponentNode, prop::Symbol) =
    get_prop(g.graph, indexof(n1, g), indexof(n2, g), prop)
MetaGraphs.get_prop(
    g::SchematicGraph,
    n1::ComponentNode,
    n2::ComponentNode,
    n::ComponentNode
) = get_prop(g.graph, indexof(n1, g), indexof(n2, g), :nodehooks)[n]
MetaGraphs.get_prop(
    g::SchematicGraph,
    e::Graphs.SimpleGraphs.SimpleEdge{Int64},
    node::ComponentNode
) = get_prop(g.graph, e, :nodehooks)[node]
MetaGraphs.get_prop(g::SchematicGraph, e::Graphs.SimpleGraphs.SimpleEdge{Int64}, n::Int) =
    get_prop(g.graph, e, :nodehooks)[nodes(g)[n]]

Base.getindex(g::SchematicGraph, idx::Int) = nodes(g)[idx]
Base.getindex(g::SchematicGraph, I) = [g[idx] for idx in I]
# Define to remove ambiguity with the above
Base.getindex(g::SchematicGraph, prop::Symbol) = g.graph[prop] # MetaGraphs indexing prop
function Base.getindex(g::SchematicGraph, I::NTuple{N, Int}) where {N}
    gi = g
    for i in I[1:(N - 1)]
        gi = graph(component(gi[i]))
    end
    return gi[I[N]]
end
Base.broadcastable(g::SchematicGraph) = Ref(g)

function additional_hooks(g::SchematicGraph, node::ComponentNode)
    if has_prop(g, node, :additional_hooks)
        return get_prop(g, node, :additional_hooks)
    else
        return Dict{Symbol, Hook}()
    end
end

"""
    add_node!(g::SchematicGraph, comp::AbstractComponent; base_id=name(comp), kwargs...)

Create and return a new node for `comp`.

The `base_id` will be used as the node's `id` if it is not already in use by the `Schematic`.
If it is, then a uniquename will be generated by appending `_n`, where `n` is the number of
occurrences of `base_id` so far (including this one).

Additional keyword arguments will become vertex properties.
"""
function add_node!(
    g::SchematicGraph,
    comp::AbstractComponent;
    base_id=name(comp),
    kwargs...
)
    props = Dict{Symbol, Any}(kwargs...)
    id = uniquename(base_id, '_', counter=g.namecounter)
    node = ComponentNode(id, comp)
    g.node_dict[Symbol(id)] = node
    push!(g.nodes, node)
    add_vertex!(g, props)
    return node
end
add_node!(g::SchematicGraph, n::ComponentNode; base_id=n.id, kwargs...) =
    add_node!(g, component(n); base_id=base_id, kwargs...)

function rem_node!(g::SchematicGraph, n::ComponentNode)
    idx = indexof(n, g)
    rem_vertex!(g.graph, idx)
    delete!(g.node_dict, n.id)
    # Tricky indexing external data structure with vertices
    g.nodes[idx] = last(g.nodes) # Internally rem_vertex swaps with last vertex and pops
    pop!(g.nodes)
    return n
end

"""
    fuse!(g::SchematicGraph,
        nodehook1::Pair{Int, Symbol},
        nodehook2::Pair{Int, Symbol}; kwargs...)
    fuse!(g::SchematicGraph,
        nodehook1::Pair{ComponentNode, <:Union{Symbol, Hook}},
        nodehook2::Pair{<:Union{ComponentNode, AbstractComponent}, <:Union{Symbol, Hook}}; kwargs...)

Usage:

  - `fuse!(g, node1=>:hook1, node2=>:hook2)`
  - `fuse!(g, idx1=>:hook1, idx2=>:hook2)`
  - `fuse!(g, node1=>:hook1, comp2=>:hook2)`
  - `fuse!(g, node1=>:hook1, comp2=>:hook2; PLAN_SKIPS_EDGE=>true)`

Add an edge `(node1, node2)` connecting their hooks `(:hook1, :hook2)` to `g`.

Returns the second `ComponentNode`.

If `fuse!` is passed a bare component `comp2`, it makes a new node, even if that component
is referenced in another node.

If no hook or only one hook is specified, `fuse!` will try to
determine the correct hook using `matching_hooks` or `matching_hook`.

You can make an attachment anywhere, not just to an existing named hook, by providing a
`Hook` object with the desired point and orientation rather than a `Symbol` (example:
`fuse!(g, node1=>PointHook(1mm, 1mm, 90°), comp2=>:hook2)`). This option is provided for convenience in
situations that call for ad-hoc or case-by-case relative positioning; one example use case
might be placing labels near components. On the other hand, if you find yourself
needing a consistent hook that doesn't already exist for `MyComponent`, then it's generally
better to update the component definition so that the hook is available through
`hooks(::MyComponent)`. Alternatively, if you want to use an existing hook with an
additional offset, consider using the [`Spacer`](@ref) component.

Cycles:
Sometimes we need to avoid adding edges in the graph to avoid cycles that'd force the
`plan` function to throw an error. Solution: Pass a keyword argument `plan_skips_edge=true`.
This allows us to encode all the edges in the graph, while informing the `plan` function
that the edge should be skipped for rendering purposes.
"""
function fuse!(
    g::SchematicGraph,
    nodehook1::Pair{Int, Symbol},
    nodehook2::Pair{Int, Symbol};
    kwargs...
)
    idx1, hook1 = nodehook1
    idx2, hook2 = nodehook2
    props = Dict{Symbol, Any}(
        :nodehooks => Dict{ComponentNode, Symbol}(g[idx1] => hook1, g[idx2] => hook2),
        kwargs...
    )
    add_edge!(g.graph, idx1, idx2, props)
    return nodes(g)[idx2]
end

function fuse!(
    g::SchematicGraph,
    nodehook1::Pair{ComponentNode, Symbol},
    nodehook2::Pair{ComponentNode, Symbol};
    kwargs...
)
    fuse!(
        g,
        indexof(nodehook1.first, g) => nodehook1.second,
        indexof(nodehook2.first, g) => nodehook2.second;
        kwargs...
    )
    return nodehook2.first
end

function fuse!(
    g::SchematicGraph,
    nodehook1::Pair{ComponentNode, <:Union{Symbol, Hook}},
    comphook2::Pair{<:AbstractComponent, <:Union{Symbol, Hook}};
    nodeprops=Dict{Symbol, Any}(),
    kwargs...
)
    node2 = add_node!(g, comphook2.first; pairs(nodeprops)...)

    fuse!(g, nodehook1.first => nodehook1.second, node2 => comphook2.second; kwargs...)
    return node2
end

### Additional hooks
function fuse!(
    g::SchematicGraph,
    nodehook1::Pair{<:ComponentNode, <:Hook},
    nodehook2::Pair{<:ComponentNode, Symbol};
    kwargs...
)
    node1 = first(nodehook1)
    hook1 = last(nodehook1)
    h1sym = Symbol(uniquename("attach_" * first(nodehook2).id, counter=g.namecounter))

    add_hooks = additional_hooks(g, node1)
    isempty(add_hooks) &&
        set_prop!(g.graph, indexof(node1, g), :additional_hooks, add_hooks)
    add_hooks[h1sym] = hook1

    return fuse!(g, node1 => h1sym, nodehook2; kwargs...)
end

function fuse!(
    g::SchematicGraph,
    nodehook1::Pair{<:ComponentNode, <:Union{Symbol, Hook}},
    nodehook2::Pair{<:ComponentNode, <:Hook};
    kwargs...
)
    node2 = first(nodehook2)
    hook2 = last(nodehook2)
    h2sym = Symbol(uniquename("attach_" * first(nodehook1).id, counter=g.namecounter))

    add_hooks = additional_hooks(g, node2)
    isempty(add_hooks) &&
        set_prop!(g.graph, indexof(node2, g), :additional_hooks, add_hooks)
    add_hooks[h2sym] = hook2

    return fuse!(g, nodehook1, node2 => h2sym; kwargs...)
end

### Matching hooks
function fuse!(
    g::SchematicGraph,
    nodehook1::Pair{ComponentNode, Symbol},
    node2::Union{AbstractComponent, ComponentNode},
    kwargs...
)
    h2 = matching_hook(component(nodehook1.first), nodehook1.second, component(node2))
    return fuse!(g, nodehook1, node2 => h2, kwargs...)
end

function fuse!(
    g::SchematicGraph,
    node1::ComponentNode,
    nodehook2::Pair{<:Union{AbstractComponent, ComponentNode}, Symbol},
    kwargs...
)
    h1 = matching_hook(component(nodehook2.first), nodehook2.second, component(node1))
    return fuse!(g, node1 => h1, nodehook2, kwargs...)
end

function fuse!(
    g::SchematicGraph,
    node1::ComponentNode,
    node2::Union{ComponentNode, AbstractComponent},
    kwargs...
)
    h1, h2 = matching_hooks(component(node1), component(node2))
    return fuse!(g, node1 => h1, node2 => h2, kwargs...)
end

"""
    add_graph!(g0::SchematicGraph, g1::SchematicGraph; id_prefix=name(g1))

Add the graph `g1` to `g0`, creating new nodes by prefixing IDs with `id_prefix`.

Does not preserve edge properties.
"""
function add_graph!(
    g0::SchematicGraph,
    g1::SchematicGraph;
    id_prefix=name(g1) * ".",
    kwargs...
)
    num_nodes = length(nodes(g0))
    ns = nodes(g1)
    for (idx, n) in enumerate(ns)
        nodeprops = props(g1, idx)
        add_node!(g0, n; base_id=id_prefix * n.id, nodeprops...)
    end
    for n in ns
        n_idx = indexof(n, g1)
        nbrs = g1[neighbors(g1, n)]
        for n1 in nbrs
            n1_idx = indexof(n1, g1)
            h = get_prop(g1, n, n1, n)
            h1 = get_prop(g1, n, n1, n1)
            fuse!(g0, (n_idx + num_nodes) => h, (n1_idx + num_nodes) => h1; kwargs...)
        end
    end
end

"""
    matching_hook(c1::S, h1::Symbol, c2::T) where {S <: AbstractComponent, T <: AbstractComponent}

Return the hook on `c2` that goes with `h1` on `c1` (as a `Symbol`).
"""
matching_hook(
    c1::S,
    h1::Symbol,
    c2::T
) where {S <: AbstractComponent, T <: AbstractComponent} =
    error("No matching hook on $c2 found for $c1=>$h1")

"""
    matching_hooks(c1::S, c2::T) where {S <: AbstractComponent, T <: AbstractComponent}

Return the hooks on `c1` and `c2` that should be fused together (as a `Tuple{Symbol,Symbol}`).
"""
matching_hooks(c1::S, c2::T) where {S <: AbstractComponent, T <: AbstractComponent} =
    error("No matching hook on $c2 found for $c1")

"""
    attach!(g::SchematicGraph,
        pathnode::S,
        nodehook2::Pair{T, Symbol},
        position;
        i=lastindex(component(pathnode)),
        location=0) where {S <: ComponentNode, T <: ComponentNode}
    Usage: attach!(g, pathnode, node2=>:hook2, position; i=segment_idx, location=0)

Adds an edge to `g` between `pathnode` and `node2`, attaching `:hook2` to a specified point along `pathnode`.

A new `HandedPointHook` is generated a distance `position` along the segment specified by `i`.
If `location` is +1 or -1, the generated hook is offset to the right or left of the segment by
the extent defined by the path's style, with the hook's inward direction pointing back to the segment.
"""
function DeviceLayout.attach!(
    g::SchematicGraph,
    pathnode::S,
    nodehook2::Pair{T, Symbol},
    position::Coordinate;
    i=lastindex(component(pathnode)),
    location=0
) where {S <: ComponentNode, T <: ComponentNode}
    pathcomp = component(pathnode)

    segment = pathcomp[i].seg
    dir = direction(segment, position)
    p_hook = segment(position)
    if location != 0
        (location < -1 || location > 1) && error("Attachment location must be -1, 0, or 1.")

        offset = Paths.extent(pathcomp[i].sty, position)
        off_x = offset * cos(dir - location * π / 2)
        off_y = offset * sin(dir - location * π / 2)
        p_hook += Point(off_x, off_y)

        dir = dir + location * π / 2 # points back to path
    end

    newhook = HandedPointHook(p_hook, dir)
    return fuse!(g, pathnode => newhook, nodehook2)
end

function DeviceLayout.attach!(
    g::SchematicGraph,
    pathnode::S,
    comphook2::Pair{T, Symbol},
    position::Coordinate;
    i=lastindex(component(pathnode)),
    location=0
) where {S <: ComponentNode, T <: AbstractComponent}
    n = add_node!(g, first(comphook2))
    return attach!(g, pathnode, n => last(comphook2), position; i=i, location=location)
end

function _format_log(io::IOContext, args::NamedTuple)
    kwargs = (; args.kwargs...)
    stage = kwargs.stage
    println(io, stage, " | ", "[", args.level, "] ", args.message)
    if haskey(kwargs, :exception)
        if kwargs.exception isa Tuple
            # should have been logged in try/catch with exception=(ex, catch_backtrace())
            ex, bt = kwargs.exception
            error_msg = sprint(showerror, ex)
            st = sprint((io, v) -> show(io, "text/plain", v), stacktrace(bt))
            println(io, error_msg, "\n", st)
        else
            error_msg = sprint(showerror, kwargs.exception)
            println(io, error_msg)
        end
    end
end

"""
    mutable struct SchematicLogger <: AbstractLogger
    SchematicLogger(name; path="build", level=Logging.Info)

Used within a `Schematic` for logging messages generated throughout the workflow.

Creates a `TeeLogger` that sends all messages both to the `current_logger()` and to a log
file at `joinpath(path, name * ".log")`. Only messages with log level of at least `level`
will be written to the log file. If `isnothing(path)`, then no log file will be written.

Keeps track of the maximum level of messages logged during each "stage" of the schematic
workflow (usually `:plan`, `:build`, and `:render` or `:render_solidmodel`).
"""
mutable struct SchematicLogger <: AbstractLogger
    max_level_logged::Dict{Symbol, LogLevel}
    stage::Symbol
    logname::String
    logger::TeeLogger
end

function SchematicLogger(name; path="build", level=Logging.Info)
    logname, logger = if isnothing(path)
        "output", Base.NullLogger()
    else
        mkpath(path)
        filename = joinpath(path, name * ".log")
        filename, MinLevelLogger(FormatLogger(_format_log, filename), level)
    end
    return SchematicLogger(
        Dict{Symbol, LogLevel}(),
        :plan,
        logname,
        TeeLogger(current_logger(), logger)
    )
end

Base.copy(x::SchematicLogger) = SchematicLogger(
    copy(x.max_level_logged),
    x.stage,
    x.logname,
    TeeLogger(x.logger.loggers...)
)
# Needed for an edge case where a `current_logger` was not copyable
function Base.deepcopy_internal(x::SchematicLogger, stackdict::IdDict)
    haskey(stackdict, x) && return stackdict[x]
    y = copy(x)
    stackdict[x] = y
    return y
end

# Overrides required for custom logger
# Update max level and add stage to kwargs
function Logging.handle_message(
    logger::SchematicLogger,
    level,
    message,
    _module,
    group,
    id,
    file,
    line;
    kwargs...
)
    logger.max_level_logged[logger.stage] =
        max(level, get(logger.max_level_logged, logger.stage, Logging.Debug))
    return handle_message(
        logger.logger,
        level,
        message,
        _module,
        group,
        id,
        file,
        line;
        stage=logger.stage,
        kwargs...
    )
end
# Otherwise just pass to internal TeeLogger
Logging.shouldlog(logger::SchematicLogger, level, _module, group, id) =
    shouldlog(logger.logger, level, _module, group, id)
Logging.min_enabled_level(logger::SchematicLogger) = min_enabled_level(logger.logger)

"""
    struct Schematic{S} <: AbstractCoordinateSystem{S}

Spatial representation of a layout in terms of `AbstractComponent`s rather than polygons.

Can be constructed from a `SchematicGraph` `g` using `plan(g)`.
"""
struct Schematic{S} <: AbstractCoordinateSystem{S}
    name::String
    graph::SchematicGraph
    coordinate_system::CoordinateSystem{S}
    ref_dict::Dict{ComponentNode, StructureReference}
    index_dict::Dict{Symbol, Vector{ComponentNode}}
    checked::Ref{Bool}
    logger::SchematicLogger

    Schematic{S}(g::SchematicGraph; log_dir="build", log_level=Logging.Info) where {S} =
        new{S}(
            g.name,
            g,
            CoordinateSystem{S}(g.name),
            Dict{ComponentNode, StructureReference}(),
            Dict{Symbol, Vector{ComponentNode}}(),
            Ref(false),
            SchematicLogger(g.name, path=log_dir, level=log_level)
        )
end
Base.broadcastable(x::Schematic) = Ref(x)
DeviceLayout.elements(s::Schematic) = elements(s.coordinate_system)
DeviceLayout.refs(s::Schematic) = refs(s.coordinate_system)
DeviceLayout.element_metadata(s::Schematic) = element_metadata(s.coordinate_system)
DeviceLayout.bounds(s::Schematic) = bounds(s.coordinate_system)
DeviceLayout.place!(s::Schematic, args...) = place!(s.coordinate_system, args...)

function Base.getproperty(sch::Schematic, s::Symbol)
    if s in (:name, :graph, :coordinate_system, :ref_dict, :index_dict, :checked, :logger)
        return getfield(sch, s)
    elseif s in keys(getfield(sch, :graph).node_dict)
        return getfield(sch, :ref_dict)[getfield(sch, :graph).node_dict[s]]
    else
        return getproperty(getfield(sch, :coordinate_system), s)
    end
end

Base.getindex(sch::Schematic, node::ComponentNode) = sch.ref_dict[node]

function max_level_logged(sch::Schematic, stage)
    return get(sch.logger.max_level_logged, stage, Logging.Debug)
end

function close_logfile(sch::Schematic)
    tee = sch.logger.logger
    l = tee.loggers[2]
    return !(l isa Base.NullLogger) && close(l.logger.stream) # MinLevelLogger->FormatLogger
end

function reopen_logfile(sch::Schematic, stage)
    sch.logger.stage = stage
    tee = sch.logger.logger
    l = tee.loggers[2]
    if !(l isa Base.NullLogger) # MinLevelLogger->FormatLogger
        sch.logger.logger = TeeLogger(
            tee.loggers[1],
            MinLevelLogger(
                FormatLogger(_format_log, sch.logger.logname, append=true),
                l.min_level
            )
        )
    end
end

"""
    transformation(sch::Schematic, node::ComponentNode)

Given a Schematic `sch` containing [`ComponentNode`](@ref)
`node` in its `SchematicGraph`, this function returns a
`CoordinateTransformations.Transformation` object that lets you translate from the
coordinate system of the node to the global coordinate system of `sch`.

Effectively a wrapper around `DeviceLayout.transformation(::CoordinateSystem, ::CoordSysRef)`.
"""
function transformation(sch::Schematic, node::ComponentNode)
    if haskey(sch.ref_dict, node)
        # We could do `transformation(sch.coordinate_system, sch.ref_dict[node])`
        # But that would search for references inside component geometries
        # Which can be quite expensive
        # Instead we'll work upwards from node and only check its neighbors
        return _transformation(sch, node)
    else
        idx = find_nodes(x -> x === node, sch.graph)
        return transformation(sch, only(idx))
    end
end

function _transformation(sch::Schematic, n0::ComponentNode)
    a = transformation(sch.ref_dict[n0])
    current_node = n0
    current_ref = sch.ref_dict[n0]
    toplevel = false
    while !toplevel
        found_parent = false
        # Check neighbors to find parent, then compose its transformation
        for node_idx in neighbors(sch.graph, current_node)
            node = sch.graph[node_idx]
            if !haskey(sch.ref_dict, node)
                continue # hasn't been placed so can't be parent
            end
            # Is this `n0`'s parent?
            if current_ref in refs(structure(sch.ref_dict[node]))
                a = transformation(sch.ref_dict[node]) ∘ a
                current_node = node
                current_ref = sch.ref_dict[node]
                found_parent = true
                break # Restart with parent as current node
            end
        end
        toplevel = !found_parent
    end

    return a
end

function transformation(
    c::Schematic,
    d::ComponentNode,
    e::ComponentNode,
    f::ComponentNode...
)
    t = transformation(c, d) ∘ transformation(component(d), e)
    if length(f) == 0
        return t
    elseif length(f) == 1
        return t ∘ transformation(component(e), f[1])
    else
        t = t ∘ transformation(component(e), f[1])
        for i = 1:(length(f) - 1)
            t = t ∘ transformation(component(f[i]), f[i + 1])
        end
        return t
    end
end

function transformation(c::Schematic, index::Int, indices::Int...)
    nodes = getpath(c.graph, index, indices...)
    return transformation(c, nodes...)
end

function transformation(c::Schematic, index::NTuple{N, Int}) where {N}
    return transformation(c, index...)
end

function getpath(g::SchematicGraph, index::Int, indices::Int...)
    nodes = Vector{ComponentNode}(undef, 1 + length(indices))
    gi = g
    nodes[1] = gi[index]
    for (i, idx) in pairs(indices)
        gi = graph(component(nodes[i]))
        nodes[i + 1] = gi[idx]
    end
    return nodes
end

"""
    hooks(sch::Schematic, node::ComponentNode)

The hooks belonging to the component in `node` in the global coordinate system of `sch`.
"""
function hooks(sch::Schematic, node::ComponentNode)
    trans = transformation(sch, node)
    hs = hooks(component(node))
    if has_prop(sch.graph, node, :additional_hooks)
        hs = merge(hs, (; pairs(get_prop(sch.graph, node, :additional_hooks))...))
    end
    return NamedTuple{keys(hs)}(trans.(values(hs)))
end
hooks(sch::Schematic, i::Int) = hooks(sch, sch.graph[i])

function hooks(sch::Schematic, node::ComponentNode, hsym::Symbol)
    trans = transformation(sch, node)
    h = _hook(sch.graph, node, hsym)
    return trans(h)
end

"""
    origin(sch::Schematic, node::ComponentNode)
    origin(sch::Schematic, node_idx::Int)

The origin of `node` in the global coordinate system of `sch`.
"""
function origin(sch::Schematic{S}, node::ComponentNode, nodes::ComponentNode...) where {S}
    trans = transformation(sch, node, nodes...)
    return trans(zero(Point{S}))
end
origin(sch::Schematic, n::Int, ns::Int...) = origin(sch, getpath(sch.graph, n, ns...)...)

"""
    center(sch::Schematic, node::ComponentNode)
    center(sch::Schematic, node_idx::Int)

The center of the `bounds` of `node`'s component in the global coordinate system of `sch`.
"""
function center(sch::Schematic, node::ComponentNode, nodes::ComponentNode...)
    trans = transformation(sch, node, nodes...)
    n = isempty(nodes) ? node : last(nodes)
    return trans(center(component(n)))
end
center(sch::Schematic, n::Int, ns::Int...) = center(sch, getpath(sch.graph, n, ns...)...)

"""
    bounds(sch::Schematic, node::ComponentNode)
    bounds(sch::Schematic, node_idx::Int)

The `Rectangle` bounding the component in `node` in the global coordinate system of `sch`.
"""
function bounds(sch::Schematic, node::ComponentNode, nodes::ComponentNode...)
    trans = transformation(sch, node, nodes...)
    n = isempty(nodes) ? node : last(nodes)
    return bounds(trans(bounds(component(n))))
end
bounds(sch::Schematic, n::Int, ns::Int...) = bounds(sch, getpath(sch.graph, n, ns...)...)

"""
    find_components(f::Function, g::SchematicGraph; depth=-1)

Return the indices of the nodes in `sch` or `g` for which `f(component(node))` is `true`.

Keyword `depth` is the number of layers of the graph to search within, where the subgraph
of each `CompositeComponent` is a layer beyond the layer holding the `ComponentNode` for
that `CompositeComponent`. To search only top-level components, use `depth=1`. To search all
subgraphs recursively, use a negative depth (the default).

Indices for nodes in subgraphs are integers or `Tuple`s of integer indices, one for each
additional layer. For example, if a node containing a `CompositeComponent` has index `2`
in the top layer, then the third subcomponent in the `CompositeComponent`'s graph has
index `(2,3)`.
"""
function find_components(f::Function, g::SchematicGraph; depth=-1)
    return find_nodes(node -> f(component(node)), g; depth=depth)
end

"""
    find_components(comptype::Type{T}, sch::Schematic; depth=-1) where {T <: AbstractComponent}
    find_components(comptype::Type{T}, g::SchematicGraph; depth=-1) where {T <: AbstractComponent}

Return the indices of nodes containing components of type `T`.

See [`find_components(::Function, ::SchematicGraph)`](@ref).
"""
function find_components(
    comptype::Type{T},
    sch::Schematic;
    depth=-1
) where {T <: AbstractComponent}
    return find_components(comptype, sch.graph, depth=depth)
end
function find_components(
    comptype::Type{T},
    g::SchematicGraph;
    depth=-1
) where {T <: AbstractComponent}
    return find_components(x -> isa(x, T), g, depth=depth)
end

"""
    find_nodes(f::Function, g::SchematicGraph; depth=-1)

Return the indices of the nodes in `sch` or `g` for which `f(node)` is `true`.

Keyword `depth` is the number of layers of the graph to search within, where the subgraph
of each `CompositeComponent` is a layer beyond the layer holding the `ComponentNode` for
that `CompositeComponent`. To search only top-level components, use `depth=1`. To search all
subgraphs recursively, use a negative depth (the default).

Indices for nodes in subgraphs are integers or `Tuple`s of integer indices, one for each
additional layer. For example, if a node containing a `CompositeComponent` has index `2`
in the top layer, then the third subcomponent in the `CompositeComponent`'s graph has
index `(2,3)`.

See also [`find_components`](@ref), which checks `f(component(node))`.
"""
function find_nodes(f::Function, g::SchematicGraph; depth=-1)
    depth == 0 && return []
    all_idx = Union{Int, Tuple}[]
    push!(all_idx, findall(f, nodes(g))...)
    cc_idx = findall(x -> isa(x, AbstractCompositeComponent), components(g))
    for i in cc_idx
        sub_idx = find_nodes(f, graph(component(g[i])), depth=depth - 1)
        push!(all_idx, [(i, sub_i...) for sub_i in sub_idx]...)
    end
    return all_idx
end

"""
    replace_component!(sch::Schematic, node_index::Int, replacement::Function)

Replaces the component `c` at `node_index` in `sch` with `replacement(c)`.

`replacement` should return a new AbstractComponent with a unique name.
"""
function replace_component!(sch::Schematic, node_index::Int, replacement::Function)
    node = nodes(sch.graph)[node_index]
    newcomp = replacement(component(node))
    return replace_component!(sch, node, newcomp)
end

function replace_component!(
    sch::Schematic,
    node::ComponentNode,
    replacement::AbstractComponent
)
    node_cs = structure(sch.ref_dict[node])
    for (i, ref) in pairs(refs(node_cs))
        # Check name so we can replace a CoordinateSystem if sch was already built
        if name(structure(ref)) == name(node.component)
            refs(node_cs)[i] = sref(replacement, transformation(ref))
        end
    end
    return node.component = replacement
end

"""
    position_dependent_replace!(sch::Schematic{S}, node_index::Int, replacement::Function;
        schematic_origin_globalcoords=zero(Point{S})) where {S}

Replaces the component `c` at `node_index` in `sch` with `replacement`.

The replacement function should have a signature matching
`replacement(c<:AbstractComponent, c_origin_globalcoords::Point)`
where `c` is the component to be replaced and `c_origin_globalcoords` is the component's
origin in global coordinates. Here "global" coordinates are defined as those in which the
schematic's origin is the keyword argument `schematic_origin_globalcoords` in
`position_dependent_replace!`.

`replacement` should return a new AbstractComponent with a unique name.
"""
function position_dependent_replace!(
    sch::Schematic{S},
    node_index::Int,
    replacement::Function,
    args...;
    schematic_origin_globalcoords=zero(Point{S}),
    kwargs...
) where {S}
    node = nodes(sch.graph)[node_index]
    orig = origin(sch, node)
    return replace_component!(
        sch,
        node_index,
        (c) -> replacement(c, orig + schematic_origin_globalcoords)
    )
end

"""
    position_dependent_replace!(sch::Schematic{S}, comptype::Type{<:AbstractComponent},
        replacement::Function;
        schematic_origin_globalcoords=zero(Point{S})) where {S}

Replaces each component instance of type `comptype` in `sch` using `position_dependent_replace!`
with the replacement function `replacement(c<:AbstractComponent, c_origin_globalcoords::Point)`.
"""
function position_dependent_replace!(
    sch::Schematic{S},
    comptype::Type{<:AbstractComponent},
    replacement::Function;
    schematic_origin_globalcoords=zero(Point{S})
) where {S}
    idx = find_components(comptype, sch)
    return position_dependent_replace!.(
        sch,
        idx,
        replacement;
        schematic_origin_globalcoords=schematic_origin_globalcoords
    )
end

"""
    plan(g::SchematicGraph, hooks_fn=hooks; strict=:error, log_dir="build", log_level=Logging.Info)
    plan(g::SchematicGraph, t::Target; strict=:error, log_dir="build", log_level=Logging.Info)

Constructs a `Schematic` floorplan from `g` without rendering Components.

Iterates through the nodes in `g` depth-first to build a tree (or more than one, if the
graph is disconnected) of `CoordinateSystem`s satisfying the translations, reflections,
and rotations required by the hooks corresponding to each edge. Each `CoordinateSystem` holds
a `StructureReference` to the `Component` in the corresponding node. A new `Schematic` is created
containing references to the roots of these trees (sometimes called "rendering trees") as
well as a dictionary mapping each `ComponentNode` in `g` to the reference to that node's
`CoordinateSystem` in its rendering tree. (This is the reference stored by its parent.)

`plan` will ignore edges with the property `SchematicDrivenLayout.PLAN_SKIPS_EDGE=>true`.

The `strict` keyword should be `:error`, `:warn`, or `:no`.

The `strict=:error` keyword option causes `plan` to throw an error if any errors were logged during planning.
This is enabled by default, but can be disabled with `strict=:no`, in which case any node that was not
successfully placed relative to an existing node will simply appear at the origin.
Using `strict=:no` is recommended only for debugging purposes.

The `strict=:warn` keyword option causes `plan` to throw an error if any warnings were logged during planning.
This is disabled by default. Using `strict=:warn` is suggested for use in automated
pipelines, where warnings may require human review.

Log messages with level of at least `log_level` will be written to
`joinpath(log_dir, name(g) * ".log")`. If `logdir` is `nothing`, then no file will be written.
The same log file will be used for `build!` and `render!` stages of the schematic workflow.
"""
function plan(
    g::SchematicGraph,
    hooks_fn=hooks;
    strict=:error,
    log_dir="build",
    log_level=Logging.Info,
    id_prefix=""
)
    S = typeof(1.0DeviceLayout.UPREFERRED)
    !isempty(nodes(g)) && (S = coordinatetype(component(g[1])))
    floorplan = Schematic{S}(g; log_dir=log_dir, log_level=log_level)
    with_logger(floorplan.logger) do
        # Place constrained element
        for node in filter(n -> !(component(n) isa RouteComponent), nodes(g))
            if !haskey(floorplan.ref_dict, node)
                node_cs = CoordinateSystem{S}(id_prefix * node.id * "_node")
                node_ref = sref(node_cs)
                addref!(floorplan, node_ref)
                floorplan.ref_dict[node] = node_ref
                try
                    _plan!(floorplan, node_cs, node, hooks_fn, id_prefix)
                catch e
                    @error "Failed to plan top-level node $(node.id)" exception =
                        (e, catch_backtrace()) _group = :plan
                end
            end
        end
        # Resolve routes
        for node in filter(n -> (component(n) isa RouteComponent), nodes(g))
            node_cs = CoordinateSystem{S}(id_prefix * node.id * "_node")
            node_ref = sref(node_cs)
            addref!(floorplan, node_ref)
            floorplan.ref_dict[node] = node_ref
            try
                _plan_route!(floorplan, node_cs, node, hooks_fn)
            catch e
                @error "Failed to plan route $(node.id)" exception = (e, catch_backtrace()) _group =
                    :plan
            end
        end
    end # with_logger
    close_logfile(floorplan)
    if strict == :error
        max_level_logged(floorplan, :plan) >= Logging.Error && error(
            "Encountered errors during planning (place-and-route). See $(floorplan.logger.logname) for details. Plan with `strict=:no` to continue anyway (not recommended except for debugging)."
        )
    elseif strict == :warn
        max_level_logged(floorplan, :plan) >= Logging.Warn && error(
            "Encountered warnings during planning (place-and-route). See $(floorplan.logger.logname) for details. Plan with `strict=:error` to continue anyway."
        )
    elseif strict != :no
        @warn "Keyword `strict` in `plan` should be `:error`, `:warn`, or `:no` (got :$strict). Proceeding as though `strict=:no` were used."
    end
    return floorplan
end

plan(
    g::SchematicGraph,
    t::Target;
    strict=:error,
    log_dir="build",
    log_level=Logging.Info,
    id_prefix=""
) = plan(g; strict=strict, log_dir=log_dir, log_level=log_level, id_prefix=id_prefix)

function transformation(
    graph::SchematicGraph,
    parent_node::ComponentNode,
    node::ComponentNode,
    hooks_fn=hooks
)
    h1sym = get_prop(graph, node, parent_node, node)
    h2sym = get_prop(graph, node, parent_node, parent_node)
    hook1 = _hook(graph, node, h1sym, hooks_fn)
    hook2 = _hook(graph, parent_node, h2sym, hooks_fn)
    return transformation(hook2, hook1)
end

function _hook(g::SchematicGraph, node::ComponentNode, hsym::Symbol, hooks_fn=hooks)
    comp = component(node)
    if has_hook(comp, hsym)
        return hooks_fn(comp, hsym)
    elseif has_prop(g, node, :additional_hooks)
        add_hooks = get_prop(g, node, :additional_hooks)
        !haskey(add_hooks, hsym) && error(
            "Node $(node.id) does not have hook $hsym. Component hooks are $(keys(hooks(comp))); the node was also given additional hooks $(keys(add_hooks))"
        )
        return add_hooks[hsym]
    else
        error(
            "Node $(node.id) does not have hook $hsym. Component hooks are $(keys(hooks(comp)))."
        )
    end
end

function skips_edge(graph::SchematicGraph, parent::ComponentNode, child::ComponentNode)
    return has_prop(graph, parent, child, PLAN_SKIPS_EDGE) &&
           get_prop(graph, parent, child, PLAN_SKIPS_EDGE)
end

function _plan_route!(sch::Schematic, node_cs, node, hooks_fn=hooks)
    graph = sch.graph
    comp1 = component(node)
    nbrs = graph[neighbors(graph, node)]
    filter!(n -> !(skips_edge(graph, node, n)), nbrs) # Filter out from nbrs any nodes that have PLAN_SKIPS_EDGE=>true
    n0, n1 = (get_prop(graph, node, nbrs[1], node) == :p0) ? nbrs : reverse(nbrs)
    h0 = hooks_fn(sch, n0, get_prop(graph, n0, node, n0))
    h1 = hooks_fn(sch, n1, get_prop(graph, node, n1, n1))
    comp1.r.p0 = h0.p
    comp1.r.p1 = h1.p
    comp1.r.α0 = out_direction(h0)
    comp1.r.α1 = in_direction(h1)
    rot = Rotation(comp1.r.α0)
    if !comp1.global_waypoints
        comp1.r.waypoints = rot.(comp1.r.waypoints) .+ Ref(comp1.r.p0)
        comp1.r.waydirs = comp1.r.waydirs .+ comp1.r.α0
    end
    return addref!(node_cs, comp1)
end

function _plan!(sch::Schematic{S}, node_cs, node, hooks_fn=hooks, id_prefix="") where {S}
    addref!(node_cs, component(node))
    for idx in neighbors(sch.graph, node)
        child_node = nodes(sch.graph)[idx]
        if (component(child_node) isa RouteComponent) ||
           skips_edge(sch.graph, node, child_node)
            continue
        end

        # If neighbor is already in the graph, it's either the parent or a cycle
        if haskey(sch.ref_dict, child_node)
            # Is it the parent?
            nbr_cs = structure(sch.ref_dict[child_node])
            if node_cs in structure.(refs(nbr_cs))
                continue
            else # A cycle
                # Is it consistent?
                existing_trans = transformation(sch, child_node)
                new_trans =
                    transformation(sch, node) ∘
                    transformation(sch.graph, node, child_node, hooks_fn)
                isapprox(
                    existing_trans,
                    new_trans,
                    atol=1e-6 * DeviceLayout.onenanometer(S)
                ) && continue
                error(
                    """Node $(id_prefix * child_node.id) is overconstrained (part of an inconsistent cycle in the schematic graph).
                    Initially planned with global transformation $existing_trans
                    Attempted to plan under $(id_prefix * node.id) with global transformation $new_trans
                    Perhaps $(id_prefix * child_node.id) should be fused to $(id_prefix * node.id) with plan_skips_edge=true?
                    """
                )
            end
        end

        try
            child_node_cs = CoordinateSystem{S}(id_prefix * child_node.id * "_node")
            child_ref = sref(
                child_node_cs,
                convert(
                    ScaledIsometry{Point{S}},
                    transformation(sch.graph, node, child_node, hooks_fn)
                )
            )
            addref!(node_cs, child_ref)
            sch.ref_dict[child_node] = child_ref
            _plan!(sch, child_node_cs, child_node, hooks_fn, id_prefix)
        catch e
            @error "Failed to plan node $(id_prefix * child_node.id) under parent $(id_prefix * node.id)" exception =
                (e, catch_backtrace()) _group = :plan
        end
    end
end

"""
    check!(sch::Schematic; rules=[rotations_valid])

Verifies that `sch` satisfies `rule(sch) == true` for each `rule` in `rules`, and sets `sch.checked = true` if it does.

By default, checks that all checkable components have an allowed global orientation
([`rotations_valid(::Schematic)`](@ref)).
"""
function check!(sch::Schematic; rules=[rotations_valid])
    for rule in rules
        @assert rule(sch)
    end
    sch.checked[] = true
    return sch
end

"""
    rotations_valid(sch::Schematic)

Verifies that all checkable components in `sch` have the right orientation in the
global coordinate system (returns `true` if successful and throws an error otherwise).
A component of type `T` is checkable if `check_rotation(::T) = true`.
"""
function rotations_valid(sch::Schematic)
    for node_idx_path in find_components(check_rotation, sch.graph)
        node = sch.graph[node_idx_path]
        comp = component(node)
        θ = rotation(transformation(sch, node_idx_path...))
        if !any(ϕ -> isapprox_angle(ϕ, θ; atol=1e-6), allowed_rotation_angles(comp))
            error("The $(typeof(comp)) $(name(comp)) in node $(node.id) doesn't have
                    the correct global orientation.")
        end
    end
    return true # no errors encountered at this point
end

function index_layer!(sch::Schematic, ly, nextindex=1)
    index_components = ComponentNode[]
    # Index top-level schematic elements
    for (idx, m) in pairs(element_metadata(sch.coordinate_system))
        if (layer(m) == ly)
            element_metadata(sch.coordinate_system)[idx] = SemanticMeta(m, index=nextindex)
            nextindex = nextindex + 1
        end
    end
    # Index component-level elements
    for node in nodes(sch.graph)
        startindex = nextindex
        nextindex = index_layer!(coordsys(sch[node]), component(node), ly, nextindex)
        for _ = startindex:(nextindex - 1)
            push!(index_components, node)
        end
    end
    sch.index_dict[ly] = index_components
    return index_components
end

# Add indexed entity to parent node, so identical components are still reused
# Set index to zero within component
function index_layer!(
    parent_cs::CoordinateSystem,
    comp_cs::GeometryStructure,
    ly,
    nextindex=1
)
    for (cs, trans) in traversal(comp_cs)
        for (idx, el, m) in zip(1:length(elements(cs)), elements(cs), element_metadata(cs))
            if layer(m) == ly
                place!(parent_cs, trans(el), SemanticMeta(m, index=nextindex))
                element_metadata(cs)[idx] = SemanticMeta(m, index=0)
                nextindex = nextindex + 1
            end
        end
    end
    return nextindex
end

function traversal(cs::GeometryStructure, trans=DeviceLayout.ScaledIsometry())
    tv = [(cs, trans)]
    for ref in refs(cs)
        tv = vcat(tv, traversal(structure(ref), trans ∘ transformation(ref)))
    end
    return tv
end

"""
    crossovers!(sch::Schematic, xsty::DeviceLayout.Paths.Intersect.IntersectStyle)

Splice crossovers into intersecting `Path`s and `RouteComponent`s.

`RouteComponents` will cross over `Path`s, and otherwise components added to the
schematic graph later will cross over those added earlier.

# Example

```
    g = SchematicGraph("crossover_example")
    # ...
    floorplan = plan(g)
    xsty = Intersect.AirBridge(
        crossing_gap=5μm,
        foot_gap=2μm,
        foot_length=4μm,
        extent_gap=2μm,
        scaffold_gap=5μm,
        scaffold_meta=GDSMeta(5),
        air_bridge_meta=GDSMeta(3)
        )
    SchematicDrivenLayout.crossovers!(floorplan, xsty)
```
"""
function crossovers!(sch::Schematic, xsty::Intersect.IntersectStyle)
    paths_idx = find_components(Path, sch)
    routes_idx = find_components(RouteComponent, sch)
    return crossovers!(sch, xsty, sch.graph[paths_idx], sch.graph[routes_idx])
end

"""
    crossovers!(sch::Schematic, xsty::DeviceLayout.Paths.Intersect.IntersectStyle,
        nodes_1, nodes_2)

Splice crossovers into intersecting `Path`s and `RouteComponent`s.

Components in `nodes_2` will cross over any components in `nodes_1`, and otherwise
components added to the schematic graph later will cross over those added earlier.
"""
function crossovers!(
    sch::Schematic,
    xsty::Intersect.IntersectStyle,
    path_nodes,
    route_nodes
)
    sch_nodes = [path_nodes..., route_nodes...]

    path_comps = component.(path_nodes)
    route_comps = component.(route_nodes)

    paths = [path_comps..., (path.(route_comps))...]

    to_global = transformation.(sch, sch_nodes)
    global_paths = deepcopy.(paths)
    new_p0 = [a(p0(gp)) for (a, gp) in zip(to_global, global_paths)]
    new_α0 = rotated_direction.(α0.(global_paths), to_global)
    for (pa, α, pt) in zip(global_paths, new_α0, new_p0)
        pa.α0 = α
        pa.p0 = pt
        reconcile!(pa)
    end

    for (idx1, idx2, pt) in Intersect.prepared_intersections(global_paths)
        pathidx_1, pathnode_idx_1, s1 = idx1
        pathidx_2, pathnode_idx_2, s2 = idx2

        node_int_1 = (
            compnode=sch_nodes[pathidx_1],
            path=paths[pathidx_1],
            pathnode_idx=pathnode_idx_1,
            s=s1,
            a=to_global[pathidx_1]
        )
        node_int_2 = (
            compnode=sch_nodes[pathidx_2],
            path=paths[pathidx_2],
            pathnode_idx=pathnode_idx_2,
            s=s2,
            a=to_global[pathidx_2]
        )
        path_1, path_2 = crossover!(xsty, node_int_1, node_int_2, pt)
        # If a node had a RouteComponent, replace it with the path
        node_1 = node_int_1.compnode
        node_2 = node_int_2.compnode
        component(node_1) isa RouteComponent && replace_component!(sch, node_1, path_1)
        component(node_2) isa RouteComponent && replace_component!(sch, node_2, path_2)
    end
end

function crossover!(xsty, int1, int2, pt)
    (node_1, path_1, pathnode_idx_1, s1, a1) = int1
    (node_2, path_2, pathnode_idx_2, s2, a2) = int2

    try
        Intersect.intersect_pairwise!(
            xsty,
            path_1,
            pathnode_idx_1,
            s1,
            path_2,
            pathnode_idx_2,
            s2,
            a1=a1,
            a2=a2
        )
    catch e
        if e isa ErrorException
            error("""Intersection failed at $pt:
                $(e.msg)""")
        else
            throw(e)
        end
    end
    return path_1, path_2
end

"""
    build!(sch::Schematic, geometry_fn=geometry; strict=:error)
    build!(sch::Schematic, t::Target; strict=:error)

Replace the `AbstractComponent`s in `sch` with their `geometry`. Usually there's no reason to
do this, since `render!` will still render the geometry but won't modify `sch`.

Users must run `check!(sch)` before calling this method; otherwise, it will throw an error.

The `strict` keyword should be `:error`, `:warn`, or `:no`.

The `strict=:error` keyword option causes `build!` to throw an error if any errors were logged while
building component geometries.
This is enabled by default, but can be disabled with `strict=:no`, in which case any component which was not
successfully built will have an empty geometry.
Using `strict=:no` is recommended only for debugging purposes.

The `strict=:warn` keyword option causes `build!` to throw an error if any warnings were logged.
This is disabled by default. Using `strict=:warn` is suggested for use in automated
pipelines, where warnings may require human review.
"""
function build!(sch::Schematic, geometry_fn=geometry; strict=:error)
    sch.checked[] || error(
        "Cannot build an unchecked Schematic. Run check!(sch::Schematic), or override by setting sch.checked[] = true (not recommended!)"
    )
    reopen_logfile(sch, :build)
    with_logger(sch.logger) do
        for ref in values(sch.ref_dict)
            node_cs = structure(ref)
            # One of the node cs's references will be its Component
            for (i, subref) in pairs(refs(node_cs)) # Just check all of them
                if structure(subref) isa AbstractCompositeComponent
                    build!(schematic(structure(subref)); strict=strict)
                end
                if structure(subref) isa AbstractComponent
                    try
                        refs(node_cs)[i] =
                            sref(geometry_fn(structure(subref)), transformation(subref))
                    catch e
                        @error "Failed to build $(structure(subref)) in $(node_cs.name)" exception =
                            (e, catch_backtrace()) _group = :build
                        refs(node_cs)[i] = sref(
                            CoordinateSystem{coordinatetype(structure(subref))}(
                                name(structure(subref))
                            ),
                            transformation(subref)
                        )
                    end
                end
            end
        end
    end
    close_logfile(sch)
    if strict == :error
        max_level_logged(sch, :build) >= Logging.Error && error(
            "Encountered errors while building component geometry. See $(sch.logger.logname) for details. Build with `strict=:no` to continue anyway (not recommended except for debugging)."
        )
    elseif strict == :warn
        max_level_logged(sch, :build) >= Logging.Warn && error(
            "Encountered warnings while building component geometry. See $(sch.logger.logname) for details. Build with `strict=:error` to continue anyway."
        )
    elseif strict != :no
        @warn "Keyword `strict` in `build!` should be `:error`, `:warn`, or `:no` (got :$strict). Proceeding as though `strict=:no` were used."
    end
end
build!(sch::Schematic, t::Target; strict=:error) = build!(sch; strict=strict)

function DeviceLayout.halo(
    sch::Schematic,
    outer_delta,
    inner_delta=nothing;
    only_layers=[],
    ignore_layers=[]
)
    return halo(
        sch.coordinate_system,
        outer_delta,
        inner_delta;
        only_layers=only_layers,
        ignore_layers=ignore_layers
    )
end

"""
    render!(
        cs::AbstractCoordinateSystem,
        sch::Schematic,
        target::LayoutTarget;
        strict=:error,
        kwargs...
    )

Render the schematic `sch` to `cs` using `target`'s rendering options, without modifying `sch`.

Users must run `check!(sch)` before calling this method; otherwise, it will throw an error.

The `strict` keyword should be `:error`, `:warn`, or `:no`.

The `strict=:error` keyword option causes `render!` to throw an error if any errors were logged while
building component geometries or while rendering geometries to `cs`.
This is enabled by default, but can be disabled with `strict=:no`, in which case any component which was not
successfully built will have an empty geometry, and any non-fatal rendering errors will be
ignored as usual.
Using `strict=:no` is recommended only for debugging purposes.

The `strict=:warn` keyword option causes `render!` to throw an error if any warnings were logged.
This is disabled by default. Using `strict=:warn` is suggested for use in automated
pipelines, where warnings may require human review.
"""
function render!(
    cs::AbstractCoordinateSystem,
    sch::Schematic,
    target::LayoutTarget;
    strict=:error,
    kwargs...
)
    sch.checked[] || error(
        "Cannot render an unchecked Schematic. Run check!(sch::Schematic), or override by setting sch.checked[] = true (not recommended!)"
    )
    reopen_logfile(sch, :render)
    with_logger(sch.logger) do
        return render!(cs, sch.coordinate_system; _maps(target)..., kwargs...)
    end
    close_logfile(sch)
    if strict == :error
        max_level_logged(sch, :render) >= Logging.Error && error(
            "Encountered errors while rendering. See $(sch.logger.logname) for details. Render with `strict=:no` to continue anyway (not recommended except for debugging)."
        )
    elseif strict == :warn
        max_level_logged(sch, :render) >= Logging.Warn && error(
            "Encountered warnings while rendering. See $(sch.logger.logname) for details. Render with `strict=:error` to continue anyway."
        )
    elseif strict != :no
        @warn "Keyword `strict` in `render!` should be `:error`, `:warn`, or `:no` (got `:$strict`). Proceeding as though `strict=:no` were used."
    end
    return cs
end
